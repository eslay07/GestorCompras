#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Actualiza los módulos de Descargas OC para que solo se inicien
a través del inicio de sesión principal del GestorCompras.
"""
from __future__ import annotations
from pathlib import Path

ROOT = Path(__file__).parent.resolve()

FILES = {
    'DescargasOC-main/descargas_oc/ui.py': 'import tkinter as tk\nimport threading\nimport logging\nimport re\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path\nfrom tkinter import messagebox\n\ntry:  # permite ejecutar como script\n    from .escuchador import buscar_ocs, cargar_ultimo_uidl, registrar_procesados\n    from .selenium_modulo import descargar_oc\n    from .reporter import enviar_reporte\n    from .config import Config\n    from .logger import get_logger\nexcept ImportError:  # pragma: no cover\n    from escuchador import buscar_ocs, cargar_ultimo_uidl, registrar_procesados\n    from selenium_modulo import descargar_oc\n    from reporter import enviar_reporte\n    from config import Config\n    from logger import get_logger\n\nlogger = get_logger(__name__)\n\nscanning_lock = threading.Lock()\n\n\ndef center_window(win: tk.Tk | tk.Toplevel):\n    win.update_idletasks()\n    w = win.winfo_width()\n    h = win.winfo_height()\n    x = (win.winfo_screenwidth() // 2) - (w // 2)\n    y = (win.winfo_screenheight() // 2) - (h // 2)\n    win.geometry(f"{w}x{h}+{x}+{y}")\n\n\ndef config_completa(cfg: Config) -> bool:\n    try:\n        cfg.validate()\n    except Exception:\n        return False\n    requeridos = [\n        cfg.usuario,\n        cfg.password,\n        cfg.carpeta_destino_local,\n        cfg.carpeta_analizar,\n        cfg.seafile_url,\n        cfg.seafile_repo_id,\n        cfg.correo_reporte,\n    ]\n    return all(requeridos)\n\n\nclass TextHandler(logging.Handler):\n    def __init__(self, widget: tk.Text):\n        super().__init__()\n        self.widget = widget\n\n    def emit(self, record: logging.LogRecord):\n        msg = self.format(record) + "\\n"\n        self.widget.after(0, lambda m=msg: (self.widget.insert(tk.END, m), self.widget.see(tk.END)))\n\n\ndef realizar_escaneo(text_widget: tk.Text, lbl_last: tk.Label):\n    if not scanning_lock.acquire(blocking=False):\n        text_widget.insert(tk.END, "Escaneo en progreso...\\n")\n        text_widget.see(tk.END)\n        return\n    try:\n        cfg = Config()\n        if not config_completa(cfg):\n            messagebox.showerror(\n                "Error", "Configuración incompleta o por favor configurar correctamente"\n            )\n            return\n\n        def append(msg: str):\n            text_widget.after(0, lambda m=msg: (text_widget.insert(tk.END, m), text_widget.see(tk.END)))\n\n        append("Buscando órdenes...\\n")\n        ordenes, ultimo = buscar_ocs(cfg)\n        uidl_por_numero = {\n            o.get("numero"): o.get("uidl")\n            for o in ordenes\n            if o.get("numero") and o.get("uidl")\n        }\n        uidl_a_numeros: dict[str, set[str]] = {}\n        for numero, uidl in uidl_por_numero.items():\n            if not uidl:\n                continue\n            uidl_a_numeros.setdefault(uidl, set()).add(numero)\n        pendientes_uidls = set(uidl_a_numeros)\n        exitosas: list[str] = []\n        faltantes: list[str] = []\n        errores: list[str] = []\n        if ordenes:\n            append(f"Procesando {len(ordenes)} OC(s)\\n")\n            try:\n                subidos, no_encontrados, errores = descargar_oc(\n                    ordenes, headless=cfg.headless\n                )\n            except Exception as exc:  # pragma: no cover - seguridad en ejecución\n                logger.exception("Fallo al descargar OC")\n                errores = [str(exc)]\n                subidos, no_encontrados = [], [o.get("numero") for o in ordenes]\n            exitosas.extend(subidos)\n            faltantes.extend(no_encontrados)\n            numeros_con_problemas = {str(n) for n in no_encontrados}\n            for error in errores:\n                m = re.search(r"OC\\s*(\\d+)", error)\n                if m:\n                    numeros_con_problemas.add(m.group(1))\n            uidls_con_problemas = {\n                uidl_por_numero[num]\n                for num in numeros_con_problemas\n                if num in uidl_por_numero and uidl_por_numero[num]\n            }\n            subidos_set = set(subidos)\n            uidls_exitosos: list[str] = []\n            for orden in ordenes:\n                uidl = orden.get("uidl")\n                if not uidl or uidl in uidls_con_problemas:\n                    continue\n                numeros_uidl = uidl_a_numeros.get(uidl, set())\n                if numeros_uidl and numeros_uidl.issubset(subidos_set) and uidl not in uidls_exitosos:\n                    uidls_exitosos.append(uidl)\n            pendientes_uidls -= set(uidls_exitosos)\n            for num in subidos:\n                append(f"✔️ OC {num} procesada\\n")\n            for num in no_encontrados:\n                append(f"❌ OC {num} faltante\\n")\n            if uidls_exitosos:\n                uidls_sin_duplicados = list(dict.fromkeys(uidls_exitosos))\n                ultimo_guardar = ultimo if not pendientes_uidls else None\n                registrar_procesados(uidls_sin_duplicados, ultimo_guardar)\n        else:\n            append("No se encontraron nuevas órdenes\\n")\n        enviado = enviar_reporte(exitosas, faltantes, ordenes, cfg)\n        if ordenes:\n            if errores:\n                summary = "Errores durante la descarga:\\n" + "\\n".join(errores)\n            elif enviado:\n                summary = "ORDENES DE COMPRA DESCARGADAS Y REPORTE ENVIADO"\n            else:\n                summary = "No se pudo enviar el reporte"\n            text_widget.after(0, lambda: messagebox.showinfo("Resultado", summary))\n        append("Proceso finalizado\\n")\n        lbl_last.config(\n            text="Último UIDL: {} - {}".format(\n                cargar_ultimo_uidl(), datetime.now().strftime("%H:%M:%S")\n            )\n        )\n    finally:\n        scanning_lock.release()\n\n\ndef main():\n    root = tk.Tk()\n    root.title("Descargas OC")\n    root.tk_setPalette(\n        background="#1e1e1e",\n        foreground="#f0f0f0",\n        activeBackground="#333333",\n        activeForeground="#f0f0f0",\n        highlightColor="#555555",\n    )\n    root.configure(bg="#1e1e1e")\n\n    frame = tk.Frame(root)\n    frame.pack(padx=10, pady=10)\n\n    text = tk.Text(frame, width=80, height=20, bg="#000000", fg="#f0f0f0", insertbackground="#f0f0f0")\n    text.pack(pady=5)\n\n    handler = TextHandler(text)\n    handler.setFormatter(logging.Formatter(\'%(asctime)s [%(levelname)s] %(message)s\'))\n    logging.getLogger().addHandler(handler)\n\n    estado = {"activo": False, "contador": 0}\n    lbl_contador = tk.Label(frame, text="Escuchador detenido")\n    lbl_contador.pack()\n    lbl_last = tk.Label(frame, text="Último UIDL: " + (cargar_ultimo_uidl() or \'-\'))\n    lbl_last.pack()\n\n    cfg = Config()\n    manual_mode = {"active": False}\n\n    def actualizar_contador():\n        if estado["activo"]:\n            if estado["contador"] <= 0:\n                threading.Thread(target=realizar_escaneo, args=(text, lbl_last), daemon=True).start()\n                estado["contador"] = cfg.scan_interval\n            lbl_contador.config(text=f"Siguiente escaneo en {estado[\'contador\']} s")\n            estado["contador"] -= 1\n            root.after(1000, actualizar_contador)\n        else:\n            lbl_contador.config(text="Escuchador detenido")\n\n    def toggle():\n        if estado["activo"]:\n            estado["activo"] = False\n            btn_toggle.config(text="Activar escuchador")\n        else:\n            if not config_completa(cfg):\n                messagebox.showerror(\n                    "Error",\n                    "Configuración incompleta o por favor configurar correctamente",\n                )\n                return\n            estado["activo"] = True\n            estado["contador"] = cfg.scan_interval\n            btn_toggle.config(text="Detener escuchador")\n            actualizar_contador()\n\n    def escanear_ahora():\n        estado["contador"] = cfg.scan_interval\n        threading.Thread(target=realizar_escaneo, args=(text, lbl_last), daemon=True).start()\n\n    def activar_manual():\n        manual_mode["active"] = True\n        text.delete("1.0", tk.END)\n        text.insert(tk.END, "Introduzca ordenes que desea descargar 1 por linea:\\n")\n        btn_ejecutar.config(state=tk.DISABLED)\n        text.focus_set()\n\n    def check_manual_input(event=None):\n        if manual_mode["active"]:\n            contenido = text.get("2.0", tk.END).strip()\n            btn_ejecutar.config(state=tk.NORMAL if contenido else tk.DISABLED)\n\n    text.bind("<KeyRelease>", check_manual_input)\n\n    def ejecutar_manual():\n        if not scanning_lock.acquire(blocking=False):\n            text.insert(tk.END, "Descarga en progreso...\\n")\n            text.see(tk.END)\n            return\n        contenido = text.get("2.0", tk.END).strip()\n        numeros = [n.strip() for n in contenido.splitlines() if n.strip()]\n        if not numeros:\n            scanning_lock.release()\n            return\n        if not messagebox.askyesno(\n            "Confirmación",\n            "Se descargarán las siguientes órdenes:\\n" + "\\n".join(numeros),\n        ):\n            scanning_lock.release()\n            return\n        text.delete("1.0", tk.END)\n        manual_mode["active"] = False\n        btn_ejecutar.config(state=tk.DISABLED)\n\n        def run():\n            try:\n                cfg.load()\n                ordenes = [{"numero": n} for n in numeros]\n\n                def append(msg: str):\n                    text.after(0, lambda m=msg: (text.insert(tk.END, m), text.see(tk.END)))\n\n                append(f"Procesando {len(ordenes)} OC(s)\\n")\n                try:\n                    subidos, no_encontrados, errores = descargar_oc(\n                        ordenes, headless=cfg.headless\n                    )\n                except Exception as exc:\n                    errores = [str(exc)]\n                    subidos, no_encontrados = [], numeros\n                for num in subidos:\n                    append(f"✔️ OC {num} procesada\\n")\n                for num in no_encontrados:\n                    append(f"❌ OC {num} faltante\\n")\n                enviar_reporte(subidos, no_encontrados, ordenes, cfg)\n                if errores:\n                    summary = "Errores durante la descarga:\\n" + "\\n".join(errores)\n                else:\n                    summary = "Proceso finalizado"\n                text.after(0, lambda: messagebox.showinfo("Resultado", summary))\n            finally:\n                scanning_lock.release()\n                text.after(0, lambda: btn_ejecutar.config(state=tk.DISABLED))\n\n        threading.Thread(target=run, daemon=True).start()\n\n    def actualizar_intervalo():\n        try:\n            val = int(entry_interval.get())\n            if val >= 300:\n                cfg.load()\n                cfg.data[\'scan_interval\'] = val\n                cfg.save()\n                estado[\'contador\'] = val\n        except ValueError:\n            pass\n\n    btn_toggle = tk.Button(frame, text="Activar escuchador", command=toggle)\n    btn_toggle.pack(side=tk.LEFT, padx=5)\n\n    btn_escanear = tk.Button(frame, text="Escanear ahora", command=escanear_ahora)\n    btn_escanear.pack(side=tk.LEFT, padx=5)\n\n    btn_manual = tk.Button(frame, text="Descarga manual", command=activar_manual)\n    btn_manual.pack(side=tk.LEFT, padx=5)\n    btn_ejecutar = tk.Button(frame, text="Ejecutar descarga", command=ejecutar_manual, state=tk.DISABLED)\n    btn_ejecutar.pack(side=tk.LEFT, padx=5)\n\n    var_bienes = tk.BooleanVar(value=bool(cfg.compra_bienes))\n\n    def actualizar_bienes():\n        cfg.load()\n        cfg.data[\'compra_bienes\'] = var_bienes.get()\n        cfg.save()\n\n    chk_bienes = tk.Checkbutton(\n        frame,\n        text="Compra Bienes",\n        variable=var_bienes,\n        command=actualizar_bienes,\n        selectcolor="#00aa00",\n    )\n    chk_bienes.pack(side=tk.LEFT, padx=5)\n\n    var_visible = tk.BooleanVar(value=not bool(cfg.headless))\n\n    def actualizar_visible():\n        cfg.load()\n        cfg.data[\'headless\'] = not var_visible.get()\n        cfg.save()\n\n    chk_visible = tk.Checkbutton(\n        frame,\n        text="Descarga visible",\n        variable=var_visible,\n        command=actualizar_visible,\n        selectcolor="#00aa00",\n    )\n    chk_visible.pack(side=tk.LEFT, padx=5)\n\n    tk.Label(frame, text="Intervalo(seg):").pack(side=tk.LEFT, padx=5)\n    entry_interval = tk.Entry(frame, width=5)\n    entry_interval.insert(0, str(cfg.scan_interval))\n    entry_interval.pack(side=tk.LEFT)\n    btn_interval = tk.Button(frame, text="Guardar", command=actualizar_intervalo)\n    btn_interval.pack(side=tk.LEFT, padx=5)\n\n    center_window(root)\n    root.mainloop()\n\n\nif __name__ == \'__main__\':\n    repo_root = Path(__file__).resolve().parents[2]\n    if str(repo_root) not in sys.path:\n        sys.path.insert(0, str(repo_root))\n    try:\n        from GestorCompras_.gestorcompras import main as gestor_main\n    except ImportError:\n        try:\n            from gestorcompras import main as gestor_main\n        except ImportError as exc:  # pragma: no cover - seguridad en ejecución directa\n            raise SystemExit(\n                "No se encontró el módulo principal de inicio de sesión. "\n                "Ejecute GestorCompras desde su lanzador oficial."\n            ) from exc\n\n    gestor_main.main()\n',
    'DescargasOC-main/descargas_oc/ui_abastecimiento.py': '"""Interfaz para descargar órdenes de compra de Abastecimiento."""\nimport threading\nimport tkinter as tk\nimport sys\nfrom pathlib import Path\nfrom tkinter import messagebox\nfrom tkinter import ttk\n\ntry:  # permite ejecutar como script\n    from .selenium_abastecimiento import descargar_abastecimiento\n    from .config import Config\nexcept ImportError:  # pragma: no cover\n    from selenium_abastecimiento import descargar_abastecimiento\n    from config import Config\n\nlock = threading.Lock()\n\n# Valor por defecto para el campo "Solicitante"\nDEFAULT_SOLICITANTE = "1221 - HERRERA PUENTE WILLIAM"\n\n\ndef ejecutar(entry_fd, entry_fh, entry_sol, entry_aut, btn):\n    if not lock.acquire(blocking=False):\n        messagebox.showinfo("Proceso en curso", "Ya existe una descarga en ejecución")\n        return\n\n    fd = entry_fd.get().strip()\n    fh = entry_fh.get().strip()\n    sol = entry_sol.get().strip()\n    aut = entry_aut.get().strip()\n    cfg = Config()\n    btn.config(state=tk.DISABLED)\n\n    def tarea():\n        try:\n            descargar_abastecimiento(\n                fd, fh, sol, aut, headless=cfg.abastecimiento_headless\n            )\n            messagebox.showinfo("Finalizado", "Proceso completado")\n        except Exception as exc:\n            messagebox.showerror("Error", str(exc))\n        finally:\n            lock.release()\n            btn.config(state=tk.NORMAL)\n\n    threading.Thread(target=tarea, daemon=True).start()\n\n\ndef main():\n    root = tk.Tk()\n    root.title("Descarga Abastecimiento")\n    root.tk_setPalette(\n        background="#1e1e1e",\n        foreground="#f0f0f0",\n        activeBackground="#333333",\n        activeForeground="#f0f0f0",\n        highlightColor="#555555",\n    )\n    root.configure(bg="#1e1e1e")\n\n    tk.Label(root, text="Fecha inicio (dd/mm/aa):").grid(row=0, column=0, sticky="e")\n    entry_fd = tk.Entry(root)\n    entry_fd.grid(row=0, column=1, padx=5, pady=2)\n\n    tk.Label(root, text="Fecha final (dd/mm/aa):").grid(row=1, column=0, sticky="e")\n    entry_fh = tk.Entry(root)\n    entry_fh.grid(row=1, column=1, padx=5, pady=2)\n\n    cfg = Config()\n    tk.Label(root, text="Solicitante:").grid(row=2, column=0, sticky="e")\n    solicitantes = cfg.abastecimiento_solicitantes or []\n    if DEFAULT_SOLICITANTE not in solicitantes:\n        solicitantes.insert(0, DEFAULT_SOLICITANTE)\n    sol_var = tk.StringVar(value=DEFAULT_SOLICITANTE)\n    entry_sol = ttk.Combobox(\n        root,\n        textvariable=sol_var,\n        values=solicitantes,\n        width=40,\n    )\n    entry_sol.grid(row=2, column=1, padx=5, pady=2)\n\n    tk.Label(root, text="Autoriza:").grid(row=3, column=0, sticky="e")\n    aut_var = tk.StringVar()\n    entry_aut = ttk.Combobox(\n        root,\n        textvariable=aut_var,\n        values=cfg.abastecimiento_autorizadores or [],\n        width=40,\n    )\n    entry_aut.grid(row=3, column=1, padx=5, pady=2)\n\n    var_visible = tk.BooleanVar(value=not bool(cfg.headless))\n\n    def actualizar_visible():\n        cfg.load()\n        cfg.data["headless"] = not var_visible.get()\n        cfg.save()\n\n    chk_visible = tk.Checkbutton(\n        root,\n        text="Descarga visible",\n        variable=var_visible,\n        command=actualizar_visible,\n        selectcolor="#00aa00",\n    )\n    chk_visible.grid(row=4, column=1, sticky="w", padx=5, pady=2)\n\n    btn_ejecutar = tk.Button(\n        root,\n        text="Descargar",\n        command=lambda: ejecutar(entry_fd, entry_fh, entry_sol, entry_aut, btn_ejecutar),\n    )\n    btn_ejecutar.grid(row=5, column=0, columnspan=2, pady=10)\n\n    def abrir_config():\n        configurar_abastecimiento()\n        nuevo = Config()\n        if entry_sol.winfo_exists():\n            solicitantes = nuevo.abastecimiento_solicitantes or []\n            if DEFAULT_SOLICITANTE not in solicitantes:\n                solicitantes.insert(0, DEFAULT_SOLICITANTE)\n            entry_sol[\'values\'] = solicitantes\n            sol_var.set(DEFAULT_SOLICITANTE)\n        if entry_aut.winfo_exists():\n            entry_aut[\'values\'] = nuevo.abastecimiento_autorizadores or []\n\n    btn_cfg = tk.Button(root, text="Configurar", command=abrir_config)\n    btn_cfg.grid(row=6, column=0, columnspan=2, pady=(0, 10))\n\n    def center_window(win):\n        win.update_idletasks()\n        w = win.winfo_width()\n        h = win.winfo_height()\n        x = (win.winfo_screenwidth() // 2) - (w // 2)\n        y = (win.winfo_screenheight() // 2) - (h // 2)\n        win.geometry(f"{w}x{h}+{x}+{y}")\n\n    center_window(root)\n    root.mainloop()\n\n\nif __name__ == "__main__":  # pragma: no cover\n    repo_root = Path(__file__).resolve().parents[2]\n    if str(repo_root) not in sys.path:\n        sys.path.insert(0, str(repo_root))\n    try:\n        from GestorCompras_.gestorcompras import main as gestor_main\n    except ImportError:\n        try:\n            from gestorcompras import main as gestor_main\n        except ImportError as exc:\n            raise SystemExit(\n                "No se encontró el módulo principal de inicio de sesión. "\n                "Ejecute GestorCompras desde su lanzador oficial."\n            ) from exc\n\n    gestor_main.main()\n',
}

def apply() -> None:
    for rel_path, content in FILES.items():
        target = ROOT / rel_path
        target.parent.mkdir(parents=True, exist_ok=True)
        backup = target.with_suffix(target.suffix + '.bak')
        if not backup.exists() and target.exists():
            backup.write_text(target.read_text(), encoding='utf-8')
        target.write_text(content, encoding='utf-8')
        print(f'Actualizado {target}')


def main() -> None:
    apply()


if __name__ == '__main__':
    main()
