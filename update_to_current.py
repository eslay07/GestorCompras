#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Aplica los cambios acumulados hasta la versión actual del GestorCompras.
"""
from __future__ import annotations
from pathlib import Path

ROOT = Path(__file__).parent.resolve()

FILES = {
    'DescargasOC-main/descargas_oc/config.py': 'import json\nimport os\nimport uuid\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\n\nBASE_DIR = Path(__file__).resolve().parents[1]\n\n\ndef _default_path() -> str:\n    data_dir = BASE_DIR / \'data\'\n    data_dir.mkdir(exist_ok=True)\n    return os.getenv(\'CONFIG_PATH\', str(data_dir / \'config.json\'))\n\n\nclass Config:\n    def __init__(self, path: str | None = None):\n        self.path = path or _default_path()\n        self.data: dict = {}\n        self.load()\n\n    def load(self):\n        load_dotenv()\n        try:\n            with open(self.path, \'r\') as f:\n                self.data = json.load(f)\n        except FileNotFoundError:\n            self.data = {}\n        # sobrescribe credenciales con variables de entorno cuando existan\n        self.data[\'usuario\'] = os.getenv(\'USUARIO_OC\', self.data.get(\'usuario\'))\n        self.data[\'password\'] = os.getenv(\'PASSWORD_OC\', self.data.get(\'password\'))\n        self.data[\'pop_server\'] = os.getenv(\'POP_SERVER\', self.data.get(\'pop_server\'))\n        self.data[\'remitente_adicional\'] = os.getenv(\n            \'REMITENTE_ADICIONAL\', self.data.get(\'remitente_adicional\')\n        )\n\n        def _parse_int(value, default):\n            try:\n                return int(value)\n            except (TypeError, ValueError):\n                return default\n\n        def _parse_bool(value, default):\n            if isinstance(value, bool):\n                return value\n            if isinstance(value, str):\n                lowered = value.strip().lower()\n                if lowered in {"1", "true", "t", "yes", "si", "sí"}:\n                    return True\n                if lowered in {"0", "false", "f", "no"}:\n                    return False\n            if isinstance(value, (int, float)):\n                return bool(value)\n            return default\n\n        self.data[\'pop_port\'] = _parse_int(\n            os.getenv(\'POP_PORT\', self.data.get(\'pop_port\', 995)), 995\n        )\n        self.data[\'smtp_server\'] = os.getenv(\n            \'SMTP_SERVER\', self.data.get(\'smtp_server\', \'smtp.telconet.ec\')\n        )\n        self.data[\'smtp_port\'] = _parse_int(\n            os.getenv(\'SMTP_PORT\', self.data.get(\'smtp_port\', 587)), 587\n        )\n        self.data[\'smtp_ssl_port\'] = _parse_int(\n            os.getenv(\'SMTP_SSL_PORT\', self.data.get(\'smtp_ssl_port\', 465)), 465\n        )\n        self.data[\'smtp_plain_port\'] = _parse_int(\n            os.getenv(\'SMTP_PLAIN_PORT\', self.data.get(\'smtp_plain_port\', 25)), 25\n        )\n        self.data[\'smtp_usuario\'] = os.getenv(\n            \'SMTP_USER\',\n            self.data.get(\'smtp_usuario\', self.data.get(\'usuario\')),\n        )\n        self.data[\'smtp_password\'] = os.getenv(\n            \'SMTP_PASSWORD\',\n            self.data.get(\'smtp_password\', self.data.get(\'password\')),\n        )\n        headless_raw = os.getenv(\'HEADLESS\', self.data.get(\'headless\'))\n        headless_val = _parse_bool(headless_raw, False)\n        self.data[\'headless\'] = headless_val\n\n        abas_headless_raw = os.getenv(\n            \'ABASTECIMIENTO_HEADLESS\',\n            self.data.get(\'abastecimiento_headless\', headless_val),\n        )\n        self.data[\'abastecimiento_headless\'] = _parse_bool(\n            abas_headless_raw,\n            headless_val,\n        )\n        self.data.setdefault(\'max_threads\', 5)\n        self.data.setdefault(\'batch_size\', 50)\n\n        interval = os.getenv(\'SCAN_INTERVAL\', self.data.get(\'scan_interval\'))\n        try:\n            val = int(interval) if interval else 300\n        except (TypeError, ValueError):\n            val = 300\n        if val < 300:\n            val = 300\n        self.data[\'scan_interval\'] = val\n\n        # valores predeterminados cuando el archivo de configuración está vacío\n        self.data.setdefault(\'pop_server\', \'pop.telconet.ec\')\n        self.data.setdefault(\'pop_port\', 995)\n        self.data.setdefault(\'usuario\', \'jotoapanta@telconet.ec\')\n        self.data.setdefault(\'carpeta_destino_local\', r\'E:\\Seadrive\\jotoapan_1\\Shared with me\\BD_TELCO\\BIENES\')\n        self.data.setdefault(\'carpeta_analizar\', r\'E:\\Seadrive\\jotoapan_1\\Shared with me\\BD_TELCO\\BIENES\')\n        self.data.setdefault(\'seafile_url\', \'https://telcodrive.telconet.net\')\n        self.data.setdefault(\'seafile_repo_id\', \'ede837d2-5de8-45f8-802d-aa513aaad8b2\')\n        self.data.setdefault(\'seafile_subfolder\', \'/prueba\')\n        self.data.setdefault(\'correo_reporte\', \'jotoapanta@telconet.ec\')\n        self.data.setdefault(\'remitente_adicional\', \'naf@telconet.ec\')\n        self.data.setdefault(\'smtp_server\', \'smtp.telconet.ec\')\n        self.data.setdefault(\'smtp_port\', 587)\n        self.data.setdefault(\'smtp_ssl_port\', 465)\n        self.data.setdefault(\'smtp_plain_port\', 25)\n        self.data.setdefault(\'smtp_usuario\', self.data.get(\'usuario\'))\n        self.data.setdefault(\'smtp_password\', self.data.get(\'password\'))\n        self.data.setdefault(\'compra_bienes\', False)\n        self.data.setdefault(\'headless\', False)\n        self.data.setdefault(\'abastecimiento_mover_archivos\', False)\n        self.data.setdefault(\'abastecimiento_headless\', self.data[\'headless\'])\n        self.data.setdefault(\n            \'abastecimiento_carpeta_descarga\', self.data.get(\'carpeta_destino_local\')\n        )\n        self.data.setdefault(\n            \'abastecimiento_correo_reporte\', self.data.get(\'correo_reporte\')\n        )\n        self.data.setdefault(\'abastecimiento_solicitantes\', [])\n        self.data.setdefault(\'abastecimiento_autorizadores\', [])\n\n        def _normalize_list(key: str) -> None:\n            raw = self.data.get(key)\n            normalized: list[str] = []\n            if raw is None:\n                pass\n            elif isinstance(raw, str):\n                normalized = [part.strip() for part in raw.split(\',\') if part.strip()]\n            else:\n                try:\n                    iterable = list(raw)\n                except TypeError:\n                    iterable = [raw]\n                for item in iterable:\n                    text = str(item).strip()\n                    if text:\n                        normalized.append(text)\n            self.data[key] = normalized\n\n        _normalize_list(\'abastecimiento_solicitantes\')\n        _normalize_list(\'abastecimiento_autorizadores\')\n        # guarda los valores para conservar la configuración entre ejecuciones\n        self.save()\n        return self\n\n    def save(self):\n        Path(self.path).parent.mkdir(parents=True, exist_ok=True)\n        with open(self.path, \'w\') as f:\n            json.dump(self.data, f, indent=2)\n\n    # accesores de conveniencia para las propiedades\n    def __getattr__(self, item):\n        return self.data.get(item)\n\n    # validaciones\n    def validate(self):\n        repo_id = self.data.get(\'seafile_repo_id\', \'\')\n        try:\n            uuid.UUID(repo_id)\n        except Exception as exc:\n            raise ValueError("seafile_repo_id invalido") from exc\n        sub = (self.data.get(\'seafile_subfolder\', \'/\') or \'/\').strip()\n        if not sub.startswith(\'/\'):\n            sub = \'/\' + sub\n        self.data[\'seafile_subfolder\'] = sub\n        if not self.data.get(\'pop_server\'):\n            raise ValueError(\'pop_server requerido\')\n        if not self.data.get(\'pop_port\'):\n            raise ValueError(\'pop_port requerido\')\n        return True\n\n\n',
    'DescargasOC-main/descargas_oc/escuchador.py': 'import poplib\nfrom email import parser as email_parser\nfrom email.header import decode_header, make_header\nfrom email.utils import getaddresses\nimport json\nimport re\nimport html\nfrom concurrent.futures import ThreadPoolExecutor\nfrom pathlib import Path\n\ntry:  # permite ejecutar como script sin el paquete instalado\n    from .config import Config\n    from .logger import get_logger\nexcept ImportError:  # pragma: no cover\n    from config import Config\n    from logger import get_logger\n\nlogger = get_logger(__name__)\n\nDATA_DIR = Path(__file__).resolve().parents[1] / \'data\'\nPROCESADOS_FILE = DATA_DIR / \'procesados.txt\'\nLAST_UIDL_FILE = DATA_DIR / \'last_uidl.txt\'\nORDENES_TMP = DATA_DIR / \'ordenes_tmp.json\'\nREMITENTES_BASE = {\n    \'jotoapanta@telconet.ec\',\n    \'naf@telconet.ec\',\n}\n\n\ndef _normalizar_remitentes(valor: str | None) -> set[str]:\n    """Extrae direcciones de correo en minúsculas desde un encabezado."""\n\n    if not valor:\n        return set()\n    parsed = {\n        addr.strip().lower()\n        for _, addr in getaddresses([valor.replace(\';\', \',\')])\n        if addr\n    }\n    if parsed:\n        return parsed\n    return {valor.strip().lower()}\n\n\ndef _conjunto_remitentes(valor) -> set[str]:\n    """Convierte diferentes formatos (str, lista) en un conjunto de correos."""\n\n    if not valor:\n        return set()\n    if isinstance(valor, str):\n        return _normalizar_remitentes(valor)\n    remitentes: set[str] = set()\n    try:\n        iterable = list(valor)\n    except TypeError:\n        return _normalizar_remitentes(str(valor))\n    for item in iterable:\n        remitentes.update(_normalizar_remitentes(str(item)))\n    return remitentes\n\n\ndef _limpiar_html(valor: str) -> str:\n    """Convierte HTML básico en texto plano preservando saltos de línea."""\n\n    if not valor:\n        return ""\n    texto = re.sub(r"(?i)<br\\s*/?>", "\\n", valor)\n    texto = re.sub(r"(?i)</p>", "\\n", texto)\n    texto = re.sub(r"<[^>]+>", "", texto)\n    texto = html.unescape(texto)\n    return texto.replace("\\xa0", " ")\n\n\ndef cargar_procesados() -> set[str]:\n    try:\n        with open(PROCESADOS_FILE, \'r\') as f:\n            return set(line.strip() for line in f)\n    except FileNotFoundError:\n        return set()\n\n\ndef guardar_procesado(uidl: str):\n    PROCESADOS_FILE.parent.mkdir(parents=True, exist_ok=True)\n    with open(PROCESADOS_FILE, \'a\') as f:\n        f.write(uidl + \'\\n\')\n\n\ndef cargar_ultimo_uidl() -> str:\n    try:\n        with open(LAST_UIDL_FILE, \'r\') as f:\n            return f.read().strip()\n    except FileNotFoundError:\n        return \'\'\n\n\ndef guardar_ultimo_uidl(uidl: str):\n    LAST_UIDL_FILE.parent.mkdir(parents=True, exist_ok=True)\n    with open(LAST_UIDL_FILE, \'w\') as f:\n        f.write(uidl)\n\n\ndef registrar_procesados(uidls: list[str], ultimo: str | None):\n    """Marca los mensajes como procesados y actualiza el último UIDL."""\n    for uidl in uidls:\n        guardar_procesado(uidl)\n    if ultimo:\n        guardar_ultimo_uidl(ultimo)\n\n\ndef extraer_datos(asunto: str, cuerpo: str):\n    """Extrae número de OC, fechas, proveedor y tarea del asunto/cuerpo."""\n    numero = None\n    fecha_aut = None\n    fecha_orden = None\n    proveedor = None\n    tarea = None\n\n    if asunto:\n        patt = r"SISTEMA\\s+NAF:.*?ORDEN\\s+COMPRA\\s+(?:NO|N[°º])\\.?\\s*(\\d+)"\n        m = re.search(patt, asunto, re.IGNORECASE)\n        if m:\n            numero = m.group(1)\n\n    cuerpo_texto = _limpiar_html(cuerpo or "")\n\n    if cuerpo_texto:\n        if not numero:\n            m = re.search(r"orden\\s+de\\s+compra\\s+de\\s+(?:No|N[°º])\\.?\\s*(\\d+)", cuerpo_texto, re.IGNORECASE)\n            if m:\n                numero = m.group(1)\n        m = re.search(r"Fecha\\s+Autorizaci(?:o|\\xc3\\xb3)n[:\\s]*([0-9]{2}/[0-9]{2}/[0-9]{4})", cuerpo_texto, re.IGNORECASE)\n        if m:\n            fecha_aut = m.group(1)\n        m = re.search(r"Fecha\\s+Orden[:\\s]*([0-9]{2}/[0-9]{2}/[0-9]{4})", cuerpo_texto, re.IGNORECASE)\n        if m:\n            fecha_orden = m.group(1)\n        m = re.search(r"proveedor\\s*:?[\\s\\xa0]+([^\\n]+?)(?:\\s+con\\s+Fecha|\\n|$)", cuerpo_texto, re.IGNORECASE)\n        if m:\n            proveedor = re.sub(r"\\s+", " ", m.group(1)).strip()\n        m = re.search(r"#(\\d+)\\s*//", cuerpo_texto)\n        if m:\n            tarea = m.group(1)\n\n    return numero, fecha_aut, fecha_orden, proveedor, tarea\n\n\ndef _descargar_mensaje(num: int, cfg: Config) -> tuple[str, bytes]:\n    conn = poplib.POP3_SSL(cfg.pop_server, cfg.pop_port)\n    conn.user(cfg.usuario)\n    conn.pass_(cfg.password)\n    resp_uidl = conn.uidl(num)\n    line = resp_uidl.decode() if isinstance(resp_uidl, bytes) else resp_uidl\n    uidl = line.split()[-1]\n    resp = conn.retr(num)\n    conn.quit()\n    raw = b"\\n".join(resp[1])\n    return uidl, raw\n\n\ndef buscar_ocs(cfg: Config) -> tuple[list[dict], str | None]:\n    procesados = cargar_procesados()\n    last_uidl = cargar_ultimo_uidl()\n\n    remitentes_validos = {r.lower() for r in REMITENTES_BASE}\n    remitentes_validos.update(_conjunto_remitentes(getattr(cfg, \'usuario\', None)))\n    remitentes_validos.update(_conjunto_remitentes(getattr(cfg, \'remitente_adicional\', None)))\n    remitentes_validos.discard(\'\')\n\n    conn = poplib.POP3_SSL(cfg.pop_server, cfg.pop_port)\n    conn.user(cfg.usuario)\n    conn.pass_(cfg.password)\n\n    resp, uidl_lines, _ = conn.uidl()\n    entries = [line.decode().split() for line in uidl_lines]\n    mensajes = [(int(num), uidl) for num, uidl in entries]\n    conn.quit()\n\n    indices: list[tuple[int, str]] = []\n    nuevo_ultimo = None\n    for num, uidl in reversed(mensajes):\n        if uidl == last_uidl:\n            break\n        if nuevo_ultimo is None:\n            nuevo_ultimo = uidl\n        if uidl in procesados:\n            continue\n        indices.append((num, uidl))\n        if len(indices) >= cfg.batch_size:\n            break\n\n    ordenes: list[dict] = []\n    if not indices:\n        return ordenes, nuevo_ultimo\n\n    with ThreadPoolExecutor(max_workers=cfg.max_threads) as ex:\n        futures = {ex.submit(_descargar_mensaje, num, cfg): (num, uidl) for num, uidl in indices}\n        for fut in futures:\n            num, uidl = futures[fut]\n            try:\n                uidl_res, raw = fut.result()\n                logger.debug("Procesado UIDL %s", uidl_res)\n                mensaje = email_parser.BytesParser().parsebytes(raw)\n                raw_sub = mensaje.get(\'Subject\', \'\')\n                raw_from = mensaje.get(\'From\', \'\')\n                asunto = str(make_header(decode_header(raw_sub)))\n                remitente = str(make_header(decode_header(raw_from)))\n                cuerpo = \'\'\n                if mensaje.is_multipart():\n                    for parte in mensaje.walk():\n                        if parte.get_content_type() == \'text/plain\':\n                            try:\n                                charset = parte.get_content_charset() or \'utf-8\'\n                                cuerpo += parte.get_payload(decode=True).decode(charset, errors=\'replace\')\n                            except Exception:\n                                pass\n                else:\n                    charset = mensaje.get_content_charset() or \'utf-8\'\n                    cuerpo = mensaje.get_payload(decode=True).decode(charset, errors=\'replace\')\n                numero, fecha_aut, fecha_orden, proveedor, tarea = extraer_datos(asunto, cuerpo)\n                asunto_ok = re.search(r\'SISTEMA\\s+NAF:.*AUTORIZACI\', asunto or \'\', re.IGNORECASE)\n                remitentes_mensaje: set[str] = set()\n                for header_name in (\'From\', \'Reply-To\', \'Sender\', \'Return-Path\'):\n                    raw_header = mensaje.get(header_name)\n                    if not raw_header:\n                        continue\n                    decoded_header = str(make_header(decode_header(raw_header)))\n                    remitentes_mensaje.update(_normalizar_remitentes(decoded_header))\n                if not remitentes_mensaje:\n                    remitentes_mensaje = _normalizar_remitentes(remitente)\n                remitente_ok = bool(remitentes_mensaje & remitentes_validos)\n                if remitente_ok and asunto_ok and numero:\n                    ordenes.append({\'uidl\': uidl_res, \'numero\': numero, \'fecha_aut\': fecha_aut, \'fecha_orden\': fecha_orden, \'proveedor\': proveedor, \'tarea\': tarea})\n                elif remitente_ok:\n                    logger.warning(\n                        \'Mensaje UIDL %s de remitente válido sin datos de OC. Asunto="%s"\',\n                        uidl_res,\n                        asunto,\n                    )\n                else:\n                    guardar_procesado(uidl_res)\n            except Exception as e:\n                logger.error(\'Error procesando mensaje %s: %s\', num, e)\n\n    logger.info(\'Órdenes encontradas: %d\', len(ordenes))\n    try:\n        ORDENES_TMP.parent.mkdir(parents=True, exist_ok=True)\n        with open(ORDENES_TMP, \'w\', encoding=\'utf-8\') as f:\n            json.dump(ordenes, f, ensure_ascii=False)\n    except Exception as exc:  # pragma: no cover\n        logger.warning(\'No se pudo guardar ordenes_tmp: %s\', exc)\n    return ordenes, nuevo_ultimo\n\n',
    'DescargasOC-main/descargas_oc/mover_pdf.py': 'import os\nimport re\nimport shutil\nimport time\nfrom pathlib import Path\nfrom typing import Any, Mapping\n\nimport PyPDF2\n\ntry:  # permite ejecutar el módulo directamente\n    from .config import Config\n    from .logger import get_logger\n    from .organizador_bienes import (\n        extraer_numero_tarea_desde_pdf,\n        extraer_proveedor_desde_pdf,\n    )\n    from .pdf_info import nombre_archivo_orden\nexcept ImportError:  # pragma: no cover\n    from config import Config\n    from logger import get_logger\n    from organizador_bienes import (\n        extraer_numero_tarea_desde_pdf,\n        extraer_proveedor_desde_pdf,\n    )\n    from pdf_info import nombre_archivo_orden\n\nlogger = get_logger(__name__)\nREINTENTOS = 5\nESPERA_INICIAL = 0.3\nLONGITUD_MAXIMA_PROVEEDOR = 50\n\n\ndef _nombre_contiene_numero(nombre: str, numero: str | None) -> bool:\n    if not nombre or not numero:\n        return False\n    patron = rf"(?<!\\\\d){re.escape(numero)}(?!\\\\d)"\n    return re.search(patron, nombre) is not None\n\n\ndef _resolver_conflicto(destino_dir: Path, nombre: str) -> Path:\n    destino_dir.mkdir(parents=True, exist_ok=True)\n    destino = destino_dir / nombre\n    if not destino.exists():\n        return destino\n    base, ext = os.path.splitext(nombre)\n    i = 1\n    while True:\n        candidato = destino_dir / f"{base} ({i}){ext}"\n        if not candidato.exists():\n            return candidato\n        i += 1\n\n\ndef _asegurar_nombre(ruta_path: Path, nombre_deseado: str) -> tuple[Path | None, str | None]:\n    if ruta_path.name == nombre_deseado:\n        return ruta_path, None\n    ultimo_error: Exception | None = None\n    destino_final: Path | None = None\n    for intento in range(REINTENTOS):\n        destino = _resolver_conflicto(ruta_path.parent, nombre_deseado)\n        destino_final = destino\n        try:\n            ruta_path.rename(destino)\n            return destino, None\n        except PermissionError as exc:\n            ultimo_error = exc\n        except OSError as exc:\n            ultimo_error = exc\n            break\n        if intento < REINTENTOS - 1:\n            time.sleep(ESPERA_INICIAL * (intento + 1))\n    if ultimo_error:\n        logger.warning(\n            "No se pudo renombrar \'%s\' como \'%s\': %s",\n            ruta_path,\n            destino_final or (ruta_path.parent / nombre_deseado),\n            ultimo_error,\n        )\n        mensaje = (\n            f"No se pudo renombrar \'{ruta_path.name}\' a "\n            f"\'{(destino_final or Path(nombre_deseado)).name}\': {ultimo_error}"\n        )\n    else:\n        mensaje = f"No se pudo renombrar \'{ruta_path.name}\' a \'{nombre_deseado}\'"\n    return None, mensaje\n\n\ndef _mover_archivo(\n    ruta_path: Path, destino_dir: Path, nombre_final: str\n) -> tuple[Path | None, str | None]:\n    ultimo_error: Exception | None = None\n    destino_final: Path | None = None\n    for intento in range(REINTENTOS):\n        destino = _resolver_conflicto(destino_dir, nombre_final)\n        destino_final = destino\n        try:\n            resultado = Path(shutil.move(str(ruta_path), destino))\n            return resultado, None\n        except PermissionError as exc:\n            ultimo_error = exc\n        except OSError as exc:\n            ultimo_error = exc\n        if intento < REINTENTOS - 1:\n            time.sleep(ESPERA_INICIAL * (intento + 1))\n\n    if ruta_path.exists():\n        destino_final = _resolver_conflicto(destino_dir, nombre_final)\n        try:\n            shutil.copy2(str(ruta_path), str(destino_final))\n            try:\n                ruta_path.unlink()\n            except Exception as exc:  # pragma: no cover - limpieza de mejor esfuerzo\n                logger.warning(\n                    "No se pudo eliminar \'%s\' tras copiarlo a \'%s\': %s",\n                    ruta_path,\n                    destino_final,\n                    exc,\n                )\n            return destino_final, None\n        except Exception as exc:\n            ultimo_error = exc\n\n    if ultimo_error:\n        logger.warning(\n            "No se pudo mover \'%s\' a \'%s\': %s",\n            ruta_path,\n            destino_final.parent if destino_final else destino_dir,\n            ultimo_error,\n        )\n        return (\n            None,\n            f"No se pudo mover \'{ruta_path.name}\' a "\n            f"\'{destino_final or destino_dir}\': {ultimo_error}",\n        )\n    return None, f"No se pudo mover \'{ruta_path.name}\' a \'{destino_dir}\'"\n\n\ndef _carpetas_origen(config: Config) -> list[Path]:\n    """Obtiene las carpetas de descarga configuradas sin duplicados."""\n\n    rutas: list[Path] = []\n    for attr in ("carpeta_destino_local", "abastecimiento_carpeta_descarga"):\n        valor = getattr(config, attr, None)\n        if not valor:\n            continue\n        try:\n            path = Path(valor)\n        except (TypeError, ValueError, OSError):  # pragma: no cover - rutas inválidas\n            continue\n        if path not in rutas:\n            rutas.append(path)\n    return rutas\n\n\ndef _destino_no_bienes(\n    config: Config, orden: Mapping[str, Any] | None\n) -> Path | None:\n    """Determina la carpeta destino para órdenes que no pertenecen a bienes."""\n\n    categoria = ""\n    if isinstance(orden, Mapping):\n        valor = orden.get("categoria")\n        if valor:\n            categoria = str(valor).strip().lower()\n\n    rutas_preferidas: list[Any] = []\n    if categoria == "abastecimiento":\n        rutas_preferidas.extend(\n            [\n                getattr(config, "abastecimiento_carpeta_descarga", None),\n                getattr(config, "carpeta_destino_local", None),\n            ]\n        )\n    rutas_preferidas.append(getattr(config, "carpeta_analizar", None))\n\n    for ruta in rutas_preferidas:\n        if not ruta:\n            continue\n        try:\n            return Path(ruta)\n        except (TypeError, ValueError, OSError):  # pragma: no cover - ruta inválida\n            continue\n    return None\n\n\ndef normalizar_nombre_archivo(nombre: str, longitud_maxima: int = LONGITUD_MAXIMA_PROVEEDOR) -> str:\n    """Normaliza *nombre* para uso en nombres de archivo."""\n\n    limpio = re.sub(r"[^\\w\\- ]", "_", nombre or "").strip()\n    limpio = re.sub(r"\\s+", " ", limpio)\n    if len(limpio) > longitud_maxima:\n        limpio = limpio[:longitud_maxima].rstrip()\n    return limpio\n\n\ndef mover_oc(config: Config, ordenes=None):\n    """Renombra y mueve los PDF de las órdenes descargadas."""\n\n    ordenes = ordenes or []\n    numeros_oc = list(dict.fromkeys(o.get("numero") for o in ordenes))\n    proveedores = {o.get("numero"): o.get("proveedor") for o in ordenes}\n    indice_ordenes = {o.get("numero"): o for o in ordenes}\n\n    carpetas_origen = _carpetas_origen(config)\n    errores: list[str] = []\n    if not carpetas_origen:\n        logger.error("Carpetas de descarga no configuradas")\n        errores.append("Carpetas de descarga no configuradas")\n        return [], numeros_oc, errores\n\n    archivos: list[Path] = []\n    for carpeta in carpetas_origen:\n        if not carpeta.exists():\n            logger.warning("Carpeta origen inexistente: %s", carpeta)\n            continue\n        archivos.extend(p for p in carpeta.glob("*.pdf"))\n\n    encontrados: dict[str, Path] = {}\n\n    for ruta_path in archivos:\n        archivo = ruta_path.name\n        for numero in numeros_oc:\n            if not numero or numero in encontrados:\n                continue\n            if _nombre_contiene_numero(archivo, numero):\n                encontrados[numero] = ruta_path\n                break\n\n    restantes = [ruta for ruta in archivos if ruta not in set(encontrados.values())]\n    for ruta_path in restantes:\n        ruta = str(ruta_path)\n        try:\n            with open(ruta, "rb") as archivo_pdf:\n                lector = PyPDF2.PdfReader(archivo_pdf)\n                texto = "".join(pagina.extract_text() or "" for pagina in lector.pages)\n        except Exception as exc:\n            logger.warning("Error leyendo %s: %s", ruta_path.name, exc)\n            continue\n        for numero in numeros_oc:\n            if numero in encontrados:\n                continue\n            if numero and numero in texto:\n                encontrados[numero] = ruta_path\n                break\n\n    faltantes: list[str] = []\n    subidos: list[str] = []\n    es_bienes = bool(getattr(config, "compra_bienes", False))\n\n    for numero in numeros_oc:\n        ruta_path = encontrados.get(numero)\n        if not ruta_path:\n            faltantes.append(numero)\n            errores.append(\n                f"OC {numero}: archivo no encontrado en carpeta de descarga"\n            )\n            continue\n\n        proveedor = proveedores.get(numero)\n        ruta_str = str(ruta_path)\n        if not proveedor:\n            proveedor = extraer_proveedor_desde_pdf(ruta_str)\n            if indice_ordenes.get(numero) is not None and proveedor:\n                indice_ordenes[numero]["proveedor"] = proveedor\n\n        tarea = None\n        if es_bienes:\n            tarea = extraer_numero_tarea_desde_pdf(ruta_str)\n            if indice_ordenes.get(numero) is not None:\n                indice_ordenes[numero]["tarea"] = tarea\n\n        extension = ruta_path.suffix or ".pdf"\n        nombre_deseado = nombre_archivo_orden(numero, proveedor, extension)\n        nombre_original = ruta_path.name\n        origen_descarga = ruta_path.parent\n\n        if es_bienes:\n            base_bienes = getattr(config, "carpeta_analizar", None) or str(origen_descarga)\n            if tarea:\n                destino = None\n                for raiz, carpetas, _ in os.walk(base_bienes):\n                    for nombre_carpeta in carpetas:\n                        if nombre_carpeta.startswith(tarea):\n                            destino = os.path.join(raiz, nombre_carpeta)\n                            break\n                    if destino:\n                        break\n                if not destino:\n                    destino = os.path.join(base_bienes, tarea)\n                    os.makedirs(destino, exist_ok=True)\n            else:\n                destino = os.path.join(base_bienes, "ordenes sin tarea")\n                os.makedirs(destino, exist_ok=True)\n\n            destino_dir = Path(destino)\n            destino_path, error_mov = _mover_archivo(\n                ruta_path, destino_dir, nombre_original\n            )\n            if destino_path is None:\n                errores.append(f"OC {numero}: {error_mov}")\n                faltantes.append(numero)\n                continue\n            ruta_path = destino_path\n\n            ruta_path, error_nombre = _asegurar_nombre(ruta_path, nombre_deseado)\n            if ruta_path is None:\n                errores.append(f"OC {numero}: {error_nombre}")\n                faltantes.append(numero)\n                try:\n                    regreso = _resolver_conflicto(origen_descarga, nombre_original)\n                    shutil.move(str(destino_path), regreso)\n                except Exception as exc:  # pragma: no cover - recuperación de mejor esfuerzo\n                    logger.warning(\n                        "No se pudo regresar \'%s\' a \'%s\' tras un fallo de renombre: %s",\n                        destino_path,\n                        origen_descarga,\n                        exc,\n                    )\n                continue\n\n            logger.info("%s movido a %s", ruta_path.name, ruta_path.parent)\n        else:\n            destino_dir = _destino_no_bienes(config, indice_ordenes.get(numero))\n\n            if destino_dir and destino_dir != ruta_path.parent:\n                destino_dir.mkdir(parents=True, exist_ok=True)\n                destino_path, error_mov = _mover_archivo(\n                    ruta_path, destino_dir, nombre_deseado\n                )\n                if destino_path is None:\n                    errores.append(f"OC {numero}: {error_mov}")\n                    faltantes.append(numero)\n                    continue\n                ruta_path = destino_path\n            else:\n                ruta_path, error_nombre = _asegurar_nombre(ruta_path, nombre_deseado)\n                if ruta_path is None:\n                    errores.append(f"OC {numero}: {error_nombre}")\n                    faltantes.append(numero)\n                    continue\n\n            logger.info("%s listo en %s", ruta_path.name, ruta_path.parent)\n\n        subidos.append(numero)\n\n    return subidos, faltantes, errores\n\n',
    'DescargasOC-main/descargas_oc/organizador_bienes.py': 'import os\nimport re\nimport shutil\n\ntry:\n    from pypdf import PdfReader  # type: ignore\nexcept ImportError:  # pragma: no cover\n    try:\n        from PyPDF2 import PdfReader  # type: ignore\n    except ImportError as exc:  # pragma: no cover\n        raise SystemExit("Falta \'pypdf\' o \'PyPDF2\'. Instálalo con: py -m pip install --user pypdf") from exc\n\ntry:\n    from .logger import get_logger\nexcept ImportError:  # pragma: no cover\n    from logger import get_logger\n\nlogger = get_logger(__name__)\n\nPATRON_TAREA = re.compile(r"#\\s*([0-9]{6,11})\\s*//")\nPATRON_PROVEEDOR = re.compile(\n    r"(?:Proveedor|Nombre)\\s*[:\\-]?\\s*(.+)", re.IGNORECASE\n)\n\n\ndef extraer_numero_tarea_desde_pdf(ruta_pdf: str) -> str | None:\n    try:\n        reader = PdfReader(ruta_pdf)\n    except Exception as e:\n        logger.error("No se pudo abrir \'%s\': %s", ruta_pdf, e)\n        return None\n    for page in getattr(reader, "pages", []):\n        try:\n            texto = page.extract_text() or ""\n        except Exception:\n            texto = ""\n        if not texto:\n            continue\n        m = PATRON_TAREA.search(texto)\n        if m:\n            return m.group(1)\n    return None\n\n\ndef extraer_proveedor_desde_pdf(ruta_pdf: str) -> str | None:\n    try:\n        reader = PdfReader(ruta_pdf)\n    except Exception as e:\n        logger.error("No se pudo abrir \'%s\': %s", ruta_pdf, e)\n        return None\n    for page in getattr(reader, "pages", []):\n        try:\n            texto = page.extract_text() or ""\n        except Exception:\n            texto = ""\n        if not texto:\n            continue\n        m = PATRON_PROVEEDOR.search(texto)\n        if m:\n            valor = m.group(1).strip().split("\\n")[0]\n            valor = re.sub(r"(?i)^nombre\\s*[:\\-]?\\s*", "", valor).strip()\n            return valor\n    return None\n\n\ndef indexar_carpetas_destino(raiz: str) -> list[tuple[str, str]]:\n    indice = []\n    for root, dirs, _files in os.walk(raiz):\n        for nombre in dirs:\n            indice.append((os.path.join(root, nombre), nombre))\n    return indice\n\n\ndef elegir_mejor_carpeta_para_numero(numero: str, indice_carpetas: list[tuple[str, str]]) -> str | None:\n    candidatos = [ruta for ruta, nombre in indice_carpetas if nombre.startswith(numero)]\n    if not candidatos:\n        return None\n    candidatos_ordenados = sorted(candidatos, key=lambda p: (len(os.path.basename(p)), p.lower()))\n    return candidatos_ordenados[0]\n\n\ndef mover_sin_sobrescribir(ruta_archivo_origen: str, carpeta_destino: str) -> str | None:\n    logger = globals().get(\'logger\')\n\n    nombre = os.path.basename(ruta_archivo_origen)\n    base, ext = os.path.splitext(nombre)\n\n    if not re.match(r\'(?i)^ORDEN\\b\', base):\n        base = re.sub(r\'^(\\d+)\', r\'ORDEN \\1\', base)\n\n    nombre = f"{base}{ext}".upper()\n\n    destino = os.path.join(carpeta_destino, nombre)\n    os.makedirs(carpeta_destino, exist_ok=True)\n    if os.path.exists(destino):\n        i = 1\n        while True:\n            nuevo_nombre = f"{os.path.splitext(nombre)[0]} ({i}){os.path.splitext(nombre)[1]}"\n            destino = os.path.join(carpeta_destino, nuevo_nombre)\n            if not os.path.exists(destino):\n                break\n            i += 1\n    try:\n        shutil.move(ruta_archivo_origen, destino)\n        return destino\n    except Exception as e:  # pragma: no cover\n        if logger:\n            logger.error("No se pudo mover \'%s\' a \'%s\': %s", ruta_archivo_origen, carpeta_destino, e)\n        return None\n\n\ndef organizar(origen: str, raiz_destino: str):\n    try:\n        archivos_pdf = [a for a in os.listdir(origen) if a.lower().endswith(\'.pdf\')]\n    except FileNotFoundError:\n        logger.error("La ruta de origen no existe: %s", origen)\n        return\n    if not archivos_pdf:\n        return\n    indice = indexar_carpetas_destino(raiz_destino)\n    for nombre_pdf in archivos_pdf:\n        ruta_pdf = os.path.join(origen, nombre_pdf)\n        numero_tarea = extraer_numero_tarea_desde_pdf(ruta_pdf)\n        if not numero_tarea:\n            logger.info("No se encontró número en \'%s\'", nombre_pdf)\n            continue\n        carpeta_destino = elegir_mejor_carpeta_para_numero(numero_tarea, indice)\n        if not carpeta_destino:\n            logger.info("No hay carpeta que empiece con \'%s\' para \'%s\'", numero_tarea, nombre_pdf)\n            continue\n        ruta_final = mover_sin_sobrescribir(ruta_pdf, carpeta_destino)\n        if ruta_final:\n            logger.info("%s movido a %s", nombre_pdf, carpeta_destino)\n',
    'DescargasOC-main/descargas_oc/pdf_info.py': '"""Herramientas para extraer metadatos de las órdenes descargadas."""\nfrom __future__ import annotations\n\nimport re\nfrom pathlib import Path\nfrom typing import Iterable, Mapping\n\ntry:  # pragma: no cover - soporte ejecución directa\n    from .logger import get_logger\nexcept ImportError:  # pragma: no cover\n    from logger import get_logger\n\ntry:  # pragma: no cover - ejecución directa\n    from .organizador_bienes import extraer_proveedor_desde_pdf\nexcept ImportError:  # pragma: no cover\n    from organizador_bienes import extraer_proveedor_desde_pdf\n\n\nlogger = get_logger(__name__)\n\nMAX_NOMBRE_ARCHIVO = 180\n\ndef limpiar_proveedor(valor: str | None) -> str:\n    """Normaliza el texto obtenido desde el PDF."""\n\n    if not valor:\n        return ""\n    texto = re.sub(r"(?i)^nombre\\s*[:\\-]?\\s*", "", valor)\n    texto = re.sub(r"\\s+", " ", texto)\n    return texto.strip()\n\n\ndef nombre_archivo_orden(numero: str | None, proveedor: str | None = None, extension: str | None = ".pdf") -> str:\n    """Genera un nombre de archivo seguro y consistente.\n    - Prefijo ORDEN si hay número.\n    - Proveedor normalizado en MAYÚSCULAS con \'_\'.\n    - Retro-compatible con llamadas (numero), (numero, proveedor), (numero, proveedor, extension) y (numero, ".pdf").\n    """\n    # Compatibilidad: si \'proveedor\' parece extensión, reubicar\n    if proveedor and isinstance(proveedor, str) and proveedor.startswith(".") and (extension is None or extension == ".pdf"):\n        extension = proveedor\n        proveedor = None\n\n    numero = (numero or "").strip()\n    if numero:\n        import re as _re\n        numero = _re.sub(r"\\s+", " ", numero)\n        numero = _re.sub(r"(#)\\s+(?=\\d)", r"#", numero)\n\n    base = numero\n\n    if proveedor:\n        import re as _re\n        prov_clean = _re.sub(r"[^\\w\\- ]", "_", proveedor or "")\n        prov_clean = _re.sub(r"\\s+", "_", prov_clean)\n        prov_clean = _re.sub(r"_+", "_", prov_clean)\n        prov_clean = prov_clean.lstrip("_").upper()\n        base = f"{base} - {prov_clean}" if base else prov_clean\n\n    base = (base or "archivo").strip()\n\n    # Prefijo ORDEN si hay número\n    if numero:\n        base = f"ORDEN {base}"\n\n    # Limitar longitud razonable\n    MAX_NOMBRE_ARCHIVO = 180\n    if len(base) > MAX_NOMBRE_ARCHIVO:\n        base = base[:MAX_NOMBRE_ARCHIVO].rstrip(" .-_") or "archivo"\n\n    if not extension:\n        extension = ".pdf"\n    if not extension.startswith(\'.\'):\n        extension = f".{extension}"\n\n    return f"{base}{extension}".upper()\n\n\ndef proveedor_desde_pdf(ruta_pdf: str | Path | None) -> str:\n    """Obtiene y normaliza el proveedor leyendo el PDF indicado."""\n\n    if not ruta_pdf:\n        return ""\n    try:\n        proveedor = extraer_proveedor_desde_pdf(str(ruta_pdf))\n    except Exception as exc:  # pragma: no cover - defensivo\n        logger.debug("No se pudo extraer proveedor de %s: %s", ruta_pdf, exc)\n        return ""\n    return limpiar_proveedor(proveedor)\n\n\ndef _buscar_numero_en_nombre(nombre: str, numeros: Iterable[str]) -> str | None:\n    for numero in numeros:\n        if not numero:\n            continue\n        if re.search(rf"(?<!\\\\d){re.escape(numero)}(?!\\\\d)", nombre):\n            return numero\n    return None\n\n\ndef actualizar_proveedores_desde_pdfs(\n    ordenes: Iterable[Mapping[str, object]] | None,\n    carpeta_descargas: str | Path | None,\n) -> dict[str, str]:\n    """Actualiza la información de proveedor leyendo cada PDF descargado.\n\n    Devuelve un diccionario con los números de OC cuyo proveedor fue\n    encontrado en el contenido del PDF.\n    """\n\n    if not ordenes or not carpeta_descargas:\n        return {}\n\n    carpeta = Path(carpeta_descargas)\n    if not carpeta.exists():\n        logger.debug("Carpeta de descargas inexistente: %s", carpeta)\n        return {}\n\n    ordenes_dict = {\n        str(o.get("numero")).strip(): o\n        for o in ordenes\n        if o and o.get("numero")\n    }\n    if not ordenes_dict:\n        return {}\n\n    pdfs = sorted(carpeta.glob("*.pdf"))\n    if not pdfs:\n        logger.debug("No se encontraron PDFs en %s", carpeta)\n        return {}\n\n    actualizados: dict[str, str] = {}\n    for pdf in pdfs:\n        numero = _buscar_numero_en_nombre(pdf.name, ordenes_dict.keys())\n        if not numero:\n            continue\n        proveedor = limpiar_proveedor(extraer_proveedor_desde_pdf(str(pdf)))\n        if not proveedor:\n            continue\n        orden = ordenes_dict.get(numero)\n        if isinstance(orden, dict):\n            orden["proveedor"] = proveedor\n        actualizados[numero] = proveedor\n        logger.debug("OC %s: proveedor \'%s\' leído desde %s", numero, proveedor, pdf)\n\n    return actualizados\n',
    'DescargasOC-main/descargas_oc/reporter.py': 'import smtplib\nimport poplib\nimport json\nfrom email.message import EmailMessage\nfrom pathlib import Path\nfrom html import escape\n\ntry:  # permite ejecutar como script\n    from .config import Config\n    from .logger import get_logger\n    from .organizador_bienes import extraer_numero_tarea_desde_pdf\nexcept ImportError:  # pragma: no cover\n    from config import Config\n    from logger import get_logger\n    from organizador_bienes import extraer_numero_tarea_desde_pdf\n\nlogger = get_logger(__name__)\n\nSMTP_SERVER = "smtp.telconet.ec"\nSMTP_PORT = 587\nSMTP_SSL_PORT = 465\nSMTP_PLAIN_PORT = 25\n\nDATA_DIR = Path(__file__).resolve().parents[1] / \'data\'\nORDENES_TMP = DATA_DIR / \'ordenes_tmp.json\'\n\n\ndef _buscar_tarea(numero: str, cfg: Config) -> str | None:\n    """Busca el número de tarea dentro del PDF de la OC."""\n    carpeta = getattr(cfg, "carpeta_analizar", None)\n    if not carpeta:\n        return None\n    # Buscar recursivamente por si los archivos fueron movidos a subcarpetas\n    for pdf in Path(carpeta).rglob(f"{numero}*.pdf"):\n        tarea = extraer_numero_tarea_desde_pdf(str(pdf))\n        if tarea:\n            return tarea\n    return None\n\n\ndef _formatear_tabla(\n    filas: list[tuple[str, ...]],\n    headers: tuple[str, ...] | None = None,\n) -> str:\n    """Tabla de texto con bordes y columnas alineadas. Usa box-drawing."""\n\n    if not filas:\n        return "─ Sin datos ─"\n\n    headers = headers or ("Orden", "Tarea", "Proveedor")\n    num_cols = len(headers)\n\n    # Límite de ancho por columna para que no se rompa la vista en correos\n    default_max = [16, 18, 40]\n    maxw = [default_max[i] if i < len(default_max) else 30 for i in range(num_cols)]\n\n    def _clip(x: str, w: int) -> str:\n        s = str(x).replace("\\n", " ").strip()\n        return (s[: w - 1] + "…") if len(s) > w else s\n\n    filas_clip = [\n        tuple(_clip(row[i], maxw[i]) for i in range(num_cols))\n        for row in ([headers] + filas)\n    ]\n\n    anchos = [max(len(r[i]) for r in filas_clip) for i in range(num_cols)]\n\n    top = "┌" + "┬".join("─" * (a + 2) for a in anchos) + "┐"\n    mid = "├" + "┼".join("─" * (a + 2) for a in anchos) + "┤"\n    bottom = "└" + "┴".join("─" * (a + 2) for a in anchos) + "┘"\n\n    def _fmt_row(row: tuple[str, ...]) -> str:\n        return "│ " + " │ ".join(row[i].ljust(anchos[i]) for i in range(num_cols)) + " │"\n\n    lines = [top, _fmt_row(filas_clip[0]), mid]\n    for row in filas_clip[1:]:\n        lines.append(_fmt_row(row))\n    lines.append(bottom)\n    return "\\n".join(lines)\n\n\ndef _tabla_html(\n    filas: list[tuple[str, ...]],\n    headers: tuple[str, ...] | None = None,\n) -> str:\n    """Tabla HTML con bordes, padding, zebra y ajuste de ancho. Seguro con escape()."""\n\n    if not filas:\n        return "<p style=\'font-family:Segoe UI, Arial, sans-serif;font-size:13px;\'>– Sin datos –</p>"\n\n    headers = headers or ("Orden", "Tarea", "Proveedor")\n    num_cols = len(headers)\n\n    table_style = (\n        "border-collapse:collapse;"\n        "border:1px solid #d0d7de;"\n        "width:100%;"\n        "font-family:Segoe UI, Arial, sans-serif;"\n        "font-size:13px;"\n        "table-layout:fixed;"\n        "word-wrap:break-word;"\n        "line-height:1.35;"\n    )\n    th_style = (\n        "text-align:left;"\n        "padding:8px 10px;"\n        "border:1px solid #d0d7de;"\n        "background:#f6f8fa;"\n        "font-weight:600;"\n        "white-space:nowrap;"\n    )\n    td_style = (\n        "padding:6px 10px;"\n        "border:1px solid #d0d7de;"\n        "vertical-align:top;"\n        "word-break:break-word;"\n    )\n\n    default_widths = ["16ch", "20ch", "auto"]\n    colgroup = "<colgroup>" + "".join(\n        f"<col style=\'width:{default_widths[i] if i < len(default_widths) else \'auto\'}\'>"\n        for i in range(num_cols)\n    ) + "</colgroup>"\n\n    header_html = "".join(\n        f"<th style=\'{th_style}\'>{escape(str(h))}</th>" for h in headers\n    )\n\n    filas_html = []\n    for i, row in enumerate(filas):\n        bg = "#ffffff" if i % 2 == 0 else "#fafbfc"\n        celdas = "".join(\n            f"<td style=\'{td_style}\'>{escape(str(row[j]))}</td>" for j in range(num_cols)\n        )\n        filas_html.append(f"<tr style=\'background:{bg};\'>{celdas}</tr>")\n    rows = "".join(filas_html)\n\n    return (\n        f"<table style=\'{table_style}\'>"\n        f"{colgroup}"\n        "<thead>"\n        f"<tr>{header_html}</tr>"\n        "</thead>"\n        f"<tbody>{rows}</tbody>"\n        "</table>"\n    )\n\n\ndef enviar_reporte(\n    exitosas,\n    faltantes,\n    ordenes,\n    cfg: Config,\n    categoria: str | None = None,\n    destinatario: str | None = None,\n) -> bool:\n    if not exitosas and not faltantes:\n        return False\n    if not ordenes:\n        try:\n            with open(ORDENES_TMP, \'r\', encoding=\'utf-8\') as f:\n                ordenes = json.load(f)\n        except Exception:\n            ordenes = []\n    # asegurarse de no repetir números\n    exitosas_uniq = list(dict.fromkeys(exitosas))\n    faltantes_uniq = list(dict.fromkeys(faltantes))\n    info = {o["numero"]: o for o in ordenes}\n\n    destinatario = destinatario or cfg.correo_reporte\n    usuario_pop = getattr(cfg, "usuario", None)\n    password_pop = getattr(cfg, "password", None)\n    smtp_usuario = getattr(cfg, "smtp_usuario", None) or usuario_pop\n    smtp_password = getattr(cfg, "smtp_password", None) or password_pop\n    smtp_server = getattr(cfg, "smtp_server", None) or SMTP_SERVER\n    smtp_port = getattr(cfg, "smtp_port", None) or SMTP_PORT\n    smtp_ssl_port = getattr(cfg, "smtp_ssl_port", None) or SMTP_SSL_PORT\n    smtp_plain_port = getattr(cfg, "smtp_plain_port", None) or SMTP_PLAIN_PORT\n\n    def _as_int(value, default):\n        try:\n            return int(value)\n        except (TypeError, ValueError):\n            return default\n\n    smtp_port = _as_int(smtp_port, SMTP_PORT)\n    smtp_ssl_port = _as_int(smtp_ssl_port, SMTP_SSL_PORT)\n    smtp_plain_port = _as_int(smtp_plain_port, SMTP_PLAIN_PORT)\n\n    if not destinatario or not smtp_usuario or not smtp_password:\n        logger.warning(\'Datos de correo SMTP incompletos, no se enviará reporte\')\n        return False\n\n    # Algunos servidores requieren autenticarse vía POP3 antes de enviar SMTP\n    if usuario_pop and password_pop:\n        try:\n            pop = poplib.POP3_SSL(cfg.pop_server, cfg.pop_port)\n            pop.user(usuario_pop)\n            pop.pass_(password_pop)\n            pop.quit()\n        except Exception as exc:  # pragma: no cover - la ausencia de POP no debe abortar\n            logger.warning("Autenticación POP fallida: %s", exc)\n    else:  # pragma: no cover - se deja registro para diagnósticos\n        logger.warning(\'Credenciales POP incompletas, se omite autenticación previa\')\n    mensaje = EmailMessage()\n    subject = \'Reporte de órdenes descargadas\'\n    if categoria:\n        subject += f\' - {categoria}\'\n    mensaje[\'Subject\'] = subject\n    if smtp_usuario and "@" in smtp_usuario:\n        remitente = smtp_usuario\n    elif usuario_pop:\n        remitente = usuario_pop\n    else:\n        remitente = smtp_usuario\n    mensaje[\'From\'] = remitente\n    mensaje[\'To\'] = destinatario\n    texto = \'\'\n    if categoria:\n        texto += f\'Categoría: {categoria}\\n\\n\'\n    texto += \'Órdenes subidas correctamente:\\n\'\n\n    usar_tabla_categoria = bool(categoria and categoria.lower() == \'abastecimiento\')\n    tabla_headers = (\n        ("Orden", "Proveedor", "Categoría")\n        if usar_tabla_categoria\n        else ("Orden", "Tarea", "Proveedor")\n    )\n\n    filas_ok: list[tuple[str, ...]] = []\n    for num in exitosas_uniq:\n        data = info.get(num, {})\n        prov = data.get(\'proveedor\') or \'-\'\n        if usar_tabla_categoria:\n            cat_valor = data.get(\'categoria\') or categoria or \'-\'\n            filas_ok.append((num, prov, cat_valor))\n        else:\n            tarea = data.get(\'tarea\') or _buscar_tarea(num, cfg) or \'-\'\n            filas_ok.append((num, tarea, prov))\n\n    html = \'\'\n    if categoria:\n        html += f"<p>Categoría: {escape(categoria)}</p>"\n    html += \'<h3>Órdenes subidas correctamente:</h3>\' + _tabla_html(filas_ok, tabla_headers)\n    if filas_ok:\n        texto += _formatear_tabla(filas_ok, tabla_headers) + \'\\n\'\n    if faltantes_uniq:\n        texto += \'\\nNo se encontraron archivos para las siguientes OC:\\n\'\n        filas_bad: list[tuple[str, ...]] = []\n        for num in faltantes_uniq:\n            data = info.get(num, {})\n            prov = data.get(\'proveedor\') or \'-\'\n            if usar_tabla_categoria:\n                cat_valor = data.get(\'categoria\') or categoria or \'-\'\n                filas_bad.append((num, prov, cat_valor))\n            else:\n                tarea = data.get(\'tarea\') or \'-\'\n                filas_bad.append((num, tarea, prov))\n        texto += _formatear_tabla(filas_bad, tabla_headers) + \'\\n\'\n        html += \'<h3>No se encontraron archivos para las siguientes OC:</h3>\' + _tabla_html(filas_bad, tabla_headers)\n    mensaje.set_content(texto)\n    mensaje.add_alternative(html, subtype=\'html\')\n    candidatos: list[str] = []\n\n    def _agregar_candidato(valor: str | None):\n        if not valor:\n            return\n        candidatos.append(valor)\n        if "@" in valor:\n            base, _, resto = valor.partition("@")\n            dominio = resto.split(".")[0].upper() if resto else ""\n            if base:\n                candidatos.append(base)\n                if dominio:\n                    candidatos.append(f"{dominio}\\\\{base}")\n\n    _agregar_candidato(smtp_usuario)\n    if usuario_pop != smtp_usuario:\n        _agregar_candidato(usuario_pop)\n\n    usernames = list(dict.fromkeys(c for c in candidatos if c))\n\n    def _intentar_envio(factory):\n        last_error: Exception | None = None\n        for u in usernames:\n            try:\n                with factory() as smtp:\n                    try:\n                        smtp.login(u, smtp_password)\n                    except smtplib.SMTPAuthenticationError as exc:\n                        logger.warning("Fallo de autenticación con \'%s\'", u)\n                        last_error = exc\n                        continue\n                    smtp.send_message(mensaje)\n                    logger.info(\'Reporte enviado\')\n                    return True\n            except smtplib.SMTPAuthenticationError as exc:\n                logger.warning("Fallo de autenticación con \'%s\'", u)\n                last_error = exc\n            except Exception as exc:\n                logger.error(\'No se pudo enviar reporte: %s\', exc)\n                return False\n        if last_error:\n            logger.error(\'No se pudo enviar reporte: %s\', last_error)\n        return False\n\n    def _smtp_tls():\n        s = smtplib.SMTP(smtp_server, smtp_port)\n        s.ehlo()\n        s.starttls()\n        s.ehlo()\n        return s\n\n    if _intentar_envio(_smtp_tls):\n        try:\n            ORDENES_TMP.unlink(missing_ok=True)\n        except Exception:\n            pass\n        return True\n\n    if _intentar_envio(lambda: smtplib.SMTP_SSL(smtp_server, smtp_ssl_port)):\n        try:\n            ORDENES_TMP.unlink(missing_ok=True)\n        except Exception:\n            pass\n        return True\n\n    def _smtp_plain():\n        s = smtplib.SMTP(smtp_server, smtp_plain_port)\n        s.ehlo()\n        return s\n\n    if _intentar_envio(_smtp_plain):\n        try:\n            ORDENES_TMP.unlink(missing_ok=True)\n        except Exception:\n            pass\n        return True\n\n    return False\n\n',
    'DescargasOC-main/descargas_oc/seafile_client.py': 'import re\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry import Retry\n\ntry:\n    # al importarse como parte del paquete principal\n    from .logger import get_logger\nexcept ImportError:  # pragma: no cover - compatibilidad con importaciones directas en pruebas\n    from logger import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass SeafileClient:\n    def __init__(self, server_url: str, username: str, password: str, *, session_token: str | None = None, timeout: int = 30):\n        self.server_url = server_url.rstrip(\'/\')\n        self.timeout = timeout\n        self.session = requests.Session()\n        retries = Retry(total=3, backoff_factor=0.5, status_forcelist=[500, 502, 503, 504])\n        adapter = HTTPAdapter(max_retries=retries)\n        self.session.mount(\'http://\', adapter)\n        self.session.mount(\'https://\', adapter)\n        if session_token:\n            self.session_token = session_token\n        else:\n            self.session_token = self._login(username, password)\n\n    def _login(self, username: str, password: str) -> str:\n        url = f"{self.server_url}/api2/auth-token/"\n        resp = self.session.post(url, data={\'username\': username, \'password\': password}, timeout=self.timeout)\n        if resp.status_code in (401, 403):\n            raise RuntimeError(\'Credenciales inválidas\')\n        resp.raise_for_status()\n        try:\n            token = resp.json().get(\'token\')\n        except ValueError as e:\n            raise RuntimeError(\'Respuesta inválida del servidor\') from e\n        if not token:\n            raise RuntimeError(\'No se recibió token\')\n        return token\n\n    def _headers(self):\n        return {\'Authorization\': f\'Token {self.session_token}\'}\n\n    def _get_upload_link(self, repo_id: str, parent_dir: str = \'/\') -> str:\n        uuid_regex = r"^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$"\n        if \'/\' in repo_id or \':\' in repo_id or not re.match(uuid_regex, repo_id, re.IGNORECASE):\n            raise ValueError("\'seafile_repo_id\' debe ser un UUID")\n        from urllib.parse import quote\n        encoded_dir = quote(parent_dir, safe=\'/\')\n        url = f"{self.server_url}/api2/repos/{repo_id}/upload-link/?p={encoded_dir}"\n        resp = self.session.get(url, headers=self._headers(), timeout=self.timeout)\n        if resp.status_code == 404:\n            raise RuntimeError(\'Repositorio no encontrado (404)\')\n        resp.raise_for_status()\n        return resp.text.strip(\'"\')\n\n    def upload_file(self, repo_id: str, file_path: str, parent_dir: str = \'/\') -> str:\n        logger.info("Subiendo %s a %s/%s", file_path, repo_id, parent_dir)\n        link = self._get_upload_link(repo_id, parent_dir)\n        with open(file_path, \'rb\') as f:\n            files = {\'file\': f}\n            data = {\'parent_dir\': parent_dir}\n            resp = self.session.post(link, files=files, data=data, headers=self._headers(), timeout=self.timeout)\n        resp.raise_for_status()\n        try:\n            return resp.json()\n        except ValueError:\n            if not resp.text:\n                raise RuntimeError(\'Respuesta vacía de Seafile\')\n            return resp.text\n\n',
    'DescargasOC-main/descargas_oc/selenium_abastecimiento.py': '"""Descarga de órdenes de compra de Abastecimiento vía Selenium."""\nfrom __future__ import annotations\n\nimport os\nimport re\nimport time\nimport unicodedata\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.common.exceptions import (\n    ElementClickInterceptedException,\n    ElementNotInteractableException,\n    TimeoutException,\n    StaleElementReferenceException,\n)\n\ntry:  # permitir la ejecución como script\n    from .config import Config\n    from .mover_pdf import mover_oc\n    from .reporter import enviar_reporte\n    from .selenium_modulo import esperar_descarga_pdf\n    from .logger import get_logger\n    from .pdf_info import (\n        actualizar_proveedores_desde_pdfs,\n        limpiar_proveedor,\n        nombre_archivo_orden,\n        proveedor_desde_pdf,\n    )\nexcept ImportError:  # pragma: no cover\n    from config import Config\n    from mover_pdf import mover_oc\n    from reporter import enviar_reporte\n    from selenium_modulo import esperar_descarga_pdf\n    from logger import get_logger\n    from pdf_info import (\n        actualizar_proveedores_desde_pdfs,\n        limpiar_proveedor,\n        nombre_archivo_orden,\n        proveedor_desde_pdf,\n    )\nlogger = get_logger(__name__)\nWAIT_TIMEOUT = 30\n\n\nAUTOCOMPLETE_LABELS: dict[str, list[str]] = {\n    "solicitante": ["solicitante", "solicita", "solicitante:"],\n    "autoriza": ["autoriza", "autoriza:", "autoriza por"],\n}\n\nICON_TEXTOS = {\n    "keyboard_arrow_down",\n    "keyboard_arrow_up",\n    "keyboard_arrow_right",\n    "keyboard_arrow_left",\n    "picture_as_pdf",\n    "save_alt",\n}\n\nPATRONES_NUMERO = (\n    re.compile(r"orden\\s*(?:de\\s*compra\\s*)?#?\\s*(\\d+)", re.IGNORECASE),\n    re.compile(r"oc\\s*(\\d+)", re.IGNORECASE),\n    re.compile(r"(\\d{5,})"),\n)\n\n\ndef _renombrar_pdf_descargado(pdf: Path, numero: str, proveedor: str) -> Path:\n    """Renombra el PDF descargado usando número y proveedor."""\n\n    base_actual = re.sub(r"\\s+", " ", pdf.stem).strip()\n    preferido = base_actual or (numero or "").strip()\n    nombre_deseado = nombre_archivo_orden(preferido, proveedor, pdf.suffix or ".pdf")\n    destino = pdf.with_name(nombre_deseado)\n    if destino == pdf:\n        return pdf\n\n    base, ext = os.path.splitext(nombre_deseado)\n    if destino.exists():\n        i = 1\n        while True:\n            candidato = pdf.with_name(f"{base} ({i}){ext}")\n            if not candidato.exists():\n                destino = candidato\n                break\n            i += 1\n\n    try:\n        pdf.rename(destino)\n        logger.info("Archivo %s renombrado a %s", pdf.name, destino.name)\n        return destino\n    except Exception as exc:  # pragma: no cover - best effort\n        logger.warning(\n            "No se pudo renombrar \'%s\' a \'%s\': %s", pdf.name, destino.name, exc\n        )\n        return pdf\n\n\ndef _normalizar_texto(texto: str) -> str:\n    """Normaliza texto para comparaciones flexibles."""\n\n    if not texto:\n        return ""\n    descompuesto = unicodedata.normalize("NFKD", texto)\n    sin_acentos = "".join(c for c in descompuesto if not unicodedata.combining(c))\n    return sin_acentos.lower().strip()\n\n\ndef _texto_es_icono(texto: str) -> bool:\n    if not texto:\n        return False\n    normalizado = _normalizar_texto(texto).replace(" ", "_")\n    return normalizado in ICON_TEXTOS\n\n\ndef _numero_desde_texto(texto: str) -> str:\n    if not texto:\n        return ""\n    for patron in PATRONES_NUMERO:\n        coincidencia = patron.search(texto)\n        if coincidencia:\n            numero = re.sub(r"\\D", "", coincidencia.group(1))\n            if numero:\n                numero_normalizado = numero.lstrip("0")\n                return numero_normalizado or numero\n    return ""\n\n\ndef _normalizar_fecha(valor: str) -> str:\n    if not valor:\n        return ""\n    texto = valor.strip()\n    for formato in ("%d/%m/%Y", "%d-%m-%Y", "%d/%m/%y", "%Y-%m-%d"):\n        try:\n            fecha = datetime.strptime(texto, formato)\n            return fecha.strftime("%d/%m/%Y")\n        except ValueError:\n            continue\n    return texto\n\n\ndef _nombre_archivo(numero: str | None, proveedor: str | None) -> str | None:\n    """Genera el nombre base del PDF utilizando número y proveedor."""\n\n    numero_limpio = (numero or "").strip()\n    proveedor_limpio = re.sub(r"\\s+", " ", (proveedor or "").strip())\n    proveedor_limpio = re.sub(r"[^\\w\\- ]", "_", proveedor_limpio).strip()\n\n    partes: list[str] = []\n    if numero_limpio:\n        partes.append(numero_limpio)\n    if proveedor_limpio:\n        partes.append(proveedor_limpio)\n    if not partes:\n        return None\n    base = " - ".join(partes)\n    return base[:180].rstrip(" .-_") or None\n\n\ndef _renombrar_descarga(archivo: Path, base: str | None) -> Path:\n    """Renombra la descarga reciente asegurando nombres únicos."""\n\n    if not base:\n        return archivo\n    base = base.strip()\n    if not base:\n        return archivo\n\n    destino = archivo.with_name(f"{base}.pdf")\n    intento = 0\n    while True:\n        candidato = destino if intento == 0 else archivo.with_name(f"{base} ({intento}).pdf")\n        if archivo == candidato:\n            return archivo\n        try:\n            archivo.rename(candidato)\n            return candidato\n        except FileExistsError:\n            intento += 1\n            continue\n        except OSError as exc:  # pragma: no cover - entorno Windows\n            logger.warning("No se pudo renombrar %s a %s: %s", archivo, candidato, exc)\n            return archivo\n\n\ndef _extraer_datos_orden(btn, indice: int) -> tuple[str, str]:\n    """Obtiene el número y proveedor asociados a un botón de descarga."""\n\n    fila = None\n    for xpath in (\n        "./ancestor::mat-row[1]",\n        "./ancestor::*[@role=\'row\'][1]",\n        "./ancestor::tr[1]",\n    ):\n        try:\n            fila = btn.find_element(By.XPATH, xpath)\n            if fila is not None:\n                break\n        except Exception:\n            continue\n\n    numero = ""\n    proveedor = ""\n\n    textos: list[str] = []\n    if fila is not None:\n        vistos: set[str] = set()\n\n        def _agregar(texto: str):\n            texto = (texto or "").strip()\n            if not texto:\n                return\n            if texto in vistos:\n                return\n            vistos.add(texto)\n            textos.append(texto)\n\n        try:\n            fila_texto = fila.text or ""\n        except Exception:\n            fila_texto = ""\n        for parte in fila_texto.splitlines():\n            _agregar(parte)\n\n    if fila is not None:\n        textos: list[str] = []\n        for locator in (".//mat-cell", ".//td"):\n            try:\n                celdas = fila.find_elements(By.XPATH, locator)\n            except Exception:\n                continue\n            for celda in celdas:\n                try:\n                    texto = celda.text or ""\n                except Exception:\n                    texto = ""\n                for parte in texto.splitlines():\n                    _agregar(parte)\n\n        try:\n            spans = fila.find_elements(By.XPATH, ".//span")\n        except Exception:\n            spans = []\n        for span in spans:\n            try:\n                texto = span.text or ""\n            except Exception:\n                texto = ""\n            for parte in texto.splitlines():\n                _agregar(parte)\n\n    numero_texto = ""\n    for texto in textos:\n        if _texto_es_icono(texto):\n            continue\n        numero_candidato = _numero_desde_texto(texto)\n        if numero_candidato:\n            numero = numero_candidato\n            numero_texto = texto\n            break\n                    texto = celda.text.strip()\n                except Exception:\n                    texto = ""\n                if texto:\n                    textos.append(texto)\n            if textos:\n                break\n\n        if textos:\n            numero = textos[0]\n            if len(textos) > 1:\n                proveedor = textos[1]\n\n        if not numero or not proveedor:\n            try:\n                spans = fila.find_elements(By.XPATH, ".//span")\n            except Exception:\n                spans = []\n            span_textos: list[str] = []\n            for span in spans:\n                try:\n                    texto = span.text.strip()\n                except Exception:\n                    texto = ""\n                if texto:\n                    span_textos.append(texto)\n            if not numero and span_textos:\n                numero = span_textos[0]\n            if not proveedor and span_textos:\n                for texto in span_textos:\n                    if texto != numero:\n                        proveedor = texto\n                        break\n\n    if not numero:\n        numero = str(indice + 1)\n\n    for texto in textos:\n        if texto == numero_texto:\n            continue\n        if _texto_es_icono(texto):\n            continue\n        if _numero_desde_texto(texto) == numero:\n            continue\n        if not re.search(r"[a-zA-ZÁÉÍÓÚÜÑ]", texto):\n            continue\n        proveedor = texto\n        break\n\n    proveedor = limpiar_proveedor(proveedor)\n\n    return numero, proveedor\n\n\n_SCRIPT_BUSCAR_AUTOCOMPLETE = r"""\nconst normalizar = (texto) => (texto || \'\')\n  .normalize(\'NFD\')\n  .replace(/[\\u0300-\\u036f]/g, \'\')\n  .toLowerCase()\n  .replace(/\\s+/g, \' \')\n  .trim();\n\nconst needle = normalizar(arguments[0] || \'\');\nif (!needle) {\n  return null;\n}\n\nconst esVisible = (el) => {\n  if (!el) {\n    return false;\n  }\n  try {\n    return el.offsetParent !== null && !el.disabled;\n  } catch (e) {\n    return false;\n  }\n};\n\nconst contenedores = Array.from(document.querySelectorAll([\n  \'mat-form-field\',\n  \'.mat-form-field\',\n  \'ng-select\',\n  \'.ng-select\',\n  \'.ng-select-container\',\n  \'div.form-group\',\n  "div[class*=\'col\']"\n].join(\',\')));\n\nfor (const campo of contenedores) {\n  if (!esVisible(campo)) {\n    continue;\n  }\n  const texto = normalizar(campo.innerText);\n  if (!texto || !texto.includes(needle)) {\n    continue;\n  }\n  const input = campo.querySelector(\'input[aria-autocomplete="list"]\');\n  if (esVisible(input)) {\n    return input;\n  }\n}\n\nconst inputs = Array.from(document.querySelectorAll(\'input[aria-autocomplete="list"]\'));\n\nconst contextoInput = (input) => {\n  const partes = [];\n\n  if (input.id) {\n    const labelFor = document.querySelector(`label[for=\'${input.id}\']`);\n    if (labelFor) {\n      partes.push(labelFor.innerText || \'\');\n    }\n  }\n\n  let nodo = input.parentElement;\n  let profundidad = 0;\n  while (nodo && profundidad < 5) {\n    const label = nodo.querySelector ? nodo.querySelector(\'label, .ng-select-label, .mat-form-field-label\') : null;\n    if (label) {\n      partes.push(label.innerText || \'\');\n    }\n    if (nodo.previousElementSibling) {\n      partes.push(nodo.previousElementSibling.innerText || \'\');\n    }\n    nodo = nodo.parentElement;\n    profundidad += 1;\n  }\n\n  return normalizar(partes.join(\' \'));\n};\n\nfor (const input of inputs) {\n  if (!esVisible(input)) {\n    continue;\n  }\n  const contexto = contextoInput(input);\n  if (contexto && contexto.includes(needle)) {\n    return input;\n  }\n}\n\nreturn null;\n"""\n\n\ndef _buscar_autocomplete_por_texto(driver, etiqueta: str):\n    """Localiza el input de autocompletado usando la etiqueta visible."""\n\n    etiqueta = etiqueta or ""\n\n    def _resolver(drv):\n        try:\n            elemento = drv.execute_script(_SCRIPT_BUSCAR_AUTOCOMPLETE, etiqueta)\n        except Exception:\n            return None\n        if not elemento:\n            return None\n        try:\n            if elemento.is_displayed() and elemento.is_enabled():\n                return elemento\n        except StaleElementReferenceException:\n            return None\n        return None\n\n    try:\n        return WebDriverWait(driver, WAIT_TIMEOUT).until(_resolver)\n    except TimeoutException as exc:  # pragma: no cover - entorno con cambios de UI\n        raise RuntimeError(f"No se pudo localizar \'{etiqueta}\'") from exc\n\n\ndef _extraer_variantes(texto: str) -> list[str]:\n    if not texto:\n        return []\n    variantes = [\n        parte.strip()\n        for parte in re.split(r"[;|,\\n]+", texto)\n        if parte.strip()\n    ]\n    if not variantes:\n        variantes = [texto.strip()]\n    return variantes\n\n\ndef _construir_consultas(variantes: list[str], original: str) -> list[str]:\n    consultas: list[str] = []\n    for variante in variantes:\n        match = re.search(r"\\d+", variante)\n        if match:\n            consultas.append(match.group(0))\n    consultas.extend(variantes)\n    if original:\n        consultas.append(original)\n    vistas: set[str] = set()\n    ordenadas: list[str] = []\n    for consulta in consultas:\n        limpia = consulta.strip()\n        if limpia and limpia not in vistas:\n            vistas.add(limpia)\n            ordenadas.append(limpia)\n    return ordenadas\n\n\ndef _esperar_opciones_visibles(driver, timeout: int = 5) -> list:\n    opciones_locator = (By.CSS_SELECTOR, "mat-option")\n\n    try:\n        return WebDriverWait(driver, timeout).until(\n            lambda d: [\n                opcion\n                for opcion in d.find_elements(*opciones_locator)\n                if opcion.is_displayed()\n            ]\n        )\n    except TimeoutException:\n        return []\n\n\ndef _esperar_cierre_opciones(driver, timeout: int = 5):\n    opciones_locator = (By.CSS_SELECTOR, "mat-option")\n\n    try:\n        WebDriverWait(driver, timeout).until(\n            lambda d: not any(\n                opcion.is_displayed() for opcion in d.find_elements(*opciones_locator)\n            )\n        )\n    except TimeoutException:\n        pass\n\n\ndef _seleccionar_opcion_visible(opciones, variantes: list[str]) -> bool:\n    if not opciones:\n        return False\n\n    variantes_norm = [_normalizar_texto(variante) for variante in variantes if variante]\n\n    for variante_norm in variantes_norm:\n        if not variante_norm:\n            continue\n        for opcion in list(opciones):\n            try:\n                texto_opcion = opcion.text\n            except StaleElementReferenceException:\n                continue\n            if _normalizar_texto(texto_opcion).find(variante_norm) != -1:\n                opcion.click()\n                return True\n    return False\n\n\ndef _valor_coincide(valor: str, variantes: list[str], consultas: list[str]) -> bool:\n    valor_norm = _normalizar_texto(valor)\n    if not valor_norm:\n        return False\n\n    for variante in variantes:\n        variante_norm = _normalizar_texto(variante)\n        if variante_norm and variante_norm in valor_norm:\n            return True\n\n    for consulta in consultas:\n        consulta_norm = _normalizar_texto(consulta)\n        if consulta_norm and consulta_norm in valor_norm:\n            return True\n\n    valor_digitos = re.sub(r"\\D", "", valor_norm)\n    if valor_digitos:\n        for consulta in consultas:\n            consulta_digitos = re.sub(r"\\D", "", _normalizar_texto(consulta))\n            if consulta_digitos and valor_digitos.startswith(consulta_digitos):\n                return True\n\n    return False\n\n\n\n\ndef descargar_abastecimiento(\n    fecha_desde: str,\n    fecha_hasta: str,\n    solicitante: str,\n    autoriza: str,\n    username: str | None = None,\n    password: str | None = None,\n    download_dir: str | None = None,\n    headless: bool | None = None,\n):\n    """Automatiza la descarga visible de órdenes de compra por abastecimiento."""\n\n    cfg = Config()\n    user = username if username is not None else cfg.usuario\n    if user:\n        user = user.split("@")[0]\n    pwd = password if password is not None else cfg.password\n    destino = Path(\n        download_dir\n        or cfg.abastecimiento_carpeta_descarga\n        or cfg.carpeta_destino_local\n        or Path.home()\n    )\n    destino.mkdir(parents=True, exist_ok=True)\n\n    headless_flag = (\n        bool(cfg.abastecimiento_headless)\n        if headless is None\n        else bool(headless)\n    )\n\n    options = webdriver.ChromeOptions()\n    prefs = {\n        "download.default_directory": str(destino),\n        "download.prompt_for_download": False,\n        "plugins.always_open_pdf_externally": True,\n    }\n    options.add_experimental_option("prefs", prefs)\n    options.add_experimental_option(\n        "excludeSwitches", ["enable-automation", "enable-logging"]\n    )\n    options.add_experimental_option("useAutomationExtension", False)\n    options.add_argument("--disable-blink-features=AutomationControlled")\n    options.add_argument("--disable-gpu")\n    options.add_argument("--window-size=1920,1080")\n    options.add_argument("--no-sandbox")\n    options.add_argument("--disable-dev-shm-usage")\n    options.add_argument("--log-level=3")\n    if headless_flag:\n        options.add_argument("--headless=new")\n\n    driver = webdriver.Chrome(options=options)\n    try:\n        ordenes: list[dict[str, str]] = []\n        try:\n            driver.execute_cdp_cmd(\n                "Page.setDownloadBehavior",\n                {"behavior": "allow", "downloadPath": str(destino)},\n            )\n        except Exception:  # pragma: no cover - depende de Chrome\n            pass\n\n        elements = {\n            "usuario": (By.CSS_SELECTOR, "input#username"),\n            "contrasena": (By.CSS_SELECTOR, "input#password"),\n            "iniciar_sesion": (\n                By.CSS_SELECTOR,\n                "input.btn.btn-block.btn-submit[name=\'submit\']",\n            ),\n            "menu_hamburguesa": (By.CSS_SELECTOR, "button.simple-sidenav__toggle"),\n            "lista_accesos": (\n                By.XPATH,\n                "//span[contains(@class,\'simple-sidenav__text\') and text()=\'Accesos\']",\n            ),\n            "seleccion_compania": (\n                By.XPATH,\n                "//span[contains(@class,\'simple-sidenav__text\') and text()=\'Selección de Compañía\']",\n            ),\n            "lista_companias": (By.CSS_SELECTOR, "input[aria-autocomplete=\'list\']"),\n            "telconet_sa": (\n                By.XPATH,\n                "//div[contains(@class,\'ng-star-inserted\') and contains(.,\'TELCONET S.A.\')]",\n            ),\n            "boton_elegir": (By.XPATH, "//span[text()=\'Elegir\']"),\n            "companias_boton_ok": (\n                By.CSS_SELECTOR,\n                "button.swal2-confirm.swal2-styled",\n            ),\n            "lista_consultas": (\n                By.XPATH,\n                "//span[contains(@class,\'simple-sidenav__text\') and text()=\'Consultas\']",\n            ),\n            "consulta_ordenes": (\n                By.XPATH,\n                "//span[contains(@class,\'simple-sidenav__text\') and text()=\'Consulta de Órdenes de Compra\']",\n            ),\n            "fecha_desde": (By.ID, "mat-input-2"),\n            "fecha_hasta": (By.ID, "mat-input-3"),\n            "btnbuscarorden": (\n                By.XPATH,\n                "//button[.//span[text()=\'Aplicar filtros\']]",\n            ),\n            "descargar_orden": (\n                By.XPATH,\n                "//mat-icon[normalize-space()=\'save_alt\']",\n            ),\n            "toast": (By.CSS_SELECTOR, "div.toast-container"),\n        }\n\n        def esperar_clickable(nombre: str, locator, timeout: int = WAIT_TIMEOUT):\n            ultimo_error: TimeoutException | None = None\n            for condicion in (EC.element_to_be_clickable, EC.presence_of_element_located):\n                try:\n                    condicion_eval = condicion(locator)\n                    elemento = WebDriverWait(driver, timeout).until(condicion_eval)\n                    if elemento:\n                        return elemento\n                except TimeoutException as exc:\n                    ultimo_error = exc\n            logger.error("No se encontró el elemento \'%s\'", nombre)\n            raise RuntimeError(f"No se pudo localizar \'{nombre}\'") from ultimo_error\n\n        def limpiar_y_escribir(nombre: str, locator, texto: str):\n            elemento = esperar_clickable(nombre, locator)\n            elemento.click()\n            elemento.send_keys(Keys.CONTROL, "a")\n            elemento.send_keys(Keys.DELETE)\n            if texto:\n                elemento.send_keys(texto)\n            return elemento\n\n        def hacer_click(nombre: str, locator):\n            elemento = esperar_clickable(nombre, locator)\n            try:\n                elemento.click()\n            except (ElementClickInterceptedException, ElementNotInteractableException):\n                driver.execute_script("arguments[0].click();", elemento)\n            return elemento\n\n        def _hay_toast_visible() -> bool:\n            for elemento in driver.find_elements(*elements["toast"]):\n                try:\n                    if elemento.is_displayed():\n                        return True\n                except StaleElementReferenceException:\n                    continue\n            return False\n\n        def esperar_toast():\n            try:\n                # Esperar a que aparezca un toast (si corresponde)\n                WebDriverWait(driver, 3).until(lambda _d: _hay_toast_visible())\n            except TimeoutException:\n                pass\n\n            try:\n                WebDriverWait(driver, 10).until(lambda _d: not _hay_toast_visible())\n            except TimeoutException:\n                pass\n\n            time.sleep(0.5)\n\n        def _autocompletes_visibles():\n            campos = []\n            for campo in driver.find_elements(By.CSS_SELECTOR, "input[aria-autocomplete=\'list\']"):\n                try:\n                    if campo.is_displayed() and campo.is_enabled():\n                        campos.append(campo)\n                except StaleElementReferenceException:\n                    continue\n            return campos\n\n        def _obtener_por_indice(indice: int):\n            def _resolver(_driver):\n                visibles = _autocompletes_visibles()\n                if len(visibles) > indice:\n                    return visibles[indice]\n                return False\n\n            return WebDriverWait(driver, WAIT_TIMEOUT).until(_resolver)\n\n        def obtener_autocomplete(nombre: str, indice: int):\n            etiquetas = AUTOCOMPLETE_LABELS.get(nombre, [])\n            for etiqueta in etiquetas:\n                try:\n                    campo = _buscar_autocomplete_por_texto(driver, etiqueta)\n                    if campo:\n                        return campo, ("label", etiqueta)\n                except RuntimeError:\n                    continue\n\n            try:\n                campo = _obtener_por_indice(indice)\n                return campo, ("index", indice)\n            except TimeoutException as exc:\n                logger.error("%s: no se encontró un campo visible", nombre)\n                raise RuntimeError(f"No se pudo localizar \'{nombre}\'") from exc\n\n        def _es_campo_autocomplete(elemento) -> bool:\n            try:\n                if elemento.tag_name.lower() != "input":\n                    return False\n            except Exception:\n                return False\n            try:\n\n        def obtener_autocomplete(nombre: str, indice: int):\n            etiquetas = AUTOCOMPLETE_LABELS.get(nombre, [])\n            for etiqueta in etiquetas:\n                try:\n                    campo = _buscar_autocomplete_por_texto(driver, etiqueta)\n                    if campo:\n                        return campo, ("label", etiqueta)\n                except RuntimeError:\n                    continue\n\n            try:\n                campo = _obtener_por_indice(indice)\n                return campo, ("index", indice)\n            except TimeoutException as exc:\n                logger.error("%s: no se encontró un campo visible", nombre)\n                raise RuntimeError(f"No se pudo localizar \'{nombre}\'") from exc\n\n        def _es_campo_autocomplete(elemento) -> bool:\n            try:\n                if elemento.tag_name.lower() != "input":\n                    return False\n            except Exception:\n                return False\n            try:\n                return (elemento.get_attribute("aria-autocomplete") or "").lower() == "list"\n            except Exception:\n                return False\n\n        def _enviar_tabs(cantidad: int, espera: float = 0.2):\n            for _ in range(max(0, cantidad)):\n                try:\n                    activo = driver.switch_to.active_element\n                except Exception:\n                    activo = None\n                if activo is not None:\n                    try:\n                        activo.send_keys(Keys.TAB)\n                    except Exception as exc:\n                        logger.debug("No se pudo enviar TAB directo: %s", exc)\n                        try:\n                            driver.execute_script("arguments[0].dispatchEvent(new KeyboardEvent(\'keydown\', {key: \'Tab\'}));", activo)\n                            driver.execute_script("arguments[0].dispatchEvent(new KeyboardEvent(\'keyup\', {key: \'Tab\'}));", activo)\n                        except Exception:\n                            pass\n                time.sleep(espera)\n\n        def completar_autocomplete(\n            nombre: str,\n            indice: int,\n            texto: str,\n            *,\n            usar_activo: bool = False,\n            avanzar_tab: bool = True,\n        ):\n            if not texto:\n                logger.warning("%s sin valor configurado; se omite", nombre.capitalize())\n                return\n\n            campo = None\n            origen_info = ("index", indice)\n\n            if usar_activo:\n                try:\n                    activo = driver.switch_to.active_element\n                except Exception:\n                    activo = None\n                if activo is not None and _es_campo_autocomplete(activo):\n                    campo = activo\n                    origen_info = ("active", None)\n\n            if campo is None:\n                campo, origen_info = obtener_autocomplete(nombre, indice)\n\n            def refrescar_campo():\n                nonlocal campo, origen_info\n                try:\n                    if campo.is_displayed() and campo.is_enabled():\n                        return campo\n                except StaleElementReferenceException:\n                    pass\n\n                if origen_info[0] == "label":\n                    try:\n                        nuevo = _buscar_autocomplete_por_texto(driver, origen_info[1])\n                        if nuevo:\n                            campo = nuevo\n                            return campo\n                    except RuntimeError:\n                        pass\n\n                try:\n                    nuevo = _obtener_por_indice(indice)\n                    campo = nuevo\n                    origen_info = ("index", indice)\n                except Exception:\n                    pass\n                return campo\n\n            campo = refrescar_campo()\n\n            try:\n                driver.execute_script("arguments[0].scrollIntoView({block: \'center\'});", campo)\n            except Exception:\n                pass\n\n            campo = refrescar_campo()\n            try:\n                campo.click()\n            except Exception:\n                driver.execute_script("arguments[0].focus();", campo)\n\n            campo = refrescar_campo()\n            campo.send_keys(Keys.CONTROL, "a")\n            campo.send_keys(Keys.DELETE)\n            time.sleep(0.1)\n\n            campo = refrescar_campo()\n            campo.send_keys(texto)\n            time.sleep(2)\n\n            campo = refrescar_campo()\n            try:\n                campo.send_keys(Keys.ENTER)\n            except Exception as exc:\n                logger.debug("%s: no se pudo enviar Enter directamente: %s", nombre, exc)\n\n            _esperar_cierre_opciones(driver)\n            time.sleep(0.2)\n\n            logger.info("%s ingresado: %s", nombre.capitalize(), texto)\n\n            if avanzar_tab:\n                try:\n                    campo = refrescar_campo()\n                    campo.send_keys(Keys.TAB)\n                except StaleElementReferenceException:\n                    pass\n\n        driver.get(\n            "https://cas.telconet.ec/cas/login?service="\n            "https://sites.telconet.ec/naf/compras/sso/check"\n        )\n        try:\n            WebDriverWait(driver, WAIT_TIMEOUT).until(\n                EC.presence_of_element_located(elements["usuario"])\n            )\n        except TimeoutException as exc:\n            logger.error("No se encontró el elemento \'%s\'", "usuario")\n            raise RuntimeError("No se pudo localizar \'usuario\'") from exc\n        limpiar_y_escribir("usuario", elements["usuario"], user)\n        limpiar_y_escribir("contrasena", elements["contrasena"], pwd)\n        try:\n            hacer_click("iniciar_sesion", elements["iniciar_sesion"])\n        except RuntimeError:\n            try:\n                campo_pwd = esperar_clickable("contrasena", elements["contrasena"])\n                campo_pwd.send_keys(Keys.RETURN)\n            except RuntimeError:\n                try:\n                    driver.execute_script(\n                        "const f=document.querySelector(\'form\'); if(f) f.submit();"\n                    )\n                except Exception:\n                    raise\n\n        time.sleep(2)\n        for _ in range(3):\n            try:\n                driver.switch_to.window(driver.window_handles[-1])\n            except Exception:\n                pass\n            if driver.find_elements(*elements["lista_accesos"]):\n                break\n            try:\n                menu = driver.find_elements(*elements["menu_hamburguesa"])\n                if menu:\n                    menu[0].click()\n            except Exception:\n                pass\n            time.sleep(2)\n        else:\n            raise RuntimeError("No se pudo localizar \'lista_accesos\'")\n\n        hacer_click("lista_accesos", elements["lista_accesos"])\n        hacer_click("seleccion_compania", elements["seleccion_compania"])\n        limpiar_y_escribir("lista_companias", elements["lista_companias"], "TELCONET")\n        hacer_click("telconet_sa", elements["telconet_sa"])\n        hacer_click("boton_elegir", elements["boton_elegir"])\n        hacer_click("companias_boton_ok", elements["companias_boton_ok"])\n        hacer_click("lista_consultas", elements["lista_consultas"])\n        hacer_click("consulta_ordenes", elements["consulta_ordenes"])\n\n        fecha_desde_fmt = _normalizar_fecha(fecha_desde)\n        fecha_hasta_fmt = _normalizar_fecha(fecha_hasta)\n        campo_fecha_desde = limpiar_y_escribir(\n            "fecha_desde", elements["fecha_desde"], fecha_desde_fmt\n        )\n        campo_fecha_desde.send_keys(Keys.TAB)\n\n        campo_fecha_hasta = limpiar_y_escribir(\n            "fecha_hasta", elements["fecha_hasta"], fecha_hasta_fmt\n        )\n        campo_fecha_hasta.send_keys(Keys.TAB)\n        _enviar_tabs(1)\n\n        completar_autocomplete(\n            "solicitante", 0, solicitante, usar_activo=True, avanzar_tab=False\n        )\n        _enviar_tabs(1)\n\n        completar_autocomplete(\n            "autoriza", 1, autoriza, usar_activo=True, avanzar_tab=False\n        )\n\n        hacer_click("btnbuscarorden", elements["btnbuscarorden"])\n        esperar_toast()\n\n        try:\n            WebDriverWait(driver, 20).until(\n                lambda d: d.find_elements(*elements["descargar_orden"]) or not d.find_elements(*elements["toast"])\n            )\n        except TimeoutException:\n            logger.info("No se encontraron órdenes para los filtros proporcionados.")\n            total_botones = 0\n        else:\n            total_botones = len(driver.find_elements(*elements["descargar_orden"]))\n\n        ordenes: list[dict[str, str]] = []\n        for idx in range(total_botones):\n            botones = driver.find_elements(*elements["descargar_orden"])\n            if idx >= len(botones):\n\n                if origen_info[0] == "label":\n                    try:\n                        nuevo = _buscar_autocomplete_por_texto(driver, origen_info[1])\n                        if nuevo:\n                            campo = nuevo\n                            return campo\n                    except RuntimeError:\n                        pass\n\n                try:\n                    nuevo = _obtener_por_indice(indice)\n                    campo = nuevo\n                    origen_info = ("index", indice)\n                except Exception:\n                    pass\n                return campo\n\n            campo = refrescar_campo()\n\n            try:\n                driver.execute_script("arguments[0].scrollIntoView({block: \'center\'});", campo)\n            except Exception:\n                pass\n\n            campo = refrescar_campo()\n            try:\n                campo.click()\n            except Exception:\n                driver.execute_script("arguments[0].focus();", campo)\n\n            campo = refrescar_campo()\n            campo.send_keys(Keys.CONTROL, "a")\n            campo.send_keys(Keys.DELETE)\n            time.sleep(0.1)\n\n            campo = refrescar_campo()\n            campo.send_keys(texto)\n            time.sleep(2)\n\n            campo = refrescar_campo()\n            try:\n                campo.send_keys(Keys.ENTER)\n            except Exception as exc:\n                logger.debug("%s: no se pudo enviar Enter directamente: %s", nombre, exc)\n\n            _esperar_cierre_opciones(driver)\n            time.sleep(0.2)\n\n            logger.info("%s ingresado: %s", nombre.capitalize(), texto)\n\n            if avanzar_tab:\n                try:\n                    campo = refrescar_campo()\n                    campo.send_keys(Keys.TAB)\n                except StaleElementReferenceException:\n                    pass\n\n        driver.get(\n            "https://cas.telconet.ec/cas/login?service="\n            "https://sites.telconet.ec/naf/compras/sso/check"\n        )\n        try:\n\n            WebDriverWait(driver, WAIT_TIMEOUT).until(\n                EC.presence_of_element_located(elements["usuario"])\n            )\n        except TimeoutException as exc:\n            logger.error("No se encontró el elemento \'%s\'", "usuario")\n            raise RuntimeError("No se pudo localizar \'usuario\'") from exc\n        limpiar_y_escribir("usuario", elements["usuario"], user)\n        limpiar_y_escribir("contrasena", elements["contrasena"], pwd)\n        try:\n            hacer_click("iniciar_sesion", elements["iniciar_sesion"])\n        except RuntimeError:\n            try:\n                campo_pwd = esperar_clickable("contrasena", elements["contrasena"])\n                campo_pwd.send_keys(Keys.RETURN)\n            except RuntimeError:\n                try:\n                    driver.execute_script(\n                        "const f=document.querySelector(\'form\'); if(f) f.submit();"\n                    )\n                except Exception:\n                    raise\n\n        time.sleep(2)\n        for _ in range(3):\n            try:\n                driver.switch_to.window(driver.window_handles[-1])\n            except Exception:\n                pass\n            if driver.find_elements(*elements["lista_accesos"]):\n                break\n            try:\n                menu = driver.find_elements(*elements["menu_hamburguesa"])\n                if menu:\n                    menu[0].click()\n            except Exception:\n                pass\n            time.sleep(2)\n        else:\n            raise RuntimeError("No se pudo localizar \'lista_accesos\'")\n\n        hacer_click("lista_accesos", elements["lista_accesos"])\n        hacer_click("seleccion_compania", elements["seleccion_compania"])\n        limpiar_y_escribir("lista_companias", elements["lista_companias"], "TELCONET")\n        hacer_click("telconet_sa", elements["telconet_sa"])\n        hacer_click("boton_elegir", elements["boton_elegir"])\n        hacer_click("companias_boton_ok", elements["companias_boton_ok"])\n        hacer_click("lista_consultas", elements["lista_consultas"])\n        hacer_click("consulta_ordenes", elements["consulta_ordenes"])\n\n        fecha_desde_fmt = _normalizar_fecha(fecha_desde)\n        fecha_hasta_fmt = _normalizar_fecha(fecha_hasta)\n        campo_fecha_desde = limpiar_y_escribir(\n            "fecha_desde", elements["fecha_desde"], fecha_desde_fmt\n        )\n        campo_fecha_desde.send_keys(Keys.TAB)\n\n        campo_fecha_hasta = limpiar_y_escribir(\n            "fecha_hasta", elements["fecha_hasta"], fecha_hasta_fmt\n        )\n        campo_fecha_hasta.send_keys(Keys.TAB)\n        _enviar_tabs(1)\n\n        completar_autocomplete(\n            "solicitante", 0, solicitante, usar_activo=True, avanzar_tab=False\n        )\n        _enviar_tabs(1)\n\n        completar_autocomplete(\n            "autoriza", 1, autoriza, usar_activo=True, avanzar_tab=False\n        )\n\n        hacer_click("btnbuscarorden", elements["btnbuscarorden"])\n        esperar_toast()\n\n        try:\n            WebDriverWait(driver, 20).until(\n                lambda d: d.find_elements(*elements["descargar_orden"]) or not d.find_elements(*elements["toast"])\n            )\n        except TimeoutException:\n            logger.info("No se encontraron órdenes para los filtros proporcionados.")\n            total_botones = 0\n        else:\n            total_botones = len(driver.find_elements(*elements["descargar_orden"]))\n\n        ordenes: list[dict[str, str]] = []\n        for idx in range(total_botones):\n            botones = driver.find_elements(*elements["descargar_orden"])\n            if idx >= len(botones):\n\n            row = btn.find_element(By.XPATH, "./ancestor::tr")\n            celdas = row.find_elements(By.TAG_NAME, "td")\n            numero = celdas[0].text.strip() if celdas else str(idx)\n            proveedor = celdas[1].text.strip() if len(celdas) > 1 else ""\n        except Exception:\n            numero = str(idx)\n            proveedor = ""\n        existentes = {pdf: pdf.stat().st_mtime for pdf in destino.glob("*.pdf")}\n        try:\n            btn.click()\n        except ElementClickInterceptedException:\n            driver.execute_script("arguments[0].click();", btn)\n        archivo_descargado = esperar_descarga_pdf(destino, existentes)\n        ordenes.append({"numero": numero, "proveedor": proveedor})\n        for _ in range(5):\n            if not driver.find_elements(*elements["toast"]):\n\n                break\n            btn = botones[idx]\n            try:\n                driver.execute_script("arguments[0].scrollIntoView({block: \'center\'});", btn)\n            except Exception:\n                pass\n            time.sleep(0.2)\n            numero, proveedor = _extraer_datos_orden(btn, idx)\n\n            orden = {\n                "numero": numero,\n                "proveedor": proveedor,\n                "categoria": "abastecimiento",\n            }\n            ordenes.append(orden)\n            ordenes.append(\n                {"numero": numero, "proveedor": proveedor, "categoria": "abastecimiento"}\n            )\n            existentes = {pdf: pdf.stat().st_mtime for pdf in destino.glob("*.pdf")}\n            try:\n                btn.click()\n            except (ElementClickInterceptedException, StaleElementReferenceException):\n                driver.execute_script("arguments[0].click();", btn)\n            try:\n                archivo_descargado = esperar_descarga_pdf(destino, existentes)\n                ruta_descargada = Path(archivo_descargado)\n                numero_archivo = _numero_desde_texto(ruta_descargada.stem)\n                if numero_archivo:\n                    orden["numero"] = numero_archivo\n                    numero = numero_archivo\n                logger.info("OC %s descargada en %s", numero, archivo_descargado)\n                proveedor_pdf = proveedor_desde_pdf(archivo_descargado)\n                if proveedor_pdf:\n                    orden["proveedor"] = proveedor_pdf\n                _renombrar_pdf_descargado(\n                    ruta_descargada,\n                    str(numero),\n                    orden.get("proveedor", ""),\n                )\n                base_nombre = _nombre_archivo(numero, proveedor)\n                if base_nombre:\n                    archivo_descargado = _renombrar_descarga(archivo_descargado, base_nombre)\n                logger.info("OC %s descargada en %s", numero, archivo_descargado)\n            except Exception as exc:\n                logger.error("No se pudo descargar la OC %s: %s", numero, exc)\n            esperar_toast()\n            time.sleep(0.5)\n\n        if ordenes:\n            actualizar_proveedores_desde_pdfs(ordenes, destino)\n\n        logger.info("Total de órdenes detectadas: %s", len(ordenes))\n    finally:\n        driver.quit()\n\n    if getattr(cfg, \'abastecimiento_mover_archivos\', True):\n        subidos, faltantes, errores_mov = mover_oc(cfg, ordenes)\n    else:\n        subidos = [o.get(\'numero\') for o in ordenes if o.get(\'numero\')]\n        faltantes, errores_mov = [], []\n\n    for err in errores_mov:\n        logger.error("Mover OC: %s", err)\n\n    enviar_reporte(\n        subidos,\n        faltantes,\n        ordenes,\n        cfg,\n        categoria="abastecimiento",\n        destinatario=cfg.abastecimiento_correo_reporte,\n    )\n    return subidos, faltantes\n\n\nif __name__ == "__main__":  # pragma: no cover\n    descargar_abastecimiento("01/01/24", "02/01/24", "", "")\n',
    'DescargasOC-main/descargas_oc/selenium_modulo.py': '"""Automatizaciones con Selenium para Descargas OC.\n\nEste módulo realiza el proceso completo de autenticación y descarga de órdenes\nde compra desde el portal de Telconet. Cada elemento de la interfaz recibe un\nnombre legible para facilitar el control de errores y la trazabilidad.\n"""\n\nfrom __future__ import annotations\n\nimport subprocess\nimport sys\nimport time\nfrom pathlib import Path\n\nfrom selenium import webdriver\nfrom selenium.common.exceptions import ElementClickInterceptedException\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\n\ntry:  # permite ejecutar como script\n    from .seafile_client import SeafileClient\nexcept ImportError:  # pragma: no cover\n    from seafile_client import SeafileClient\n\ntry:  # permite ejecutar como script\n    from .config import Config\n    from .mover_pdf import mover_oc, normalizar_nombre_archivo\n    from .organizador_bienes import organizar as organizar_bienes\n    from .pdf_info import actualizar_proveedores_desde_pdfs\nexcept ImportError:  # pragma: no cover\n    from config import Config\n    from mover_pdf import mover_oc, normalizar_nombre_archivo\n    from organizador_bienes import organizar as organizar_bienes\n    from pdf_info import actualizar_proveedores_desde_pdfs\n\n\ndef esperar_descarga_pdf(\n    directory: Path,\n    existentes: dict[Path, float],\n    timeout: float = 60.0,\n    intervalo: float = 0.5,\n) -> Path:\n    """Espera a que aparezca un PDF nuevo o actualizado en ``directory``."""\n\n    limite = time.monotonic() + timeout\n    while time.monotonic() < limite:\n        time.sleep(intervalo)\n        candidatos: list[tuple[float, Path]] = []\n        for pdf in directory.glob("*.pdf"):\n            try:\n                mtime = pdf.stat().st_mtime\n            except FileNotFoundError:\n                continue\n            anterior = existentes.get(pdf)\n            if anterior is None or mtime > anterior:\n                candidatos.append((mtime, pdf))\n        if not candidatos:\n            continue\n        candidatos.sort()\n        candidato = candidatos[-1][1]\n        crdownload = candidato.with_suffix(candidato.suffix + ".crdownload")\n        if crdownload.exists():\n            continue\n        try:\n            size = candidato.stat().st_size\n        except FileNotFoundError:\n            continue\n        time.sleep(min(intervalo / 2, 0.5))\n        try:\n            if candidato.stat().st_size != size:\n                continue\n        except FileNotFoundError:\n            continue\n        return candidato\n    raise RuntimeError("No se descargó archivo")\n\n\ndef esperar_descarga_pdf(\n    directory: Path,\n    existentes: dict[Path, float],\n    timeout: float = 60.0,\n    intervalo: float = 0.5,\n) -> Path:\n    """Espera a que aparezca un PDF nuevo o actualizado en ``directory``."""\n\n    limite = time.monotonic() + timeout\n    while time.monotonic() < limite:\n        time.sleep(intervalo)\n        candidatos: list[tuple[float, Path]] = []\n        for pdf in directory.glob("*.pdf"):\n            try:\n                mtime = pdf.stat().st_mtime\n            except FileNotFoundError:\n                continue\n            anterior = existentes.get(pdf)\n            if anterior is None or mtime > anterior:\n                candidatos.append((mtime, pdf))\n        if not candidatos:\n            continue\n        candidatos.sort()\n        candidato = candidatos[-1][1]\n        crdownload = candidato.with_suffix(candidato.suffix + ".crdownload")\n        if crdownload.exists():\n            continue\n        try:\n            size = candidato.stat().st_size\n        except FileNotFoundError:\n            continue\n        time.sleep(min(intervalo / 2, 0.5))\n        try:\n            if candidato.stat().st_size != size:\n                continue\n        except FileNotFoundError:\n            continue\n        return candidato\n    raise RuntimeError("No se descargó archivo")\n\n\ndef descargar_oc(\n    ordenes,\n    username: str | None = None,\n    password: str | None = None,\n    headless: bool = False,\n):\n    """Descarga una o varias órdenes de compra.\n\n    ``ordenes`` es una lista de diccionarios con las claves ``numero`` y\n    ``proveedor``. El proceso inicia sesión una sola vez y repite la búsqueda y\n    descarga para cada OC encontrada en el correo.\n    """\n\n    if isinstance(ordenes, dict):\n        ordenes = [ordenes]\n\n    # Asegurar sincronización de SeaDrive antes de iniciar Selenium\n    script = Path(__file__).resolve().parents[1] / "scripts" / "seadrive_autoresync.py"\n    if script.exists():  # pragma: no cover - depende del entorno Windows\n        try:\n            subprocess.run([sys.executable, str(script)], check=False)\n        except Exception:\n            pass\n\n    cfg = Config()\n    download_dir = Path(cfg.carpeta_destino_local or Path.home() / "Documentos")\n    download_dir.mkdir(parents=True, exist_ok=True)\n\n    def _renombrar_descarga(archivo: Path, base: str | None) -> Path:\n        if not base:\n            return archivo\n        destino = download_dir / f"{base}.pdf"\n        if archivo == destino:\n            return archivo\n        intento = 0\n        while True:\n            candidato = destino if intento == 0 else download_dir / f"{base} ({intento}).pdf"\n            try:\n                archivo.rename(candidato)\n                return candidato\n            except FileExistsError:\n                intento += 1\n                continue\n            except OSError:\n                break\n        return archivo\n\n    user = username if username is not None else cfg.usuario\n    if user:\n        user = user.split("@")[0]\n    pwd = password if password is not None else cfg.password\n\n    cliente = SeafileClient(cfg.seafile_url, cfg.usuario, cfg.password)\n    repo_id = cfg.seafile_repo_id\n    subfolder = cfg.seafile_subfolder or "/"\n\n    options = webdriver.ChromeOptions()\n    prefs = {\n        "download.default_directory": str(download_dir),\n        "download.prompt_for_download": False,\n        "plugins.always_open_pdf_externally": True,\n    }\n    options.add_experimental_option("prefs", prefs)\n    options.add_experimental_option(\n        "excludeSwitches", ["enable-automation", "enable-logging"]\n    )\n    options.add_experimental_option("useAutomationExtension", False)\n    options.add_argument("--disable-blink-features=AutomationControlled")\n    if headless:\n        options.add_argument("--headless=new")\n    options.add_argument("--disable-gpu")\n    options.add_argument("--window-size=1920,1080")\n    options.add_argument("--no-sandbox")\n    options.add_argument("--disable-dev-shm-usage")\n    options.add_argument("--log-level=3")\n    driver = webdriver.Chrome(options=options)\n    try:\n        driver.execute_cdp_cmd(\n            "Page.setDownloadBehavior",\n            {"behavior": "allow", "downloadPath": str(download_dir)},\n        )\n    except Exception:  # pragma: no cover - depende de la implementación de Chrome\n        pass\n\n    elements = {\n        "usuario": (By.ID, "username"),\n        "contrasena": (By.ID, "password"),\n        "iniciar_sesion": (\n            By.CSS_SELECTOR,\n            "button[type=\'submit\'], input[type=\'submit\']",\n        ),\n        "lista_accesos": (\n            By.XPATH,\n            "//span[contains(@class,\'simple-sidenav__text\') and contains(text(),\'Accesos\')]",\n        ),\n        "seleccion_compania": (\n            By.XPATH,\n            "//span[contains(@class,\'simple-sidenav__text\') and contains(text(),\'Selección de Compañía\')]",\n        ),\n        "lista_companias": (By.CSS_SELECTOR, "input[aria-autocomplete=\'list\']"),\n        "telconet_sa": (\n            By.XPATH,\n            "//div[contains(@class,\'ng-star-inserted\') and contains(.,\'TELCONET S.A.\')]",\n        ),\n        "boton_elegir": (By.XPATH, "//span[contains(text(),\'Elegir\')]"),\n        "companias_boton_ok": (\n            By.CSS_SELECTOR,\n            "button.swal2-confirm.swal2-styled",\n        ),\n        "lista_consultas": (\n            By.XPATH,\n            "//span[contains(@class,\'simple-sidenav__text\') and contains(text(),\'Consultas\')]",\n        ),\n        "consulta_ordenes": (\n            By.XPATH,\n            "//span[contains(@class,\'simple-sidenav__text\') and contains(text(),\'Consulta de Órdenes de Compra\')]",\n        ),\n        "digitar_oc": (\n            By.CSS_SELECTOR,\n            "input[data-placeholder=\'Digite el número de la O/C\']",\n        ),\n        "btnbuscarorden": (\n            By.XPATH,\n            "//button[.//span[contains(text(),\'Aplicar filtros\')]]",\n        ),\n        "descargar_orden": (\n            By.XPATH,\n            "//mat-icon[normalize-space()=\'save_alt\']",\n        ),\n        "toast": (By.CSS_SELECTOR, "div.toast-container"),\n        "menu_hamburguesa": (By.CSS_SELECTOR, "button.simple-sidenav__toggle"),\n    }\n\n    def _find(name: str, locator, retries: int = 5, delay: float = 2.0):\n        """Busca un elemento realizando varios intentos."""\n\n        def search(loc):\n            try:\n                elems = driver.find_elements(*loc)\n                if elems:\n                    return elems[0]\n            except Exception:\n                return None\n\n        for _ in range(retries):\n            for handle in driver.window_handles:\n                try:\n                    driver.switch_to.window(handle)\n                except Exception:\n                    continue\n                driver.switch_to.default_content()\n                elem = search(locator)\n                if elem:\n                    return elem\n                frames = driver.find_elements(By.TAG_NAME, "iframe")\n                for frame in frames:\n                    try:\n                        driver.switch_to.frame(frame)\n                        elem = search(locator)\n                        if elem:\n                            return elem\n                    except Exception:\n                        pass\n                driver.switch_to.default_content()\n            time.sleep(delay)\n        raise RuntimeError(f"Fallo al localizar \'{name}\'")\n\n    def _click(name: str, locator):\n        for _ in range(3):\n            elem = _find(name, locator)\n            try:\n                elem.click()\n                return\n            except ElementClickInterceptedException:\n                driver.execute_script("arguments[0].click();", elem)\n                return\n            except Exception:\n                time.sleep(2)\n        raise RuntimeError(f"No se pudo hacer click en \'{name}\'")\n\n    errores: list[str] = []\n    try:\n        driver.get(\n            "https://cas.telconet.ec/cas/login?service="\n            "https://sites.telconet.ec/naf/compras/sso/check"\n        )\n\n        time.sleep(2)\n        user_el = _find("usuario", elements["usuario"])\n        pass_el = _find("contrasena", elements["contrasena"])\n        user_el.send_keys(user or "")\n        pass_el.send_keys(pwd or "")\n        try:\n            _click("iniciar_sesion", elements["iniciar_sesion"])\n        except RuntimeError:\n            # si no se encuentra el botón, intentar enviar Enter o usar submit\n            try:\n                pass_el = _find("contrasena", elements["contrasena"])\n                try:\n                    pass_el.send_keys(Keys.RETURN)\n                except Exception:\n                    pass\n            except Exception:\n                pass\n            try:\n                driver.execute_script(\n                    "const f=document.querySelector(\'form\'); if(f) f.submit();"\n                )\n            except Exception:\n                pass\n        time.sleep(2)\n        for _ in range(3):\n            try:\n                driver.switch_to.window(driver.window_handles[-1])\n            except Exception:\n                pass\n            if driver.find_elements(*elements["lista_accesos"]):\n                break\n            try:\n                menu = driver.find_elements(*elements["menu_hamburguesa"])\n                if menu:\n                    menu[0].click()\n            except Exception:\n                pass\n            time.sleep(2)\n        else:\n            raise RuntimeError("Fallo al localizar \'lista_accesos\'")\n        _click("lista_accesos", elements["lista_accesos"])\n        _click("seleccion_compania", elements["seleccion_compania"])\n        _find("lista_companias", elements["lista_companias"]).send_keys("TELCONET S.A.")\n        _click("telconet_sa", elements["telconet_sa"])\n        _click("boton_elegir", elements["boton_elegir"])\n        _click("companias_boton_ok", elements["companias_boton_ok"])\n        _click("lista_consultas", elements["lista_consultas"])\n        _click("consulta_ordenes", elements["consulta_ordenes"])\n\n        for oc in ordenes:\n            numero = oc.get("numero")\n            proveedor = oc.get("proveedor", "")\n            try:\n                campo = _find("digitar_oc", elements["digitar_oc"])\n                campo.clear()\n                campo.send_keys(numero)\n                time.sleep(2)\n                _click("btnbuscarorden", elements["btnbuscarorden"])\n\n                for _ in range(5):\n                    if not driver.find_elements(*elements["toast"]):\n                        break\n                    time.sleep(2)\n                boton_descarga = _find("descargar_orden", elements["descargar_orden"])\n                existentes = {\n                    pdf: pdf.stat().st_mtime for pdf in download_dir.glob("*.pdf")\n                }\n                try:\n                    boton_descarga.click()\n                except ElementClickInterceptedException:\n                    driver.execute_script("arguments[0].click();", boton_descarga)\n\n                archivo = esperar_descarga_pdf(download_dir, existentes)\n                if not getattr(cfg, "compra_bienes", False):\n                    prov_clean = None\n                    if proveedor:\n                        prov_clean = re.sub(r"[^\\w\\- ]", "_", proveedor)\n                        prov_clean = re.sub(r"\\s+", " ", prov_clean).strip()\n                        if not prov_clean:\n                            prov_clean = None\n                    partes: list[str] = []\n                    if numero:\n                        partes.append(str(numero))\n                    if prov_clean:\n                        partes.append(prov_clean)\n                    base_nombre = " - ".join(partes) if partes else None\n                    archivo = _renombrar_descarga(archivo, base_nombre)\n                antes = set(download_dir.glob("*.pdf"))\n                for _ in range(120):  # esperar hasta 60 s\n                    time.sleep(0.5)\n                    nuevos = set(download_dir.glob("*.pdf")) - antes\n                    if nuevos:\n                        archivo = nuevos.pop()\n                        break\n                else:\n                    raise RuntimeError("No se descargó archivo")\n                if not getattr(cfg, "compra_bienes", False) and proveedor:\n                    prov_clean = normalizar_nombre_archivo(proveedor)\n                    nuevo_nombre = download_dir / f"{numero} - {prov_clean}.pdf"\n                    try:\n                        archivo.rename(nuevo_nombre)\n                        archivo = nuevo_nombre\n                        except Exception:\n                            prov_clean = normalizar_nombre_archivo(proveedor, longitud_maxima=20)\n                            nuevo_nombre = download_dir / f"{numero} - {prov_clean}.pdf"\n                            try:\n                                archivo.rename(nuevo_nombre)\n                                archivo = nuevo_nombre\n                            except Exception:\n                                pass\n                try:\n                    cliente.upload_file(\n                        repo_id, str(archivo), parent_dir=subfolder\n                    )\n                except Exception as e:\n                    errores.append(f"OC {numero}: fallo subida {e}")\n            except Exception as exc:  # pragma: no cover - incidencias en ejecución\n                errores.append(f"OC {numero}: {exc}")\n    finally:\n        driver.quit()\n\n    if ordenes:\n        actualizar_proveedores_desde_pdfs(ordenes, download_dir)\n\n    numeros = [oc.get("numero") for oc in ordenes]\n    subidos, faltantes, errores_mov = mover_oc(cfg, ordenes)\n    if getattr(cfg, "compra_bienes", False):\n        organizar_bienes(cfg.carpeta_analizar, cfg.carpeta_analizar)\n    errores.extend(errores_mov)\n    faltantes.extend(n for n in numeros if any(n in e for e in errores))\n    # evitar números repetidos al reportar faltantes\n    faltantes = list(dict.fromkeys(faltantes))\n    return subidos, faltantes, errores\n\n\nif __name__ == "__main__":  # pragma: no cover\n    descargar_oc([])\n\n',
    'DescargasOC-main/descargas_oc/ui.py': 'import tkinter as tk\nimport threading\nimport logging\nimport re\nfrom datetime import datetime\nfrom tkinter import messagebox\n\ntry:  # permite ejecutar como script\n    from .escuchador import buscar_ocs, cargar_ultimo_uidl, registrar_procesados\n    from .selenium_modulo import descargar_oc\n    from .reporter import enviar_reporte\n    from .config import Config\n    from .logger import get_logger\nexcept ImportError:  # pragma: no cover\n    from escuchador import buscar_ocs, cargar_ultimo_uidl, registrar_procesados\n    from selenium_modulo import descargar_oc\n    from reporter import enviar_reporte\n    from config import Config\n    from logger import get_logger\n\nlogger = get_logger(__name__)\n\nscanning_lock = threading.Lock()\n\n\ndef center_window(win: tk.Tk | tk.Toplevel):\n    win.update_idletasks()\n    w = win.winfo_width()\n    h = win.winfo_height()\n    x = (win.winfo_screenwidth() // 2) - (w // 2)\n    y = (win.winfo_screenheight() // 2) - (h // 2)\n    win.geometry(f"{w}x{h}+{x}+{y}")\n\n\ndef config_completa(cfg: Config) -> bool:\n    try:\n        cfg.validate()\n    except Exception:\n        return False\n    requeridos = [\n        cfg.usuario,\n        cfg.password,\n        cfg.carpeta_destino_local,\n        cfg.carpeta_analizar,\n        cfg.seafile_url,\n        cfg.seafile_repo_id,\n        cfg.correo_reporte,\n    ]\n    return all(requeridos)\n\n\nclass TextHandler(logging.Handler):\n    def __init__(self, widget: tk.Text):\n        super().__init__()\n        self.widget = widget\n\n    def emit(self, record: logging.LogRecord):\n        msg = self.format(record) + "\\n"\n        self.widget.after(0, lambda m=msg: (self.widget.insert(tk.END, m), self.widget.see(tk.END)))\n\n\ndef realizar_escaneo(text_widget: tk.Text, lbl_last: tk.Label):\n    if not scanning_lock.acquire(blocking=False):\n        text_widget.insert(tk.END, "Escaneo en progreso...\\n")\n        text_widget.see(tk.END)\n        return\n    try:\n        cfg = Config()\n        if not config_completa(cfg):\n            messagebox.showerror(\n                "Error", "Configuración incompleta o por favor configurar correctamente"\n            )\n            return\n\n        def append(msg: str):\n            text_widget.after(0, lambda m=msg: (text_widget.insert(tk.END, m), text_widget.see(tk.END)))\n\n        append("Buscando órdenes...\\n")\n        ordenes, ultimo = buscar_ocs(cfg)\n        uidl_por_numero = {\n            o.get("numero"): o.get("uidl")\n            for o in ordenes\n            if o.get("numero") and o.get("uidl")\n        }\n        uidl_a_numeros: dict[str, set[str]] = {}\n        for numero, uidl in uidl_por_numero.items():\n            if not uidl:\n                continue\n            uidl_a_numeros.setdefault(uidl, set()).add(numero)\n        pendientes_uidls = set(uidl_a_numeros)\n        exitosas: list[str] = []\n        faltantes: list[str] = []\n        errores: list[str] = []\n        if ordenes:\n            append(f"Procesando {len(ordenes)} OC(s)\\n")\n            try:\n                subidos, no_encontrados, errores = descargar_oc(\n                    ordenes, headless=cfg.headless\n                )\n            except Exception as exc:  # pragma: no cover - seguridad en ejecución\n                logger.exception("Fallo al descargar OC")\n                errores = [str(exc)]\n                subidos, no_encontrados = [], [o.get("numero") for o in ordenes]\n            exitosas.extend(subidos)\n            faltantes.extend(no_encontrados)\n            numeros_con_problemas = {str(n) for n in no_encontrados}\n            for error in errores:\n                m = re.search(r"OC\\s*(\\d+)", error)\n                if m:\n                    numeros_con_problemas.add(m.group(1))\n            uidls_con_problemas = {\n                uidl_por_numero[num]\n                for num in numeros_con_problemas\n                if num in uidl_por_numero and uidl_por_numero[num]\n            }\n            subidos_set = set(subidos)\n            uidls_exitosos: list[str] = []\n            for orden in ordenes:\n                uidl = orden.get("uidl")\n                if not uidl or uidl in uidls_con_problemas:\n                    continue\n                numeros_uidl = uidl_a_numeros.get(uidl, set())\n                if numeros_uidl and numeros_uidl.issubset(subidos_set) and uidl not in uidls_exitosos:\n                    uidls_exitosos.append(uidl)\n            pendientes_uidls -= set(uidls_exitosos)\n            for num in subidos:\n                append(f"✔️ OC {num} procesada\\n")\n            for num in no_encontrados:\n                append(f"❌ OC {num} faltante\\n")\n            if uidls_exitosos:\n                uidls_sin_duplicados = list(dict.fromkeys(uidls_exitosos))\n                ultimo_guardar = ultimo if not pendientes_uidls else None\n                registrar_procesados(uidls_sin_duplicados, ultimo_guardar)\n        else:\n            append("No se encontraron nuevas órdenes\\n")\n        enviado = enviar_reporte(exitosas, faltantes, ordenes, cfg)\n        if ordenes:\n            if errores:\n                summary = "Errores durante la descarga:\\n" + "\\n".join(errores)\n            elif enviado:\n                summary = "ORDENES DE COMPRA DESCARGADAS Y REPORTE ENVIADO"\n            else:\n                summary = "No se pudo enviar el reporte"\n            text_widget.after(0, lambda: messagebox.showinfo("Resultado", summary))\n        append("Proceso finalizado\\n")\n        lbl_last.config(\n            text="Último UIDL: {} - {}".format(\n                cargar_ultimo_uidl(), datetime.now().strftime("%H:%M:%S")\n            )\n        )\n    finally:\n        scanning_lock.release()\n\n\ndef main():\n    root = tk.Tk()\n    root.title("Descargas OC")\n    root.tk_setPalette(\n        background="#1e1e1e",\n        foreground="#f0f0f0",\n        activeBackground="#333333",\n        activeForeground="#f0f0f0",\n        highlightColor="#555555",\n    )\n    root.configure(bg="#1e1e1e")\n\n    frame = tk.Frame(root)\n    frame.pack(padx=10, pady=10)\n\n    text = tk.Text(frame, width=80, height=20, bg="#000000", fg="#f0f0f0", insertbackground="#f0f0f0")\n    text.pack(pady=5)\n\n    handler = TextHandler(text)\n    handler.setFormatter(logging.Formatter(\'%(asctime)s [%(levelname)s] %(message)s\'))\n    logging.getLogger().addHandler(handler)\n\n    estado = {"activo": False, "contador": 0}\n    lbl_contador = tk.Label(frame, text="Escuchador detenido")\n    lbl_contador.pack()\n    lbl_last = tk.Label(frame, text="Último UIDL: " + (cargar_ultimo_uidl() or \'-\'))\n    lbl_last.pack()\n\n    cfg = Config()\n    manual_mode = {"active": False}\n\n    def actualizar_contador():\n        if estado["activo"]:\n            if estado["contador"] <= 0:\n                threading.Thread(target=realizar_escaneo, args=(text, lbl_last), daemon=True).start()\n                estado["contador"] = cfg.scan_interval\n            lbl_contador.config(text=f"Siguiente escaneo en {estado[\'contador\']} s")\n            estado["contador"] -= 1\n            root.after(1000, actualizar_contador)\n        else:\n            lbl_contador.config(text="Escuchador detenido")\n\n    def toggle():\n        if estado["activo"]:\n            estado["activo"] = False\n            btn_toggle.config(text="Activar escuchador")\n        else:\n            if not config_completa(cfg):\n                messagebox.showerror(\n                    "Error",\n                    "Configuración incompleta o por favor configurar correctamente",\n                )\n                return\n            estado["activo"] = True\n            estado["contador"] = cfg.scan_interval\n            btn_toggle.config(text="Detener escuchador")\n            actualizar_contador()\n\n    def escanear_ahora():\n        estado["contador"] = cfg.scan_interval\n        threading.Thread(target=realizar_escaneo, args=(text, lbl_last), daemon=True).start()\n\n    def activar_manual():\n        manual_mode["active"] = True\n        text.delete("1.0", tk.END)\n        text.insert(tk.END, "Introduzca ordenes que desea descargar 1 por linea:\\n")\n        btn_ejecutar.config(state=tk.DISABLED)\n        text.focus_set()\n\n    def check_manual_input(event=None):\n        if manual_mode["active"]:\n            contenido = text.get("2.0", tk.END).strip()\n            btn_ejecutar.config(state=tk.NORMAL if contenido else tk.DISABLED)\n\n    text.bind("<KeyRelease>", check_manual_input)\n\n    def ejecutar_manual():\n        if not scanning_lock.acquire(blocking=False):\n            text.insert(tk.END, "Descarga en progreso...\\n")\n            text.see(tk.END)\n            return\n        contenido = text.get("2.0", tk.END).strip()\n        numeros = [n.strip() for n in contenido.splitlines() if n.strip()]\n        if not numeros:\n            scanning_lock.release()\n            return\n        if not messagebox.askyesno(\n            "Confirmación",\n            "Se descargarán las siguientes órdenes:\\n" + "\\n".join(numeros),\n        ):\n            scanning_lock.release()\n            return\n        text.delete("1.0", tk.END)\n        manual_mode["active"] = False\n        btn_ejecutar.config(state=tk.DISABLED)\n\n        def run():\n            try:\n                cfg.load()\n                ordenes = [{"numero": n} for n in numeros]\n\n                def append(msg: str):\n                    text.after(0, lambda m=msg: (text.insert(tk.END, m), text.see(tk.END)))\n\n                append(f"Procesando {len(ordenes)} OC(s)\\n")\n                try:\n                    subidos, no_encontrados, errores = descargar_oc(\n                        ordenes, headless=cfg.headless\n                    )\n                except Exception as exc:\n                    errores = [str(exc)]\n                    subidos, no_encontrados = [], numeros\n                for num in subidos:\n                    append(f"✔️ OC {num} procesada\\n")\n                for num in no_encontrados:\n                    append(f"❌ OC {num} faltante\\n")\n                enviar_reporte(subidos, no_encontrados, ordenes, cfg)\n                if errores:\n                    summary = "Errores durante la descarga:\\n" + "\\n".join(errores)\n                else:\n                    summary = "Proceso finalizado"\n                text.after(0, lambda: messagebox.showinfo("Resultado", summary))\n            finally:\n                scanning_lock.release()\n                text.after(0, lambda: btn_ejecutar.config(state=tk.DISABLED))\n\n        threading.Thread(target=run, daemon=True).start()\n\n    def actualizar_intervalo():\n        try:\n            val = int(entry_interval.get())\n            if val >= 300:\n                cfg.load()\n                cfg.data[\'scan_interval\'] = val\n                cfg.save()\n                estado[\'contador\'] = val\n        except ValueError:\n            pass\n\n    btn_toggle = tk.Button(frame, text="Activar escuchador", command=toggle)\n    btn_toggle.pack(side=tk.LEFT, padx=5)\n\n    btn_escanear = tk.Button(frame, text="Escanear ahora", command=escanear_ahora)\n    btn_escanear.pack(side=tk.LEFT, padx=5)\n\n    btn_manual = tk.Button(frame, text="Descarga manual", command=activar_manual)\n    btn_manual.pack(side=tk.LEFT, padx=5)\n    btn_ejecutar = tk.Button(frame, text="Ejecutar descarga", command=ejecutar_manual, state=tk.DISABLED)\n    btn_ejecutar.pack(side=tk.LEFT, padx=5)\n\n    var_bienes = tk.BooleanVar(value=bool(cfg.compra_bienes))\n\n    def actualizar_bienes():\n        cfg.load()\n        cfg.data[\'compra_bienes\'] = var_bienes.get()\n        cfg.save()\n\n    chk_bienes = tk.Checkbutton(\n        frame,\n        text="Compra Bienes",\n        variable=var_bienes,\n        command=actualizar_bienes,\n        selectcolor="#00aa00",\n    )\n    chk_bienes.pack(side=tk.LEFT, padx=5)\n\n    var_visible = tk.BooleanVar(value=not bool(cfg.headless))\n\n    def actualizar_visible():\n        cfg.load()\n        cfg.data[\'headless\'] = not var_visible.get()\n        cfg.save()\n\n    chk_visible = tk.Checkbutton(\n        frame,\n        text="Descarga visible",\n        variable=var_visible,\n        command=actualizar_visible,\n        selectcolor="#00aa00",\n    )\n    chk_visible.pack(side=tk.LEFT, padx=5)\n\n    tk.Label(frame, text="Intervalo(seg):").pack(side=tk.LEFT, padx=5)\n    entry_interval = tk.Entry(frame, width=5)\n    entry_interval.insert(0, str(cfg.scan_interval))\n    entry_interval.pack(side=tk.LEFT)\n    btn_interval = tk.Button(frame, text="Guardar", command=actualizar_intervalo)\n    btn_interval.pack(side=tk.LEFT, padx=5)\n\n    center_window(root)\n    root.mainloop()\n\n\nif __name__ == \'__main__\':\n    main()\n',
    'DescargasOC-main/descargas_oc/ui_abastecimiento.py': '"""Interfaz para descargar órdenes de compra de Abastecimiento."""\nimport threading\nimport tkinter as tk\nfrom tkinter import messagebox\nfrom tkinter import ttk\n\ntry:  # permite ejecutar como script\n    from .selenium_abastecimiento import descargar_abastecimiento\n    from .config import Config\nexcept ImportError:  # pragma: no cover\n    from selenium_abastecimiento import descargar_abastecimiento\n    from config import Config\n\nlock = threading.Lock()\n\n# Valor por defecto para el campo "Solicitante"\nDEFAULT_SOLICITANTE = "1221 - HERRERA PUENTE WILLIAM"\n\n\ndef ejecutar(entry_fd, entry_fh, entry_sol, entry_aut, btn):\n    if not lock.acquire(blocking=False):\n        messagebox.showinfo("Proceso en curso", "Ya existe una descarga en ejecución")\n        return\n\n    fd = entry_fd.get().strip()\n    fh = entry_fh.get().strip()\n    sol = entry_sol.get().strip()\n    aut = entry_aut.get().strip()\n    cfg = Config()\n    btn.config(state=tk.DISABLED)\n\n    def tarea():\n        try:\n            descargar_abastecimiento(\n                fd, fh, sol, aut, headless=cfg.abastecimiento_headless\n            )\n            messagebox.showinfo("Finalizado", "Proceso completado")\n        except Exception as exc:\n            messagebox.showerror("Error", str(exc))\n        finally:\n            lock.release()\n            btn.config(state=tk.NORMAL)\n\n    threading.Thread(target=tarea, daemon=True).start()\n\n\ndef main():\n    root = tk.Tk()\n    root.title("Descarga Abastecimiento")\n    root.tk_setPalette(\n        background="#1e1e1e",\n        foreground="#f0f0f0",\n        activeBackground="#333333",\n        activeForeground="#f0f0f0",\n        highlightColor="#555555",\n    )\n    root.configure(bg="#1e1e1e")\n\n    tk.Label(root, text="Fecha inicio (dd/mm/aa):").grid(row=0, column=0, sticky="e")\n    entry_fd = tk.Entry(root)\n    entry_fd.grid(row=0, column=1, padx=5, pady=2)\n\n    tk.Label(root, text="Fecha final (dd/mm/aa):").grid(row=1, column=0, sticky="e")\n    entry_fh = tk.Entry(root)\n    entry_fh.grid(row=1, column=1, padx=5, pady=2)\n\n    cfg = Config()\n    tk.Label(root, text="Solicitante:").grid(row=2, column=0, sticky="e")\n    solicitantes = cfg.abastecimiento_solicitantes or []\n    if DEFAULT_SOLICITANTE not in solicitantes:\n        solicitantes.insert(0, DEFAULT_SOLICITANTE)\n    sol_var = tk.StringVar(value=DEFAULT_SOLICITANTE)\n    entry_sol = ttk.Combobox(\n        root,\n        textvariable=sol_var,\n        values=solicitantes,\n        width=40,\n    )\n    entry_sol.grid(row=2, column=1, padx=5, pady=2)\n\n    tk.Label(root, text="Autoriza:").grid(row=3, column=0, sticky="e")\n    aut_var = tk.StringVar()\n    entry_aut = ttk.Combobox(\n        root,\n        textvariable=aut_var,\n        values=cfg.abastecimiento_autorizadores or [],\n        width=40,\n    )\n    entry_aut.grid(row=3, column=1, padx=5, pady=2)\n\n    var_visible = tk.BooleanVar(value=not bool(cfg.headless))\n\n    def actualizar_visible():\n        cfg.load()\n        cfg.data["headless"] = not var_visible.get()\n        cfg.save()\n\n    chk_visible = tk.Checkbutton(\n        root,\n        text="Descarga visible",\n        variable=var_visible,\n        command=actualizar_visible,\n        selectcolor="#00aa00",\n    )\n    chk_visible.grid(row=4, column=1, sticky="w", padx=5, pady=2)\n\n    btn_ejecutar = tk.Button(\n        root,\n        text="Descargar",\n        command=lambda: ejecutar(entry_fd, entry_fh, entry_sol, entry_aut, btn_ejecutar),\n    )\n    btn_ejecutar.grid(row=5, column=0, columnspan=2, pady=10)\n\n    def abrir_config():\n        configurar_abastecimiento()\n        nuevo = Config()\n        if entry_sol.winfo_exists():\n            solicitantes = nuevo.abastecimiento_solicitantes or []\n            if DEFAULT_SOLICITANTE not in solicitantes:\n                solicitantes.insert(0, DEFAULT_SOLICITANTE)\n            entry_sol[\'values\'] = solicitantes\n            sol_var.set(DEFAULT_SOLICITANTE)\n        if entry_aut.winfo_exists():\n            entry_aut[\'values\'] = nuevo.abastecimiento_autorizadores or []\n\n    btn_cfg = tk.Button(root, text="Configurar", command=abrir_config)\n    btn_cfg.grid(row=6, column=0, columnspan=2, pady=(0, 10))\n\n    def center_window(win):\n        win.update_idletasks()\n        w = win.winfo_width()\n        h = win.winfo_height()\n        x = (win.winfo_screenwidth() // 2) - (w // 2)\n        y = (win.winfo_screenheight() // 2) - (h // 2)\n        win.geometry(f"{w}x{h}+{x}+{y}")\n\n    center_window(root)\n    root.mainloop()\n\n\nif __name__ == "__main__":  # pragma: no cover\n    main()\n',
    'DescargasOC-main/tests/test_mover_pdf.py': 'import sys\nimport types\nfrom types import SimpleNamespace\n\nfake_pdf = types.ModuleType("PyPDF2")\n\n\nclass DummyReader:\n    def __init__(self, _file):\n        self.pages = []\n\n\nfake_pdf.PdfReader = DummyReader\nsys.modules.setdefault("PyPDF2", fake_pdf)\n\nfrom descargas_oc import mover_pdf\n\n\ndef _config(tmp_path, bienes=True):\n    origen = tmp_path / "descargas"\n    destino = tmp_path / "destino"\n    origen.mkdir()\n    destino.mkdir()\n    return (\n        SimpleNamespace(\n            compra_bienes=bienes,\n            carpeta_destino_local=str(origen),\n            carpeta_analizar=str(destino),\n            abastecimiento_carpeta_descarga=str(origen),\n        ),\n        origen,\n        destino,\n    )\n\n\ndef test_mover_oc_bienes_registra_error_si_no_se_mueve(tmp_path, monkeypatch):\n    origen = tmp_path / "descargas"\n    destino = tmp_path / "destino"\n    origen.mkdir()\n    destino.mkdir()\n\n    pdf = origen / "123456.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    cfg = SimpleNamespace(\n        compra_bienes=True,\n        carpeta_destino_local=str(origen),\n        carpeta_analizar=str(destino),\n        abastecimiento_carpeta_descarga=str(origen),\n    )\n\n    monkeypatch.setattr(\n        mover_pdf, "extraer_numero_tarea_desde_pdf", lambda ruta: "140144463"\n    )\n    monkeypatch.setattr(\n        mover_pdf, "extraer_proveedor_desde_pdf", lambda ruta: "Proveedor X"\n    )\n\n    def failing_move(src, dst):\n        raise PermissionError("sin permisos")\n\n    monkeypatch.setattr(mover_pdf.shutil, "move", failing_move)\n    monkeypatch.setattr(mover_pdf.shutil, "copy2", failing_move)\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "123456", "proveedor": "Proveedor X"}]\n    )\n\n    assert subidos == []\n    assert faltantes == ["123456"]\n    assert any("OC 123456" in msg for msg in errores)\n    # el PDF debe permanecer en la carpeta de origen para reintentos\n    assert any(item.suffix.lower() == ".pdf" for item in origen.iterdir())\n\n\ndef test_mover_oc_bienes_copia_si_move_falla(tmp_path, monkeypatch):\n    cfg, origen, destino = _config(tmp_path)\n    carpeta_tarea = destino / "140144463"\n    carpeta_tarea.mkdir()\n\n    pdf = origen / "123456.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    monkeypatch.setattr(\n        mover_pdf, "extraer_numero_tarea_desde_pdf", lambda ruta: "140144463"\n    )\n    monkeypatch.setattr(\n        mover_pdf, "extraer_proveedor_desde_pdf", lambda ruta: "Proveedor X"\n    )\n\n    def failing_move(_src, _dst):\n        raise PermissionError("sin permisos")\n\n    monkeypatch.setattr(mover_pdf.shutil, "move", failing_move)\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "123456", "proveedor": "Proveedor X"}]\n    )\n\n    assert subidos == ["123456"]\n    assert faltantes == []\n    assert errores == []\n    archivos = list(carpeta_tarea.glob("*.pdf"))\n    assert len(archivos) == 1\n    assert archivos[0].name.startswith("ORDEN 123456")\n    assert not any(origen.glob("*.pdf"))\n\n\ndef test_mover_oc_reporta_error_si_no_puede_renombrar(tmp_path, monkeypatch):\n    cfg, origen, _destino = _config(tmp_path)\n\n    pdf = origen / "123456.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    monkeypatch.setattr(\n        mover_pdf, "extraer_proveedor_desde_pdf", lambda ruta: "Proveedor X"\n    )\n\n    def failing_rename(self, target):\n        raise PermissionError("bloqueado")\n\n    monkeypatch.setattr(mover_pdf.Path, "rename", failing_rename)\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "123456", "proveedor": "Proveedor X"}]\n    )\n\n    assert subidos == []\n    assert faltantes == ["123456"]\n    assert any("renombrar" in err for err in errores)\n    assert any(p.name == "123456.pdf" for p in origen.iterdir())\n\n\ndef test_mover_oc_bienes_mueve_a_carpeta_existente(tmp_path, monkeypatch):\n    cfg, origen, destino = _config(tmp_path)\n    carpeta_tarea = destino / "140144463 - carpeta"\n    carpeta_tarea.mkdir()\n\n    pdf = origen / "123456.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    monkeypatch.setattr(\n        mover_pdf, "extraer_numero_tarea_desde_pdf", lambda ruta: "140144463"\n    )\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "123456", "proveedor": "Proveedor X"}]\n    )\n\n    assert subidos == ["123456"]\n    assert faltantes == []\n    assert errores == []\n    archivos = list(carpeta_tarea.glob("*.pdf"))\n    assert len(archivos) == 1\n    assert "PROVEEDOR_X" in archivos[0].stem\n    assert "ORDEN 123456" in archivos[0].stem\n    assert not any(origen.glob("*.pdf"))\n\n\ndef test_mover_oc_bienes_resuelve_conflictos(tmp_path, monkeypatch):\n    cfg, origen, destino = _config(tmp_path)\n    monkeypatch.setattr(\n        mover_pdf, "extraer_numero_tarea_desde_pdf", lambda ruta: "140144463"\n    )\n\n    carpeta_tarea = destino / "140144463"\n    carpeta_tarea.mkdir()\n    conflicto = carpeta_tarea / "ORDEN 123456 - PROVEEDOR_X.PDF"\n    conflicto.write_text("existing")\n\n    pdf = origen / "123456.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "123456", "proveedor": "Proveedor X"}]\n    )\n\n    assert subidos == ["123456"]\n    assert faltantes == []\n    assert errores == []\n    archivos = sorted(carpeta_tarea.glob("*.pdf"))\n    assert len(archivos) == 2\n    nombres = [p.name for p in archivos]\n    assert any(name.endswith("(1).pdf") for name in nombres)\n\n\ndef test_mover_oc_no_bienes_identifica_numero_en_nombre(tmp_path):\n    cfg, origen, destino = _config(tmp_path, bienes=False)\n\n    pdf = origen / "ORDEN # 123456.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "123456", "proveedor": "Proveedor X"}]\n    )\n\n    assert subidos == ["123456"]\n    assert faltantes == []\n    assert errores == []\n    archivos = list(destino.glob("*.pdf"))\n    assert len(archivos) == 1\n    assert archivos[0].name == "ORDEN 123456 - PROVEEDOR_X.PDF"\n    assert not any(origen.glob("*.pdf"))\n\n\ndef test_mover_oc_no_bienes_renombra_en_origen_si_no_hay_destino(tmp_path):\n    cfg, origen, destino = _config(tmp_path, bienes=False)\n    cfg.carpeta_analizar = str(origen)\n\n    pdf = origen / "ORDEN # 654321.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "654321", "proveedor": "Proveedor Y"}]\n    )\n\n    assert subidos == ["654321"]\n    assert faltantes == []\n    assert errores == []\n    archivos = list(origen.glob("*.pdf"))\n    assert len(archivos) == 1\n    assert archivos[0].name == "ORDEN 654321 - PROVEEDOR_Y.PDF"\n\n\ndef test_mover_oc_no_bienes_registra_error_si_no_puede_mover(tmp_path, monkeypatch):\n    cfg, origen, destino = _config(tmp_path, bienes=False)\n\n    pdf = origen / "ORDEN # 999999.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    monkeypatch.setattr(\n        mover_pdf,\n        "_mover_archivo",\n        lambda ruta, dest, nombre: (None, "fallo de movimiento"),\n    )\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "999999", "proveedor": "Proveedor Z"}]\n    )\n\n    assert subidos == []\n    assert faltantes == ["999999"]\n    assert any("fallo de movimiento" in err for err in errores)\n    assert (origen / "ORDEN # 999999.pdf").exists()\n\n\ndef test_mover_oc_no_bienes_registra_error_si_no_puede_renombrar(tmp_path, monkeypatch):\n    cfg, origen, _destino = _config(tmp_path, bienes=False)\n    cfg.carpeta_analizar = str(origen)\n\n    pdf = origen / "ORDEN # 777777.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    def failing_rename(self, target):  # pragma: no cover - comportamiento forzado\n        raise PermissionError("bloqueado")\n\n    monkeypatch.setattr(mover_pdf.Path, "rename", failing_rename)\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "777777", "proveedor": "Proveedor W"}]\n    )\n\n    assert subidos == []\n    assert faltantes == ["777777"]\n    assert any("renombrar" in err for err in errores)\n    assert any(p.name == "ORDEN # 777777.pdf" for p in origen.iterdir())\n\n\ndef test_mover_oc_abastecimiento_permanecen_en_descarga(tmp_path):\n    origen_normal = tmp_path / "descargas_normales"\n    origen_abas = tmp_path / "descargas_abastecimiento"\n    destino_general = tmp_path / "destino_general"\n\n    origen_normal.mkdir()\n    origen_abas.mkdir()\n    destino_general.mkdir()\n\n    cfg = SimpleNamespace(\n        compra_bienes=False,\n        carpeta_destino_local=str(origen_normal),\n        carpeta_analizar=str(destino_general),\n        abastecimiento_carpeta_descarga=str(origen_abas),\n    )\n\n    pdf = origen_abas / "ORDEN # 555555.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    orden = {\n        "numero": "555555",\n        "proveedor": "Proveedor Uno",\n        "categoria": "abastecimiento",\n    }\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(cfg, [orden])\n\n    assert subidos == ["555555"]\n    assert faltantes == []\n    assert errores == []\n\n    archivos_abas = list(origen_abas.glob("*.pdf"))\n    assert len(archivos_abas) == 1\n    assert archivos_abas[0].name.startswith("ORDEN 555555 - PROVEEDOR_UNO")\n    # no se debe mover a la carpeta general\n    assert not list(destino_general.glob("*.pdf"))\ndef test_mover_oc_no_bienes_identifica_numero_en_nombre(tmp_path, monkeypatch):\n    cfg, origen, _destino = _config(tmp_path, bienes=False)\n\n    pdf = origen / "ORDEN # 123456.pdf"\n    pdf.write_bytes(b"%PDF-1.4")\n\n    monkeypatch.setattr(mover_pdf, "extraer_proveedor_desde_pdf", lambda ruta: None)\n\n    subidos, faltantes, errores = mover_pdf.mover_oc(\n        cfg, [{"numero": "123456", "proveedor": None}]\n    )\n\n    assert subidos == ["123456"]\n    assert faltantes == []\n    assert errores == []\n',
    'DescargasOC-main/tests/test_reporter.py': 'from types import SimpleNamespace\n\nimport smtplib\n\nfrom descargas_oc import reporter\n\n\nclass DummyPOP:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.user_called: str | None = None\n        self.pass_called: str | None = None\n        self.quit_called = False\n\n    def user(self, username):\n        self.user_called = username\n\n    def pass_(self, password):\n        self.pass_called = password\n\n    def quit(self):\n        self.quit_called = True\n\n\ndef _base_cfg(**overrides):\n    data = {\n        "correo_reporte": "dest@example.com",\n        "usuario": "popuser@telconet.ec",\n        "password": "pop-pass",\n        "pop_server": "pop.telconet.ec",\n        "pop_port": 995,\n        "smtp_usuario": "smtpuser@example.com",\n        "smtp_password": "smtp-pass",\n        "smtp_server": "smtp.telconet.ec",\n        "smtp_port": 587,\n        "smtp_ssl_port": 465,\n        "smtp_plain_port": 25,\n        "carpeta_analizar": None,\n    }\n    data.update(overrides)\n    return SimpleNamespace(**data)\n\n\ndef test_enviar_reporte_prefers_custom_smtp_credentials(monkeypatch):\n    pop_instance = DummyPOP("pop.telconet.ec", 995)\n    pop_calls: list[tuple[str, int]] = []\n\n    def fake_pop(host, port):\n        pop_calls.append((host, port))\n        return pop_instance\n\n    monkeypatch.setattr(reporter.poplib, "POP3_SSL", fake_pop)\n\n    init_calls: list[tuple[str, int]] = []\n    login_calls: list[tuple[str, str]] = []\n    sent_messages = []\n\n    class DummySMTP:\n        def __init__(self, host, port):\n            init_calls.append((host, port))\n\n        def __enter__(self):\n            return self\n\n        def __exit__(self, exc_type, exc_val, exc_tb):\n            return False\n\n        def ehlo(self):\n            return None\n\n        def starttls(self):\n            return None\n\n        def login(self, username, password):\n            login_calls.append((username, password))\n            if (username, password) != ("smtpuser@example.com", "smtp-pass"):\n                raise smtplib.SMTPAuthenticationError(535, b"bad credentials")\n\n        def send_message(self, message):\n            sent_messages.append(message)\n\n    monkeypatch.setattr(reporter.smtplib, "SMTP", DummySMTP)\n    monkeypatch.setattr(\n        reporter.smtplib,\n        "SMTP_SSL",\n        lambda *args, **kwargs: (_ for _ in ()).throw(AssertionError("Retroceso SSL no esperado")),\n    )\n\n    cfg = _base_cfg()\n\n    assert reporter.enviar_reporte(["123"], [], [{"numero": "123"}], cfg)\n    assert init_calls == [("smtp.telconet.ec", 587)]\n    assert login_calls == [("smtpuser@example.com", "smtp-pass")]\n    assert pop_calls == [("pop.telconet.ec", 995)]\n    assert pop_instance.user_called == "popuser@telconet.ec"\n    assert pop_instance.pass_called == "pop-pass"\n    assert pop_instance.quit_called is True\n    assert len(sent_messages) == 1\n\n\ndef test_enviar_reporte_retries_with_additional_usernames(monkeypatch):\n    pop_instance = DummyPOP("pop.telconet.ec", 995)\n    pop_calls: list[tuple[str, int]] = []\n\n    def fake_pop(host, port):\n        pop_calls.append((host, port))\n        return pop_instance\n\n    monkeypatch.setattr(reporter.poplib, "POP3_SSL", fake_pop)\n\n    init_calls: list[tuple[str, int]] = []\n    login_attempts: list[str] = []\n    sent_messages = []\n\n    class SequenceSMTP:\n        def __init__(self, host, port):\n            init_calls.append((host, port))\n\n        def __enter__(self):\n            return self\n\n        def __exit__(self, exc_type, exc_val, exc_tb):\n            return False\n\n        def ehlo(self):\n            return None\n\n        def starttls(self):\n            return None\n\n        def login(self, username, password):\n            login_attempts.append(username)\n            if username != "second@domain.test":\n                raise smtplib.SMTPAuthenticationError(535, b"bad")\n\n        def send_message(self, message):\n            sent_messages.append(message)\n\n    monkeypatch.setattr(reporter.smtplib, "SMTP", SequenceSMTP)\n    monkeypatch.setattr(\n        reporter.smtplib,\n        "SMTP_SSL",\n        lambda *args, **kwargs: (_ for _ in ()).throw(AssertionError("Retroceso SSL no esperado")),\n    )\n\n    cfg = _base_cfg(smtp_usuario="first", usuario="second@domain.test")\n\n    assert reporter.enviar_reporte(["123"], [], [{"numero": "123"}], cfg)\n    assert pop_calls == [("pop.telconet.ec", 995)]\n    assert init_calls == [("smtp.telconet.ec", 587), ("smtp.telconet.ec", 587)]\n    assert login_attempts == ["first", "second@domain.test"]\n    assert len(sent_messages) == 1\n\n\ndef test_enviar_reporte_abastecimiento_incluye_categoria(monkeypatch):\n    pop_instance = DummyPOP("pop.telconet.ec", 995)\n\n    def fake_pop(host, port):\n        assert (host, port) == ("pop.telconet.ec", 995)\n        return pop_instance\n\n    monkeypatch.setattr(reporter.poplib, "POP3_SSL", fake_pop)\n\n    init_calls: list[tuple[str, int]] = []\n    login_calls: list[tuple[str, str]] = []\n    sent_messages = []\n\n    class DummySMTP:\n        def __init__(self, host, port):\n            init_calls.append((host, port))\n\n        def __enter__(self):\n            return self\n\n        def __exit__(self, exc_type, exc_val, exc_tb):\n            return False\n\n        def ehlo(self):\n            return None\n\n        def starttls(self):\n            return None\n\n        def login(self, username, password):\n            login_calls.append((username, password))\n\n        def send_message(self, message):\n            sent_messages.append(message)\n\n    monkeypatch.setattr(reporter.smtplib, "SMTP", DummySMTP)\n    monkeypatch.setattr(\n        reporter.smtplib,\n        "SMTP_SSL",\n        lambda *args, **kwargs: (_ for _ in ()).throw(AssertionError("SSL fallback no esperado")),\n    )\n\n    cfg = _base_cfg()\n    ordenes = [\n        {"numero": "456", "proveedor": "Proveedor Uno", "categoria": "abastecimiento"}\n    ]\n\n    resultado = reporter.enviar_reporte(["456"], [], ordenes, cfg, categoria="abastecimiento")\n\n    assert resultado is True\n    assert init_calls == [("smtp.telconet.ec", 587)]\n    assert login_calls == [("smtpuser@example.com", "smtp-pass")]\n    assert pop_instance.quit_called is True\n    assert len(sent_messages) == 1\n\n    mensaje = sent_messages[0]\n    cuerpo_texto = mensaje.get_body(preferencelist=("plain",)).get_content()\n    cuerpo_html = mensaje.get_body(preferencelist=("html",)).get_content()\n\n    assert "Categoría: abastecimiento" in cuerpo_texto\n    assert "Categoría" in cuerpo_texto\n    assert "Proveedor Uno" in cuerpo_texto\n    assert "abastecimiento" in cuerpo_texto\n\n    assert "Categoría" in cuerpo_html\n    assert "Proveedor Uno" in cuerpo_html\n    assert "abastecimiento" in cuerpo_html\n',
    'DescargasOC-main/tests/test_ui_scan.py': 'import importlib\nimport sys\nimport types\n\nimport pytest\n\n\nclass DummyText:\n    def __init__(self):\n        self.messages = []\n\n    def insert(self, index, text):  # pragma: no cover - almacenamiento sencillo\n        self.messages.append(text)\n\n    def see(self, index):  # pragma: no cover - sin efecto en pruebas\n        pass\n\n    def after(self, delay, callback):\n        callback()\n\n\nclass DummyLabel:\n    def __init__(self):\n        self.text = ""\n\n    def config(self, **kwargs):\n        if "text" in kwargs:\n            self.text = kwargs["text"]\n\n\nclass DummyConfig:\n    def __init__(self):\n        self.usuario = "user@telconet.ec"\n        self.password = "secret"\n        self.carpeta_destino_local = "dest"\n        self.carpeta_analizar = "analizar"\n        self.seafile_url = "https://seafile"\n        self.seafile_repo_id = "repo"\n        self.correo_reporte = "report@telconet.ec"\n        self.headless = True\n\n    def validate(self):  # pragma: no cover - sin lógica de validación\n        return True\n\n\n@pytest.fixture\ndef ui_module(monkeypatch):\n    fake_pdf = types.ModuleType("PyPDF2")\n    fake_pdf.PdfReader = object\n    sys.modules["PyPDF2"] = fake_pdf\n    for mod in [\n        "descargas_oc.mover_pdf",\n        "descargas_oc.selenium_modulo",\n        "descargas_oc.ui",\n    ]:\n        sys.modules.pop(mod, None)\n    ui_mod = importlib.import_module("descargas_oc.ui")\n    yield ui_mod\n    sys.modules.pop("PyPDF2", None)\n\n\n@pytest.fixture(autouse=True)\ndef reset_lock(ui_module):\n    if ui_module.scanning_lock.locked():\n        ui_module.scanning_lock.release()\n    yield\n    if ui_module.scanning_lock.locked():\n        ui_module.scanning_lock.release()\n\n\ndef test_uidl_kept_pending_when_some_orders_fail(monkeypatch, ui_module):\n    monkeypatch.setattr(ui_module, "Config", DummyConfig)\n    monkeypatch.setattr(\n        ui_module,\n        "buscar_ocs",\n        lambda cfg: (\n            [\n                {"uidl": "UID1", "numero": "1001"},\n                {"uidl": "UID1", "numero": "1002"},\n                {"uidl": "UID2", "numero": "2001"},\n            ],\n            "UID_LAST",\n        ),\n    )\n    monkeypatch.setattr(\n        ui_module,\n        "descargar_oc",\n        lambda ordenes, headless: (["1001", "2001"], ["1002"], ["OC 1002: error"]),\n    )\n    monkeypatch.setattr(ui_module, "enviar_reporte", lambda *args, **kwargs: True)\n\n    calls = []\n\n    def fake_registrar(uidls, ultimo):\n        calls.append((uidls, ultimo))\n\n    monkeypatch.setattr(ui_module, "registrar_procesados", fake_registrar)\n    monkeypatch.setattr(ui_module, "cargar_ultimo_uidl", lambda: "PREV")\n    monkeypatch.setattr(ui_module.messagebox, "showerror", lambda *a, **k: None)\n    monkeypatch.setattr(ui_module.messagebox, "showinfo", lambda *a, **k: None)\n\n    text = DummyText()\n    label = DummyLabel()\n\n    ui_module.realizar_escaneo(text, label)\n\n    assert calls == [(["UID2"], None)]\n    assert "PREV" in label.text\n',
    'GestorCompras_/db/migrations/20240501_add_reasignaciones_servicios.sql': 'CREATE TABLE IF NOT EXISTS reasignaciones_servicios (\n  id INTEGER PRIMARY KEY,\n  message_id TEXT UNIQUE,\n  fecha DATETIME,\n  asunto TEXT,\n  task_number TEXT,\n  proveedor TEXT,\n  mecanico TEXT,\n  telefono TEXT,\n  inf_vehiculo TEXT,\n  correo_usuario TEXT,\n  raw_hash TEXT,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\nCREATE INDEX IF NOT EXISTS idx_rs_fecha ON reasignaciones_servicios(fecha);\nCREATE INDEX IF NOT EXISTS idx_rs_message ON reasignaciones_servicios(message_id);\nCREATE INDEX IF NOT EXISTS idx_rs_task ON reasignaciones_servicios(task_number);\n',
    'GestorCompras_/gestorcompras/core/__init__.py': '',
    'GestorCompras_/gestorcompras/core/config.py': '"""Manejo centralizado de configuración para la aplicación."""\nfrom __future__ import annotations\n\nfrom configparser import ConfigParser\nfrom pathlib import Path\nfrom threading import RLock\nfrom typing import Any\n\n_CONFIG_LOCK = RLock()\n_PARSER = ConfigParser()\n_LOADED = False\n\nCONFIG_PATH = (Path(__file__).resolve().parents[1] / "services" / "data" / "config.ini")\nCONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)\n\n_DEFAULTS = {\n    "auth": {\n        "correo_usuario": "",\n    },\n    "servicios": {\n        "cadena_asunto_fija": "NOTIFICACION A PROVEEDOR:",\n        "zona_horaria": "America/Guayaquil",\n        "remitente_correo": "",\n    },\n}\n\n\ndef _save_locked() -> None:\n    with CONFIG_PATH.open("w", encoding="utf-8") as fh:\n        _PARSER.write(fh)\n\n\ndef _ensure_loaded() -> None:\n    global _LOADED\n    if _LOADED:\n        return\n    with _CONFIG_LOCK:\n        if _LOADED:\n            return\n        if CONFIG_PATH.exists():\n            _PARSER.read(CONFIG_PATH, encoding="utf-8")\n        for section, options in _DEFAULTS.items():\n            if not _PARSER.has_section(section):\n                _PARSER.add_section(section)\n            for key, value in options.items():\n                if not _PARSER.has_option(section, key):\n                    _PARSER.set(section, key, value)\n        _save_locked()\n        _LOADED = True\n\n\ndef save() -> None:\n    """Persiste la configuración en disco."""\n    with _CONFIG_LOCK:\n        _save_locked()\n\n\ndef get(section: str, option: str, fallback: Any | None = None) -> Any:\n    _ensure_loaded()\n    if _PARSER.has_option(section, option):\n        return _PARSER.get(section, option)\n    return fallback\n\n\ndef set_value(section: str, option: str, value: Any) -> None:\n    _ensure_loaded()\n    with _CONFIG_LOCK:\n        if not _PARSER.has_section(section):\n            _PARSER.add_section(section)\n        _PARSER.set(section, option, str(value))\n        save()\n\n\ndef get_servicios_config() -> dict[str, str]:\n    _ensure_loaded()\n    section = "servicios"\n    keys = set(_DEFAULTS[section]) | {option for option in _PARSER.options(section)}\n    return {key: _PARSER.get(section, key) for key in keys}\n\n\ndef get_user_email() -> str:\n    return get("auth", "correo_usuario", fallback="")\n\n\ndef set_user_email(email: str) -> None:\n    set_value("auth", "correo_usuario", email)\n',
    'GestorCompras_/gestorcompras/core/mail_parse.py': '"""Utilidades para normalizar y extraer datos de los correos de Servicios."""\nfrom __future__ import annotations\n\nimport re\nimport unicodedata\n\nRX_TAREA_SUBJECT = re.compile(r\'TAREA:\\s*["“”]?(\\d{6,11})["“”]?\', re.I)\nRX_PROVEEDOR = re.compile(r\'Estimados\\s+(?:"([^"]+)"|([^\\n]+))\', re.I)\nRX_MECANICO = re.compile(\n    r\'coordinando\\s+el\\s+mantenimiento\\s+con\\s+"?([^"(]+?)"?\\s*\\(([^)]+)\\)\\s*"?\\.?\',\n    re.I,\n)\nRX_OT_LINE = re.compile(\n    r\'^(?:\\s*\\[[^\\]]+\\]\\s*)*(.*?OT[^\\n"]+)\',\n    re.I | re.M,\n)\nRX_USERMAIL = re.compile(r\'[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\', re.I)\n\n_MOJI = {\n    "Ã¡": "á",\n    "Ã©": "é",\n    "Ã\xad": "í",\n    "Ã³": "ó",\n    "Ãº": "ú",\n    "Ã±": "ñ",\n    "Ã‘": "Ñ",\n}\n\n\ndef _norm_quotes(s: str) -> str:\n    return s.replace("“", \'"\').replace("”", \'"\').replace("‘", "\'").replace("’", "\'")\n\n\ndef _fix_mojibake(s: str) -> str:\n    for bad, good in _MOJI.items():\n        s = s.replace(bad, good)\n    return s\n\n\ndef _norm(s: str | None) -> str:\n    if not s:\n        return ""\n    return unicodedata.normalize("NFC", _fix_mojibake(_norm_quotes(s)))\n\n\ndef _digits_only(s: str) -> str:\n    return "".join(ch for ch in s if ch.isdigit())\n\n\ndef parse_subject(subject: str | None) -> dict[str, str]:\n    s = _norm(subject)\n    match = RX_TAREA_SUBJECT.search(s)\n    task = match.group(1) if match else "N/D"\n    return {"task_number": task}\n\n\ndef parse_body(body_text: str | None, correo_usuario: str) -> dict[str, object]:\n    body = _norm(body_text)\n    proveedor = "N/D"\n    proveedor_match = RX_PROVEEDOR.search(body)\n    if proveedor_match:\n        proveedor = next((g for g in proveedor_match.groups() if g), "N/D").strip()\n\n    mecanico_nombre = "N/D"\n    mecanico_telefono = "N/D"\n    mecanico_match = RX_MECANICO.search(body)\n    if mecanico_match:\n        mecanico_nombre = mecanico_match.group(1).strip() or "N/D"\n        mecanico_telefono = _digits_only(mecanico_match.group(2)) or "N/D"\n\n    inf_vehiculo = "N/D"\n    ot_match = RX_OT_LINE.search(body)\n    if ot_match:\n        inf_vehiculo = ot_match.group(1).strip().strip(\'"\')\n\n    correo_usuario_encontrado = False\n    if correo_usuario:\n        correo_usuario_encontrado = correo_usuario.lower() in body.lower()\n    else:\n        correo_usuario_encontrado = bool(RX_USERMAIL.search(body))\n\n    return {\n        "proveedor": proveedor or "N/D",\n        "mecanico_nombre": mecanico_nombre or "N/D",\n        "mecanico_telefono": mecanico_telefono or "N/D",\n        "inf_vehiculo": inf_vehiculo or "N/D",\n        "correo_usuario_encontrado": correo_usuario_encontrado,\n    }\n\n\n__all__ = [\n    "parse_subject",\n    "parse_body",\n    "RX_TAREA_SUBJECT",\n    "RX_PROVEEDOR",\n    "RX_MECANICO",\n    "RX_OT_LINE",\n    "RX_USERMAIL",\n]\n',
    'GestorCompras_/gestorcompras/data/reasignaciones_repo.py': '"""Acceso a datos para la tabla de reasignaciones de servicios."""\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Dict\n\nfrom gestorcompras.services import db\n\n_TABLE = "reasignaciones_servicios"\n\n_COLUMNS = (\n    "message_id",\n    "fecha",\n    "asunto",\n    "task_number",\n    "proveedor",\n    "mecanico",\n    "telefono",\n    "inf_vehiculo",\n    "correo_usuario",\n    "raw_hash",\n)\n\n\ndef _normalize_record(record: Dict[str, Any]) -> Dict[str, Any]:\n    normalized = {key: record.get(key) for key in _COLUMNS}\n    fecha = record.get("fecha")\n    if isinstance(fecha, datetime):\n        normalized["fecha"] = fecha.isoformat()\n    return normalized\n\n\ndef upsert(record: Dict[str, Any]) -> Dict[str, Any]:\n    if not record.get("message_id") and not record.get("raw_hash"):\n        raise ValueError("Se requiere message_id o raw_hash para guardar la reasignación")\n\n    normalized = _normalize_record(record)\n    conn = db.get_connection()\n    cur = conn.cursor()\n\n    existing = None\n    if normalized.get("message_id"):\n        cur.execute(\n            f"SELECT id FROM {_TABLE} WHERE message_id=?",\n            (normalized["message_id"],),\n        )\n        existing = cur.fetchone()\n    if existing is None and normalized.get("raw_hash"):\n        cur.execute(\n            f"SELECT id FROM {_TABLE} WHERE raw_hash=?",\n            (normalized["raw_hash"],),\n        )\n        existing = cur.fetchone()\n\n    if existing:\n        set_clause = ", ".join(f"{col}=?" for col in _COLUMNS if col != "message_id")\n        values = [normalized[col] for col in _COLUMNS if col != "message_id"]\n        values.append(normalized.get("message_id"))\n        cur.execute(\n            f"UPDATE {_TABLE} SET {set_clause} WHERE message_id=?",\n            values,\n        )\n        record_id = existing[0]\n    else:\n        placeholders = ",".join("?" for _ in _COLUMNS)\n        cur.execute(\n            f"INSERT OR IGNORE INTO {_TABLE} ({\', \'.join(_COLUMNS)}) VALUES ({placeholders})",\n            [normalized[col] for col in _COLUMNS],\n        )\n        record_id = cur.lastrowid\n\n    conn.commit()\n    conn.close()\n    record_copy = dict(record)\n    record_copy["id"] = record_id\n    return record_copy\n\n\n__all__ = ["upsert"]\n',
    'GestorCompras_/gestorcompras/gui/config_gui.py': 'import tkinter as tk\nimport os\nimport tkinter.font as tkFont\nimport re\nimport threading\nimport poplib\nimport sys\nfrom pathlib import Path\nfrom tkinter import ttk, messagebox, simpledialog, filedialog\nfrom html import escape\n\n# Claves compartidas con los módulos de reasignación\nSERVICIOS_DEPARTAMENTO_KEY = "SERVICIOS_DEPARTAMENTO"\nSERVICIOS_USUARIO_KEY = "SERVICIOS_USUARIO"\nSERVICIOS_MENSAJE_KEY = "SERVICIOS_REASIGNACION_MSG"\nSERVICIOS_REMITENTE_KEY = "SERVICIOS_REMITENTE"\n\n# Garantiza que el paquete descargas_oc esté disponible incluso cuando la\n# aplicación se ejecute desde el directorio GestorCompras_. Buscamos la carpeta\n# "DescargasOC-main" ascendiendo en el árbol de directorios para soportar\n# distribuciones donde ambos módulos viven como carpetas hermanas.\ndef _find_descargas_root() -> Path | None:\n    for parent in Path(__file__).resolve().parents:\n        candidate = parent / "DescargasOC-main"\n        if candidate.exists():\n            return candidate\n    return None\n\n\n_DESCARGAS_ROOT = _find_descargas_root()\nif _DESCARGAS_ROOT is not None:\n    _path = str(_DESCARGAS_ROOT)\n    if _path not in sys.path:\n        sys.path.insert(0, _path)\n\nfrom gestorcompras.services import db\nfrom gestorcompras.gui.html_editor import HtmlEditor\nfrom gestorcompras.services.email_sender import send_email_custom\nfrom descargas_oc.config import Config as DescargasConfig\nfrom descargas_oc.escuchador import PROCESADOS_FILE\n\n\ndef _format_ruc(value: str | int) -> str:\n    """Devuelve el RUC como cadena preservando ceros a la izquierda."""\n    if isinstance(value, int):\n        value = str(value)\n    elif not isinstance(value, str):\n        value = str(value)\n    digits = value.strip()\n    if digits.isdigit():\n        if digits.startswith("0"):\n            return digits\n        if len(digits) == 12:\n            return digits.zfill(13)\n    return value\n\ndef center_window(win: tk.Tk | tk.Toplevel):\n    win.update_idletasks()\n    w = win.winfo_width()\n    h = win.winfo_height()\n    x = (win.winfo_screenwidth() // 2) - (w // 2)\n    y = (win.winfo_screenheight() // 2) - (h // 2)\n    win.geometry(f"{w}x{h}+{x}+{y}")\n\nclass ConfigGUI(tk.Toplevel):\n    def __init__(self, master=None, email_session=None):\n        super().__init__(master)\n        # Ensure the database has all required tables even if this\n        # window is launched directly without going through main()\n        db.init_db()\n        self.title("Configuración")\n        self.geometry("1100x760")\n        self.email_session = email_session\n        self.descargas_cfg = DescargasConfig()\n        self._oc_entries: dict[str, tk.Widget] = {}\n        self._oc_vars: dict[str, tk.Variable] = {}\n        self._procesados_status = tk.StringVar(value="Generado" if PROCESADOS_FILE.exists() else "Pendiente")\n        self._procesados_button: ttk.Button | None = None\n        self._abastecimiento_focus: tk.Widget | None = None\n        self._oc_focus: tk.Widget | None = None\n        self._oc_canvas: tk.Canvas | None = None\n        self._oc_scrollable: tk.Widget | None = None\n        self.create_widgets()\n        center_window(self)\n\n    def create_widgets(self):\n        self.notebook = ttk.Notebook(self, style="MyNotebook.TNotebook")\n        self.notebook.pack(fill="both", expand=True, padx=10, pady=10)\n\n        self.suppliers_frame = ttk.Frame(self.notebook, style="MyFrame.TFrame", padding=10)\n        self.assign_frame = ttk.Frame(self.notebook, style="MyFrame.TFrame", padding=10)\n        self.tracking_frame = ttk.Frame(self.notebook, style="MyFrame.TFrame", padding=10)\n        self.dispatch_frame = ttk.Frame(self.notebook, style="MyFrame.TFrame", padding=10)\n        self.oc_frame = ttk.Frame(self.notebook, style="MyFrame.TFrame", padding=10)\n        self.email_templates_frame = ttk.Frame(self.notebook, style="MyFrame.TFrame", padding=10)\n\n        self.notebook.add(self.suppliers_frame, text="Proveedores")\n        self.notebook.add(self.assign_frame, text="Asignación")\n        self.notebook.add(self.tracking_frame, text="Seguimientos")\n        self.notebook.add(self.dispatch_frame, text="Despacho")\n        self.notebook.add(self.oc_frame, text="Descargas OC")\n        self.notebook.add(self.email_templates_frame, text="Formatos de Correo")\n\n        self.create_suppliers_tab()\n        self.create_assignment_tab()\n        self.create_tracking_tab()\n        self.create_dispatch_tab()\n        self.create_oc_tab()\n        self.create_email_templates_tab()\n    \n    def create_suppliers_tab(self):\n        search_frame = ttk.Frame(self.suppliers_frame, style="MyFrame.TFrame")\n        search_frame.pack(fill="x", pady=(0,5))\n        ttk.Label(search_frame, text="Buscar:", style="MyLabel.TLabel").pack(side="left")\n        self.search_var = tk.StringVar()\n        search_entry = ttk.Entry(search_frame, textvariable=self.search_var, style="MyEntry.TEntry")\n        search_entry.pack(side="left", fill="x", expand=True, padx=5)\n        self.search_var.trace_add("write", lambda *args: self.filter_suppliers())\n        ttk.Button(search_frame, text="Limpiar", style="MyButton.TButton", command=lambda: self.search_var.set(""))\\\n            .pack(side="left", padx=5)\n\n        # Contenedor para el Treeview y sus scrollbars\n        container = ttk.Frame(self.suppliers_frame, style="MyFrame.TFrame")\n        container.pack(fill="both", expand=True)\n        \n        # Creamos el Treeview\n        self.suppliers_list = ttk.Treeview(\n            container,\n            style="MyTreeview.Treeview",\n            columns=("ID", "Nombre", "RUC", "Correo", "Correo2"),\n            show="headings",\n        )\n        for col in ("ID", "Nombre", "RUC", "Correo", "Correo2"):\n            self.suppliers_list.heading(col, text=col)\n        \n        # Creamos las scrollbars vertical y horizontal\n        v_scrollbar = ttk.Scrollbar(container, orient="vertical", command=self.suppliers_list.yview)\n        h_scrollbar = ttk.Scrollbar(container, orient="horizontal", command=self.suppliers_list.xview)\n        \n        self.suppliers_list.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)\n        \n        # Ubicamos el Treeview y las scrollbars en la grilla\n        self.suppliers_list.grid(row=0, column=0, sticky="nsew")\n        v_scrollbar.grid(row=0, column=1, sticky="ns")\n        h_scrollbar.grid(row=1, column=0, sticky="ew")\n        \n        # Configuramos el contenedor para que se expanda\n        container.grid_rowconfigure(0, weight=1)\n        container.grid_columnconfigure(0, weight=1)\n        \n        self.load_suppliers()\n        \n        btn_frame = ttk.Frame(self.suppliers_frame, style="MyFrame.TFrame", padding=5)\n        btn_frame.pack(fill="x", pady=5)\n        \n        ttk.Button(btn_frame, text="Agregar",\n                   style="MyButton.TButton",\n                   command=self.add_supplier).pack(side="left", padx=5)\n        ttk.Button(btn_frame, text="Editar",\n                   style="MyButton.TButton",\n                   command=self.edit_supplier).pack(side="left", padx=5)\n        ttk.Button(btn_frame, text="Eliminar",\n                   style="MyButton.TButton",\n                   command=self.delete_supplier).pack(side="left", padx=5)\n    \n    def load_suppliers(self):\n        term = getattr(self, "search_var", None)\n        if term and term.get().strip():\n            suppliers = db.search_suppliers(term.get().strip())\n        else:\n            suppliers = db.get_suppliers()\n        self.suppliers_list.delete(*self.suppliers_list.get_children())\n        for sup in suppliers:\n            values = list(sup)\n            if len(values) > 2:\n                values[2] = _format_ruc(values[2])\n            self.suppliers_list.insert("", "end", values=values)\n        self.auto_adjust_columns()\n\n    def filter_suppliers(self):\n        self.load_suppliers()\n    \n    def auto_adjust_columns(self):\n        style = ttk.Style()\n        font_str = style.lookup("MyTreeview.Treeview", "font")\n        if not font_str:\n            font_str = "TkDefaultFont"\n        font = tkFont.Font(font=font_str)\n        for col in self.suppliers_list["columns"]:\n            header_text = self.suppliers_list.heading(col, option="text")\n            max_width = font.measure(header_text)\n            for item in self.suppliers_list.get_children():\n                cell_text = str(self.suppliers_list.set(item, col))\n                cell_width = font.measure(cell_text)\n                if cell_width > max_width:\n                    max_width = cell_width\n            self.suppliers_list.column(col, width=max_width + 20)\n    \n    def add_supplier(self):\n        SupplierForm(self, "Agregar Proveedor", self.load_suppliers)\n    \n    def edit_supplier(self):\n        selected = self.suppliers_list.selection()\n        if not selected:\n            messagebox.showwarning("Advertencia", "Seleccione un proveedor para editar.")\n            return\n        data = self.suppliers_list.item(selected[0])["values"]\n        supplier_id = data[0]\n        try:\n            supplier_id_int = int(supplier_id)\n        except (TypeError, ValueError):\n            supplier_id_int = supplier_id\n        supplier_data = db.get_supplier(supplier_id_int)\n        if not supplier_data:\n            messagebox.showerror("Error", "No se pudo cargar el proveedor seleccionado.")\n            return\n        supplier_values = list(supplier_data)\n        if len(supplier_values) > 2:\n            supplier_values[2] = _format_ruc(supplier_values[2])\n        SupplierForm(self, "Editar Proveedor", self.load_suppliers, supplier_values)\n    \n    def delete_supplier(self):\n        selected = self.suppliers_list.selection()\n        if not selected:\n            messagebox.showwarning("Advertencia", "Seleccione un proveedor para eliminar.")\n            return\n        supplier_id = self.suppliers_list.item(selected[0])["values"][0]\n        db.delete_supplier(supplier_id)\n        self.load_suppliers()\n        messagebox.showinfo("Información", "Proveedor eliminado.")\n    \n    def create_assignment_tab(self):\n        self.assign_list = ttk.Treeview(\n            self.assign_frame,\n            columns=("Subdepto", "Departamento", "Persona"),\n            show="headings",\n            style="MyTreeview.Treeview",\n            height=10,\n        )\n        for col in ("Subdepto", "Departamento", "Persona"):\n            self.assign_list.heading(col, text=col)\n        self.assign_list.pack(fill="both", expand=True, pady=5)\n\n        btn_frame = ttk.Frame(self.assign_frame, style="MyFrame.TFrame", padding=5)\n        btn_frame.pack(pady=5)\n        ttk.Button(btn_frame, text="Agregar", style="MyButton.TButton",\n                   command=self.add_assignment).pack(side="left", padx=5)\n        ttk.Button(btn_frame, text="Editar", style="MyButton.TButton",\n                   command=self.edit_assignment).pack(side="left", padx=5)\n        ttk.Button(btn_frame, text="Eliminar", style="MyButton.TButton",\n                   command=self.delete_assignment).pack(side="left", padx=5)\n\n        servicios_frame = ttk.LabelFrame(\n            self.assign_frame,\n            text="Parámetros Servicios",\n            style="MyLabelFrame.TLabelframe",\n            padding=10,\n        )\n        servicios_frame.pack(fill="x", pady=(10, 0))\n        servicios_frame.columnconfigure(1, weight=1)\n        servicios_frame.columnconfigure(3, weight=1)\n\n        ttk.Label(servicios_frame, text="Departamento Telcos:", style="MyLabel.TLabel").grid(\n            row=0, column=0, sticky="w"\n        )\n        self.servicios_dept_var = tk.StringVar(value=db.get_config(SERVICIOS_DEPARTAMENTO_KEY, ""))\n        ttk.Entry(servicios_frame, textvariable=self.servicios_dept_var, style="MyEntry.TEntry").grid(\n            row=0, column=1, padx=5, sticky="ew"\n        )\n\n        ttk.Label(servicios_frame, text="Usuario Telcos:", style="MyLabel.TLabel").grid(\n            row=0, column=2, sticky="w"\n        )\n        self.servicios_usuario_var = tk.StringVar(value=db.get_config(SERVICIOS_USUARIO_KEY, ""))\n        ttk.Entry(servicios_frame, textvariable=self.servicios_usuario_var, style="MyEntry.TEntry").grid(\n            row=0, column=3, padx=5, sticky="ew"\n        )\n\n        ttk.Label(servicios_frame, text="Correo remitente:", style="MyLabel.TLabel").grid(\n            row=1, column=0, sticky="w", pady=(8, 0)\n        )\n        self.servicios_remitente_var = tk.StringVar(\n            value=db.get_config(SERVICIOS_REMITENTE_KEY, "")\n        )\n        ttk.Entry(\n            servicios_frame,\n            textvariable=self.servicios_remitente_var,\n            style="MyEntry.TEntry",\n        ).grid(row=1, column=1, columnspan=3, sticky="ew", padx=5, pady=(8, 0))\n\n        ttk.Label(servicios_frame, text="Mensaje de reasignación:", style="MyLabel.TLabel").grid(\n            row=2, column=0, sticky="w", pady=(8, 0)\n        )\n        self.servicios_mensaje_var = tk.StringVar(\n            value=db.get_config(SERVICIOS_MENSAJE_KEY, \'Taller Asignado "{proveedor}"\')\n        )\n        ttk.Entry(\n            servicios_frame,\n            textvariable=self.servicios_mensaje_var,\n            style="MyEntry.TEntry",\n        ).grid(row=2, column=1, columnspan=3, sticky="ew", padx=5, pady=(8, 0))\n\n        ttk.Button(\n            servicios_frame,\n            text="Guardar parámetros de Servicios",\n            style="MyButton.TButton",\n            command=self.save_servicios_params,\n        ).grid(row=3, column=0, columnspan=4, sticky="e", pady=(12, 0))\n\n        self.load_assignments()\n\n    def load_assignments(self):\n        for i in self.assign_list.get_children():\n            self.assign_list.delete(i)\n        for sub, dept, person in db.get_assignments():\n            self.assign_list.insert("", "end", values=(sub, dept, person))\n\n    def add_assignment(self):\n        AssignmentForm(self, "Nueva Asignación", self.load_assignments).wait_window()\n\n    def edit_assignment(self):\n        sel = self.assign_list.selection()\n        if not sel:\n            messagebox.showwarning("Advertencia", "Seleccione un registro a editar.")\n            return\n        values = self.assign_list.item(sel[0])["values"]\n        AssignmentForm(self, "Editar Asignación", self.load_assignments, tuple(values)).wait_window()\n\n    def delete_assignment(self):\n        sel = self.assign_list.selection()\n        if not sel:\n            messagebox.showwarning("Advertencia", "Seleccione un registro a eliminar.")\n            return\n        sub = self.assign_list.item(sel[0])["values"][0]\n        if messagebox.askyesno("Confirmar", "¿Eliminar la asignación seleccionada?"):\n            db.delete_assignment(sub)\n            self.load_assignments()\n\n    def save_servicios_params(self):\n        dept = self.servicios_dept_var.get().strip()\n        usuario = self.servicios_usuario_var.get().strip()\n        remitente = self.servicios_remitente_var.get().strip()\n        mensaje = self.servicios_mensaje_var.get().strip()\n        if not dept or not usuario:\n            messagebox.showwarning(\n                "Advertencia",\n                "Debe definir el departamento y el usuario de reasignación para Servicios.",\n            )\n            return\n        db.set_config(SERVICIOS_DEPARTAMENTO_KEY, dept)\n        db.set_config(SERVICIOS_USUARIO_KEY, usuario)\n        db.set_config(SERVICIOS_REMITENTE_KEY, remitente)\n        db.set_config(SERVICIOS_MENSAJE_KEY, mensaje or \'Taller Asignado "{proveedor}"\')\n        messagebox.showinfo("Configuración", "Parámetros de Servicios actualizados correctamente.")\n\n    def create_tracking_tab(self):\n        frame = self.tracking_frame\n\n        ttk.Label(frame, text="Configuración Seguimientos",\n                  style="MyLabel.TLabel").pack(pady=10)\n\n        ttk.Label(frame, text="Credenciales Google (JSON):",\n                  style="MyLabel.TLabel").pack(pady=5)\n\n        self.google_creds_var = tk.StringVar()\n        self.google_creds_var.set(db.get_config("GOOGLE_CREDS", ""))\n\n        ttk.Entry(frame, textvariable=self.google_creds_var,\n                  style="MyEntry.TEntry", width=50).pack(pady=5)\n\n        ttk.Button(frame, text="Seleccionar Credenciales",\n                   style="MyButton.TButton",\n                   command=self.select_google_creds).pack(pady=5)\n\n        ttk.Label(frame, text="ID de Spreadsheet:",\n                  style="MyLabel.TLabel").pack(pady=5)\n\n        self.sheet_id_var = tk.StringVar()\n        self.sheet_id_var.set(db.get_config("GOOGLE_SHEET_ID", ""))\n\n        ttk.Entry(frame, textvariable=self.sheet_id_var,\n                  style="MyEntry.TEntry", width=50).pack(pady=5)\n\n        ttk.Label(frame, text="Nombre de la Hoja:",\n                  style="MyLabel.TLabel").pack(pady=5)\n\n        self.sheet_name_var = tk.StringVar()\n        self.sheet_name_var.set(db.get_config("GOOGLE_SHEET_NAME", ""))\n\n        ttk.Entry(frame, textvariable=self.sheet_name_var,\n                  style="MyEntry.TEntry", width=50).pack(pady=5)\n\n        ttk.Label(frame, text="Correos CC Seguimiento (hasta 9, separados por \';\'):",\n                  style="MyLabel.TLabel").pack(pady=5)\n\n        self.cc_tracking_var = tk.StringVar()\n        self.cc_tracking_var.set(db.get_config("EMAIL_CC_SEGUIMIENTO", ""))\n\n        ttk.Entry(frame, textvariable=self.cc_tracking_var,\n                  style="MyEntry.TEntry", width=50).pack(pady=5)\n\n        ttk.Button(frame, text="Guardar Configuración",\n                   style="MyButton.TButton",\n                   command=self.save_tracking_config).pack(pady=10)\n\n    def create_dispatch_tab(self):\n        frame = self.dispatch_frame\n\n        ttk.Label(frame, text="Configuración Despacho",\n                  style="MyLabel.TLabel").pack(pady=10)\n\n        ttk.Label(frame, text="Ruta de la carpeta para PDFs:",\n                  style="MyLabel.TLabel").pack(pady=5)\n\n        self.pdf_path_var = tk.StringVar()\n        self.pdf_path_var.set(db.get_config("PDF_FOLDER", os.path.join(os.path.dirname(__file__), "pdfs")))\n\n        self.pdf_entry = ttk.Entry(frame, textvariable=self.pdf_path_var,\n                                   style="MyEntry.TEntry", width=50)\n        self.pdf_entry.pack(pady=5)\n\n        ttk.Button(frame, text="Seleccionar Carpeta",\n                   style="MyButton.TButton",\n                   command=self.select_pdf_folder).pack(pady=5)\n\n        ttk.Label(frame, text="Correos CC Despachos (hasta 9, separados por \';\'):",\n                  style="MyLabel.TLabel").pack(pady=5)\n\n        self.cc_dispatch_var = tk.StringVar()\n        self.cc_dispatch_var.set(db.get_config("EMAIL_CC_DESPACHO", ""))\n\n        ttk.Entry(frame, textvariable=self.cc_dispatch_var,\n                  style="MyEntry.TEntry", width=50).pack(pady=5)\n\n        ttk.Button(frame, text="Guardar Configuración",\n                   style="MyButton.TButton",\n                   command=self.save_dispatch_config).pack(pady=10)\n    \n    def select_pdf_folder(self):\n        folder_selected = filedialog.askdirectory(title="Seleccionar carpeta para PDFs")\n        if folder_selected:\n            self.pdf_path_var.set(folder_selected)\n\n    def select_google_creds(self):\n        path = filedialog.askopenfilename(title="Seleccionar archivo de credenciales", filetypes=[("JSON", "*.json")])\n        if path:\n            self.google_creds_var.set(path)\n    \n    def save_tracking_config(self):\n        cc_text = self.cc_tracking_var.get().strip()\n        emails = [e.strip() for e in re.split(r"[;,]+", cc_text) if e.strip()]\n        if len(emails) > 9:\n            messagebox.showwarning(\n                "Advertencia", "Se permiten máximo 9 correos en CC.")\n            return\n\n        db.set_config("GOOGLE_CREDS", self.google_creds_var.get().strip())\n        db.set_config("GOOGLE_SHEET_ID", self.sheet_id_var.get().strip())\n        db.set_config("GOOGLE_SHEET_NAME", self.sheet_name_var.get().strip())\n        db.set_config("EMAIL_CC_SEGUIMIENTO", ";".join(emails) if emails else "")\n        messagebox.showinfo(\n            "Información", "Configuración guardada correctamente.")\n\n    def save_dispatch_config(self):\n        pdf_folder = self.pdf_path_var.get().strip()\n        if not pdf_folder:\n            messagebox.showwarning(\n                "Advertencia", "La ruta de la carpeta no puede estar vacía.")\n            return\n\n        cc_text = self.cc_dispatch_var.get().strip()\n        emails = [e.strip() for e in re.split(r"[;,]+", cc_text) if e.strip()]\n        if len(emails) > 9:\n            messagebox.showwarning(\n                "Advertencia", "Se permiten máximo 9 correos en CC.")\n            return\n\n        db.set_config("PDF_FOLDER", pdf_folder)\n        db.set_config("EMAIL_CC_DESPACHO", ";".join(emails) if emails else "")\n        messagebox.showinfo(\n            "Información", "Configuración guardada correctamente.")\n\n    def create_oc_tab(self):\n        cfg = self.descargas_cfg\n\n        canvas = tk.Canvas(self.oc_frame, highlightthickness=0, borderwidth=0)\n        scrollbar = ttk.Scrollbar(self.oc_frame, orient="vertical", command=canvas.yview)\n        canvas.configure(yscrollcommand=scrollbar.set)\n        canvas.pack(side="left", fill="both", expand=True)\n        scrollbar.pack(side="right", fill="y")\n\n        scrollable = ttk.Frame(canvas, style="MyFrame.TFrame", padding=10)\n        window_id = canvas.create_window((0, 0), window=scrollable, anchor="nw")\n\n        def _update_scrollregion(_event):\n            canvas.configure(scrollregion=canvas.bbox("all"))\n\n        def _resize_inner(event):\n            canvas.itemconfigure(window_id, width=event.width)\n\n        scrollable.bind("<Configure>", _update_scrollregion)\n        canvas.bind("<Configure>", _resize_inner)\n\n        self._oc_canvas = canvas\n        self._oc_scrollable = scrollable\n\n        def _str_var(key: str, value: str) -> tk.StringVar:\n            var = tk.StringVar(value=value)\n            self._oc_vars[key] = var\n            return var\n\n        def _bool_var(key: str, value: bool) -> tk.BooleanVar:\n            var = tk.BooleanVar(value=value)\n            self._oc_vars[key] = var\n            return var\n\n        remitente_cfg = cfg.data.get("remitente_adicional", "")\n        if isinstance(remitente_cfg, (list, tuple, set)):\n            remitente_txt = ", ".join(str(r).strip() for r in remitente_cfg if str(r).strip())\n        else:\n            remitente_txt = str(remitente_cfg or "")\n\n        general_frame = ttk.LabelFrame(\n            scrollable,\n            text="Descargas OC (Normal)",\n            style="MyLabelFrame.TLabelframe",\n            padding=10,\n        )\n        general_frame.pack(fill="x", expand=False, pady=(0, 10))\n        general_frame.columnconfigure(1, weight=1)\n\n        row = 0\n        ttk.Label(general_frame, text="Servidor POP3:", style="MyLabel.TLabel").grid(\n            row=row, column=0, sticky="w", padx=5, pady=2\n        )\n        pop_entry = ttk.Entry(\n            general_frame,\n            textvariable=_str_var("pop_server", cfg.pop_server or ""),\n            style="MyEntry.TEntry",\n        )\n        pop_entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["pop_server"] = pop_entry\n        self._oc_focus = pop_entry\n\n        row += 1\n        ttk.Label(general_frame, text="Puerto POP3:", style="MyLabel.TLabel").grid(\n            row=row, column=0, sticky="w", padx=5, pady=2\n        )\n        ttk.Entry(\n            general_frame,\n            textvariable=_str_var("pop_port", str(cfg.pop_port or 995)),\n            width=10,\n            style="MyEntry.TEntry",\n        ).grid(row=row, column=1, sticky="w", padx=5, pady=2)\n\n        row += 1\n        ttk.Label(general_frame, text="Usuario:", style="MyLabel.TLabel").grid(\n            row=row, column=0, sticky="w", padx=5, pady=2\n        )\n        user_entry = ttk.Entry(\n            general_frame,\n            textvariable=_str_var("usuario", cfg.usuario or ""),\n            style="MyEntry.TEntry",\n        )\n        user_entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["usuario"] = user_entry\n\n        row += 1\n        ttk.Label(general_frame, text="Contraseña:", style="MyLabel.TLabel").grid(\n            row=row, column=0, sticky="w", padx=5, pady=2\n        )\n        pwd_entry = ttk.Entry(\n            general_frame,\n            textvariable=_str_var("password", cfg.password or ""),\n            show="*",\n            style="MyEntry.TEntry",\n        )\n        pwd_entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["password"] = pwd_entry\n\n        row += 1\n        ttk.Label(\n            general_frame,\n            text="Carpeta de descarga principal:",\n            style="MyLabel.TLabel",\n        ).grid(row=row, column=0, sticky="w", padx=5, pady=2)\n        dest_frame = ttk.Frame(general_frame, style="MyFrame.TFrame")\n        dest_frame.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        dest_entry = ttk.Entry(\n            dest_frame,\n            textvariable=_str_var(\n                "carpeta_destino_local", cfg.carpeta_destino_local or ""\n            ),\n            style="MyEntry.TEntry",\n        )\n        dest_entry.pack(side="left", fill="x", expand=True)\n        ttk.Button(\n            dest_frame,\n            text="Seleccionar",\n            style="MyButton.TButton",\n            command=lambda: self._browse_directory(self._oc_vars["carpeta_destino_local"]),\n        ).pack(side="left", padx=(5, 0))\n        self._oc_entries["carpeta_destino_local"] = dest_entry\n\n        row += 1\n        ttk.Label(\n            general_frame,\n            text="Carpeta de tareas Bienes:",\n            style="MyLabel.TLabel",\n        ).grid(row=row, column=0, sticky="w", padx=5, pady=2)\n        analizar_frame = ttk.Frame(general_frame, style="MyFrame.TFrame")\n        analizar_frame.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        analizar_entry = ttk.Entry(\n            analizar_frame,\n            textvariable=_str_var("carpeta_analizar", cfg.carpeta_analizar or ""),\n            style="MyEntry.TEntry",\n        )\n        analizar_entry.pack(side="left", fill="x", expand=True)\n        ttk.Button(\n            analizar_frame,\n            text="Seleccionar",\n            style="MyButton.TButton",\n            command=lambda: self._browse_directory(self._oc_vars["carpeta_analizar"]),\n        ).pack(side="left", padx=(5, 0))\n        self._oc_entries["carpeta_analizar"] = analizar_entry\n\n        row += 1\n        ttk.Label(general_frame, text="URL Telcodrive:", style="MyLabel.TLabel").grid(\n            row=row, column=0, sticky="w", padx=5, pady=2\n        )\n        url_entry = ttk.Entry(\n            general_frame,\n            textvariable=_str_var("seafile_url", cfg.seafile_url or ""),\n            style="MyEntry.TEntry",\n        )\n        url_entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["seafile_url"] = url_entry\n\n        row += 1\n        ttk.Label(general_frame, text="ID de carpeta principal:", style="MyLabel.TLabel").grid(\n            row=row, column=0, sticky="w", padx=5, pady=2\n        )\n        repo_entry = ttk.Entry(\n            general_frame,\n            textvariable=_str_var("seafile_repo_id", cfg.seafile_repo_id or ""),\n            style="MyEntry.TEntry",\n        )\n        repo_entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["seafile_repo_id"] = repo_entry\n\n        row += 1\n        ttk.Label(\n            general_frame,\n            text="Carpeta personal Telcodrive:",\n            style="MyLabel.TLabel",\n        ).grid(row=row, column=0, sticky="w", padx=5, pady=2)\n        sub_entry = ttk.Entry(\n            general_frame,\n            textvariable=_str_var("seafile_subfolder", cfg.seafile_subfolder or "/"),\n            style="MyEntry.TEntry",\n        )\n        sub_entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["seafile_subfolder"] = sub_entry\n\n        row += 1\n        ttk.Label(general_frame, text="Correo para reporte:", style="MyLabel.TLabel").grid(\n            row=row, column=0, sticky="w", padx=5, pady=2\n        )\n        correo_entry = ttk.Entry(\n            general_frame,\n            textvariable=_str_var("correo_reporte", cfg.correo_reporte or ""),\n            style="MyEntry.TEntry",\n        )\n        correo_entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["correo_reporte"] = correo_entry\n\n        row += 1\n        ttk.Label(\n            general_frame,\n            text="Remitentes adicionales (separar con coma):",\n            style="MyLabel.TLabel",\n        ).grid(row=row, column=0, sticky="w", padx=5, pady=2)\n        remitente_entry = ttk.Entry(\n            general_frame,\n            textvariable=_str_var("remitente_adicional", remitente_txt),\n            style="MyEntry.TEntry",\n        )\n        remitente_entry.grid(row=row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["remitente_adicional"] = remitente_entry\n\n        row += 1\n        headless_check = ttk.Checkbutton(\n            general_frame,\n            text="Ejecutar Chrome en modo oculto (headless)",\n            style="MyCheckbutton.TCheckbutton",\n            variable=_bool_var("headless", bool(cfg.headless)),\n        )\n        headless_check.grid(row=row, column=0, columnspan=2, sticky="w", padx=5, pady=4)\n        self._oc_entries["headless"] = headless_check\n\n        abas_frame = ttk.LabelFrame(\n            scrollable,\n            text="Abastecimiento",\n            style="MyLabelFrame.TLabelframe",\n            padding=10,\n        )\n        abas_frame.pack(fill="x", expand=False, pady=(0, 10))\n        abas_frame.columnconfigure(1, weight=1)\n\n        abas_row = 0\n        ttk.Label(abas_frame, text="Carpeta de descarga:", style="MyLabel.TLabel").grid(\n            row=abas_row, column=0, sticky="w", padx=5, pady=2\n        )\n        abas_dest_frame = ttk.Frame(abas_frame, style="MyFrame.TFrame")\n        abas_dest_frame.grid(row=abas_row, column=1, sticky="ew", padx=5, pady=2)\n        abas_dest_entry = ttk.Entry(\n            abas_dest_frame,\n            textvariable=_str_var(\n                "abastecimiento_carpeta_descarga",\n                cfg.abastecimiento_carpeta_descarga or cfg.carpeta_destino_local or "",\n            ),\n            style="MyEntry.TEntry",\n        )\n        abas_dest_entry.pack(side="left", fill="x", expand=True)\n        ttk.Button(\n            abas_dest_frame,\n            text="Seleccionar",\n            style="MyButton.TButton",\n            command=lambda: self._browse_directory(self._oc_vars["abastecimiento_carpeta_descarga"]),\n        ).pack(side="left", padx=(5, 0))\n        self._oc_entries["abastecimiento_carpeta_descarga"] = abas_dest_entry\n        self._abastecimiento_focus = abas_dest_entry\n\n        abas_row += 1\n        ttk.Label(abas_frame, text="Correo para reporte:", style="MyLabel.TLabel").grid(\n            row=abas_row, column=0, sticky="w", padx=5, pady=2\n        )\n        abas_correo_entry = ttk.Entry(\n            abas_frame,\n            textvariable=_str_var(\n                "abastecimiento_correo_reporte",\n                cfg.abastecimiento_correo_reporte or cfg.correo_reporte or "",\n            ),\n            style="MyEntry.TEntry",\n        )\n        abas_correo_entry.grid(row=abas_row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["abastecimiento_correo_reporte"] = abas_correo_entry\n\n        abas_row += 1\n        solicitantes_txt = ", ".join(cfg.abastecimiento_solicitantes or [])\n        ttk.Label(\n            abas_frame,\n            text="Solicitantes (separa con coma o salto de línea):",\n            style="MyLabel.TLabel",\n        ).grid(row=abas_row, column=0, sticky="w", padx=5, pady=2)\n        abas_sol_entry = ttk.Entry(\n            abas_frame,\n            textvariable=_str_var("abastecimiento_solicitantes", solicitantes_txt),\n            style="MyEntry.TEntry",\n        )\n        abas_sol_entry.grid(row=abas_row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["abastecimiento_solicitantes"] = abas_sol_entry\n\n        abas_row += 1\n        autorizadores_txt = ", ".join(cfg.abastecimiento_autorizadores or [])\n        ttk.Label(\n            abas_frame,\n            text="Autorizadores (separa con coma o salto de línea):",\n            style="MyLabel.TLabel",\n        ).grid(row=abas_row, column=0, sticky="w", padx=5, pady=2)\n        abas_aut_entry = ttk.Entry(\n            abas_frame,\n            textvariable=_str_var("abastecimiento_autorizadores", autorizadores_txt),\n            style="MyEntry.TEntry",\n        )\n        abas_aut_entry.grid(row=abas_row, column=1, sticky="ew", padx=5, pady=2)\n        self._oc_entries["abastecimiento_autorizadores"] = abas_aut_entry\n\n        abas_row += 1\n        abas_headless_check = ttk.Checkbutton(\n            abas_frame,\n            text="Ejecutar Chrome en modo oculto (headless)",\n            style="MyCheckbutton.TCheckbutton",\n            variable=_bool_var(\n                "abastecimiento_headless", bool(cfg.abastecimiento_headless)\n            ),\n        )\n        abas_headless_check.grid(\n            row=abas_row, column=0, columnspan=2, sticky="w", padx=5, pady=4\n        )\n        self._oc_entries["abastecimiento_headless"] = abas_headless_check\n\n        button_frame = ttk.Frame(scrollable, style="MyFrame.TFrame")\n        button_frame.pack(fill="x", pady=(0, 10))\n\n        ttk.Button(\n            button_frame,\n            text="Guardar Configuración",\n            style="MyButton.TButton",\n            command=self.save_descargas_config,\n        ).pack(side="left", padx=5)\n\n        ttk.Button(\n            button_frame,\n            text="Probar subida a Telcodrive",\n            style="MyButton.TButton",\n            command=self.test_seafile_upload,\n        ).pack(side="left", padx=5)\n\n        self._procesados_button = ttk.Button(\n            button_frame,\n            text="Generar procesados",\n            style="MyButton.TButton",\n            command=self.generate_processed_file,\n        )\n        self._procesados_button.pack(side="left", padx=5)\n\n        ttk.Label(\n            button_frame,\n            textvariable=self._procesados_status,\n            style="MyLabel.TLabel",\n        ).pack(side="left", padx=5)\n\n    def create_email_templates_tab(self):\n        frame = self.email_templates_frame\n        ttk.Label(frame, text="Seleccione el Formato de Correo Actual:",\n                  style="MyLabel.TLabel").pack(pady=10)\n        self.email_template_var = tk.StringVar()\n        self.template_combo = ttk.Combobox(frame, textvariable=self.email_template_var,\n                                           state="readonly")\n        self.template_combo.pack(pady=5)\n        ttk.Button(frame, text="Guardar Formato",\n                   style="MyButton.TButton",\n                   command=self.save_email_template).pack(pady=10)\n\n        self.templates_list = ttk.Treeview(frame, style="MyTreeview.Treeview",\n                                           columns=("ID", "Nombre"), show="headings",\n                                           height=5)\n        self.templates_list.heading("ID", text="ID")\n        self.templates_list.heading("Nombre", text="Nombre")\n        self.templates_list.column("ID", width=50)\n        self.templates_list.pack(fill="x", pady=5)\n\n        btn_frame = ttk.Frame(frame, style="MyFrame.TFrame", padding=5)\n        btn_frame.pack(pady=5)\n        ttk.Button(btn_frame, text="Agregar",\n                   style="MyButton.TButton",\n                   command=self.agregar_nuevo_formato).pack(side="left", padx=5)\n        ttk.Button(btn_frame, text="Editar",\n                   style="MyButton.TButton",\n                   command=self.editar_formato).pack(side="left", padx=5)\n        ttk.Button(btn_frame, text="Eliminar",\n                   style="MyButton.TButton",\n                   command=self.eliminar_formato).pack(side="left", padx=5)\n\n        self.load_email_templates()\n    \n    def save_email_template(self):\n        formato = self.email_template_var.get().strip()\n        if not formato:\n            messagebox.showwarning("Advertencia", "Debe seleccionar un formato de correo.")\n            return\n        db.set_config("EMAIL_TEMPLATE", formato)\n        messagebox.showinfo("Información", "Formato de correo guardado correctamente.")\n\n    def load_email_templates(self):\n        for i in self.templates_list.get_children():\n            self.templates_list.delete(i)\n        templates = db.get_email_templates()\n        for tpl in templates:\n            self.templates_list.insert("", "end", values=(tpl[0], tpl[1]))\n\n        opciones = ["FORMATO"] + [tpl[1] for tpl in templates]\n        self.template_combo["values"] = opciones\n        current = db.get_config("EMAIL_TEMPLATE", "FORMATO")\n        if current in opciones:\n            self.email_template_var.set(current)\n        else:\n            self.email_template_var.set("FORMATO")\n\n    def agregar_nuevo_formato(self):\n        TemplateForm(self, "Nuevo Formato", self.load_email_templates, email_session=self.email_session).wait_window()\n\n    def editar_formato(self):\n        selected = self.templates_list.selection()\n        if not selected:\n            messagebox.showwarning("Advertencia", "Seleccione un formato para editar.")\n            return\n        tpl_id = self.templates_list.item(selected[0])["values"][0]\n        data = db.get_email_template(tpl_id)\n        TemplateForm(self, "Editar Formato", self.load_email_templates, data, email_session=self.email_session).wait_window()\n\n    def eliminar_formato(self):\n        selected = self.templates_list.selection()\n        if not selected:\n            messagebox.showwarning("Advertencia", "Seleccione un formato para eliminar.")\n            return\n        tpl_id = self.templates_list.item(selected[0])["values"][0]\n        if messagebox.askyesno("Confirmar", "¿Eliminar el formato seleccionado?"):\n            db.delete_email_template(tpl_id)\n            self.load_email_templates()\n\n    def _browse_directory(self, var: tk.StringVar):\n        initial = var.get().strip() or os.getcwd()\n        path = filedialog.askdirectory(initialdir=initial)\n        if path:\n            var.set(path)\n\n    @staticmethod\n    def _parse_list(value: str) -> list[str]:\n        if not value:\n            return []\n        partes = [p.strip() for p in re.split(r"[;\\n,]+", value) if p.strip()]\n        return partes\n\n    def _safe_int(self, key: str, default: int) -> int:\n        raw = self._oc_vars.get(key)\n        if raw is None:\n            return default\n        valor = raw.get()\n        try:\n            return int(str(valor).strip())\n        except (TypeError, ValueError):\n            return default\n\n    def _collect_descargas_form(self) -> dict:\n        cfg = self.descargas_cfg\n        data = {\n            "pop_server": self._oc_vars["pop_server"].get().strip(),\n            "pop_port": self._safe_int("pop_port", cfg.data.get("pop_port", 995)),\n            "usuario": self._oc_vars["usuario"].get().strip(),\n            "password": self._oc_vars["password"].get(),\n            "carpeta_destino_local": self._oc_vars["carpeta_destino_local"].get().strip(),\n            "carpeta_analizar": self._oc_vars["carpeta_analizar"].get().strip(),\n            "seafile_url": self._oc_vars["seafile_url"].get().strip(),\n            "seafile_repo_id": self._oc_vars["seafile_repo_id"].get().strip(),\n            "seafile_subfolder": self._oc_vars["seafile_subfolder"].get().strip() or "/",\n            "correo_reporte": self._oc_vars["correo_reporte"].get().strip(),\n            "headless": bool(self._oc_vars["headless"].get()),\n            "abastecimiento_carpeta_descarga": self._oc_vars[\n                "abastecimiento_carpeta_descarga"\n            ].get().strip(),\n            "abastecimiento_correo_reporte": self._oc_vars[\n                "abastecimiento_correo_reporte"\n            ].get().strip(),\n            "abastecimiento_headless": bool(\n                self._oc_vars["abastecimiento_headless"].get()\n            ),\n            "abastecimiento_solicitantes": self._parse_list(\n                self._oc_vars["abastecimiento_solicitantes"].get()\n            ),\n            "abastecimiento_autorizadores": self._parse_list(\n                self._oc_vars["abastecimiento_autorizadores"].get()\n            ),\n        }\n\n        remitentes_texto = self._oc_vars["remitente_adicional"].get().strip()\n        if remitentes_texto:\n            remitentes = self._parse_list(remitentes_texto)\n            data["remitente_adicional"] = ", ".join(remitentes) if remitentes else remitentes_texto\n        else:\n            data["remitente_adicional"] = ""\n        return data\n\n    def save_descargas_config(self):\n        datos = self._collect_descargas_form()\n        self.descargas_cfg.data.update(datos)\n        try:\n            self.descargas_cfg.validate()\n        except Exception as exc:\n            messagebox.showerror("Error", f"Configuración inválida: {exc}")\n            return\n        self.descargas_cfg.save()\n        self._procesados_status.set("Generado" if PROCESADOS_FILE.exists() else "Pendiente")\n        messagebox.showinfo("Información", "Configuración guardada correctamente.")\n\n    def test_seafile_upload(self):\n        datos = self._collect_descargas_form()\n        self.descargas_cfg.data.update(datos)\n        try:\n            self.descargas_cfg.validate()\n        except Exception as exc:\n            messagebox.showerror("Error", f"Configuración inválida: {exc}")\n            return\n        archivo = filedialog.askopenfilename(title="Seleccionar archivo de prueba")\n        if not archivo:\n            return\n        try:\n            from descargas_oc.seafile_client import SeafileClient\n\n            cliente = SeafileClient(\n                self.descargas_cfg.seafile_url,\n                self.descargas_cfg.usuario,\n                self.descargas_cfg.password,\n            )\n            cliente.upload_file(\n                self.descargas_cfg.seafile_repo_id,\n                archivo,\n                parent_dir=self.descargas_cfg.seafile_subfolder,\n            )\n        except Exception as exc:\n            messagebox.showerror("Error", f"No se pudo subir el archivo: {exc}")\n            return\n        messagebox.showinfo("Información", "Archivo subido correctamente.")\n\n    def generate_processed_file(self):\n        datos = self._collect_descargas_form()\n        servidor = datos["pop_server"]\n        usuario = datos["usuario"]\n        contrasena = datos["password"]\n        puerto = datos["pop_port"]\n        if not (servidor and usuario and contrasena):\n            messagebox.showwarning(\n                "Advertencia",\n                "Debe completar servidor, usuario y contraseña para generar el archivo.",\n            )\n            return\n\n        if self._procesados_button:\n            self._procesados_button.config(state=tk.DISABLED)\n        self._procesados_status.set("Generando...")\n\n        def tarea():\n            mensaje = ""\n            estado = "Pendiente"\n            try:\n                conn = poplib.POP3_SSL(servidor, puerto)\n                conn.user(usuario)\n                conn.pass_(contrasena)\n                total = len(conn.list()[1])\n                PROCESADOS_FILE.parent.mkdir(parents=True, exist_ok=True)\n                with open(PROCESADOS_FILE, "w", encoding="utf-8") as archivo:\n                    for indice in range(total):\n                        respuesta = conn.uidl(indice + 1)\n                        linea = respuesta.decode() if isinstance(respuesta, bytes) else respuesta\n                        uidl = linea.split()[2]\n                        archivo.write(uidl + "\\n")\n                conn.quit()\n                mensaje = f"Se generaron {total} UIDL(s)."\n                estado = "Generado"\n            except Exception as exc:  # pragma: no cover - interacción con servidor\n                mensaje = f"No se pudo generar el archivo: {exc}"\n                estado = "Error"\n\n            def finalizar():\n                if self._procesados_button:\n                    self._procesados_button.config(state=tk.NORMAL)\n                self._procesados_status.set(estado)\n                if estado == "Generado":\n                    messagebox.showinfo("Procesados", mensaje)\n                else:\n                    messagebox.showerror("Procesados", mensaje)\n\n            self.after(0, finalizar)\n\n        threading.Thread(target=tarea, daemon=True).start()\n\n    def _scroll_to_widget(self, widget: tk.Widget):\n        canvas = self._oc_canvas\n        container = self._oc_scrollable\n        if not canvas or not container:\n            return\n        try:\n            canvas.update_idletasks()\n            container.update_idletasks()\n            widget.update_idletasks()\n        except tk.TclError:  # pragma: no cover - widget destruido\n            return\n\n        frame_height = container.winfo_height()\n        canvas_height = canvas.winfo_height()\n        if frame_height <= canvas_height or canvas_height <= 0:\n            return\n\n        try:\n            widget_top = widget.winfo_rooty() - container.winfo_rooty()\n            widget_bottom = widget_top + widget.winfo_height()\n        except tk.TclError:  # pragma: no cover - widget sin geometría\n            return\n\n        view_top, view_bottom = canvas.yview()\n        view_top *= frame_height\n        view_bottom *= frame_height\n\n        if widget_top < view_top:\n            destino = max(0, widget_top / frame_height)\n            canvas.yview_moveto(destino)\n        elif widget_bottom > view_bottom:\n            destino = (widget_bottom - canvas_height) / frame_height\n            destino = min(max(0, destino), 1)\n            canvas.yview_moveto(destino)\n\n    def focus_descargas_tab(self, section: str | None = None):\n        try:\n            self.notebook.select(self.oc_frame)\n        except tk.TclError:  # pragma: no cover - defensive\n            return\n        objetivo: tk.Widget | None = self._oc_focus\n        if section == "abastecimiento" and self._abastecimiento_focus:\n            objetivo = self._abastecimiento_focus\n        if objetivo:\n            objetivo.focus_set()\n            self.after(50, lambda: self._scroll_to_widget(objetivo))\n\n\nclass TemplateForm(tk.Toplevel):\n    def __init__(self, master, title, refresh_callback, template_data=None, email_session=None):\n        super().__init__(master)\n        self.title(title)\n        self.geometry("800x600")\n        self.transient(master)\n        self.grab_set()\n        self.focus()\n        self.refresh_callback = refresh_callback\n        self.template_data = template_data\n        self.email_session = email_session\n        self.create_widgets()\n        center_window(self)\n\n    def create_widgets(self):\n        container = ttk.Frame(self, style="MyFrame.TFrame", padding=10)\n        container.pack(fill="both", expand=True)\n\n        container.columnconfigure(0, weight=1)\n\n        self.name_var = tk.StringVar()\n        self.signature_var = tk.StringVar()\n\n        row = 0\n        ttk.Label(container, text="Nombre:", style="MyLabel.TLabel").grid(row=row, column=0, sticky="w", pady=5)\n        row += 1\n        ttk.Entry(container, textvariable=self.name_var, style="MyEntry.TEntry").grid(row=row, column=0, sticky="ew", pady=5)\n        row += 1\n\n        ttk.Label(container, text="Imagen de firma:", style="MyLabel.TLabel").grid(row=row, column=0, sticky="w", pady=5)\n        row += 1\n        frame_img = ttk.Frame(container, style="MyFrame.TFrame")\n        frame_img.grid(row=row, column=0, sticky="ew")\n        frame_img.columnconfigure(0, weight=1)\n        ttk.Entry(frame_img, textvariable=self.signature_var, style="MyEntry.TEntry").grid(row=0, column=0, sticky="ew", pady=5)\n        ttk.Button(frame_img, text="Seleccionar", style="MyButton.TButton", command=self.select_image).grid(row=0, column=1, padx=5)\n        row += 1\n        ttk.Button(container, text="Guardar", style="MyButton.TButton", command=self.save_template).grid(row=row, column=0, pady=(5,10), sticky="w")\n        row += 1\n\n        ttk.Label(container, text="Contenido HTML:", style="MyLabel.TLabel").grid(row=row, column=0, sticky="w", pady=5)\n        row += 1\n        self.editor = HtmlEditor(container)\n        self.editor.grid(row=row, column=0, sticky="nsew", pady=5)\n        container.rowconfigure(row, weight=1)\n        row += 1\n\n        ttk.Label(container, text="Correo de prueba:", style="MyLabel.TLabel").grid(row=row, column=0, sticky="w", pady=5)\n        row += 1\n        test_frame = ttk.Frame(container, style="MyFrame.TFrame")\n        test_frame.grid(row=row, column=0, sticky="ew")\n        test_frame.columnconfigure(0, weight=1)\n        self.test_email_var = tk.StringVar()\n        ttk.Entry(test_frame, textvariable=self.test_email_var, style="MyEntry.TEntry").grid(row=0, column=0, sticky="ew", pady=5)\n        ttk.Button(test_frame, text="Enviar prueba", style="MyButton.TButton", command=self.send_test_email).grid(row=0, column=1, padx=5, pady=5)\n\n        if self.template_data:\n            self.name_var.set(self.template_data[1])\n            self.editor.set_html(self.template_data[2])\n            if self.template_data[3]:\n                self.signature_var.set(self.template_data[3])\n\n    def select_image(self):\n        path = filedialog.askopenfilename(title="Seleccionar imagen", filetypes=[("Imágenes", "*.png *.jpg *.jpeg *.gif")])\n        if path:\n            self.signature_var.set(path)\n\n    def save_template(self):\n        # Recreate missing tables if the database was not initialized\n        db.init_db()\n        name = self.name_var.get().strip()\n        self.editor.text.tag_remove("sel", "1.0", "end")\n        raw_text = self.editor.text.get("1.0", "end-1c").strip()\n        html = self.editor.get_html().strip()\n        if not html and raw_text:\n            html = escape(raw_text).replace("\\n", "<br>")\n        signature = self.signature_var.get().strip()\n        if not (name and raw_text):\n            messagebox.showwarning(\n                "Advertencia",\n                "El nombre y el contenido son obligatorios.",\n            )\n            return\n        if self.template_data:\n            db.update_email_template(self.template_data[0], name, html, signature)\n        else:\n            db.add_email_template(name, html, signature)\n        self.refresh_callback()\n        self.destroy()\n\n    def send_test_email(self):\n        email = self.test_email_var.get().strip()\n        if not email:\n            messagebox.showwarning("Advertencia", "Ingrese un correo para la prueba.")\n            return\n        if not self.email_session:\n            messagebox.showerror("Error", "No hay sesión de correo configurada.")\n            return\n        name = self.name_var.get().strip() or "Formato"\n        self.editor.text.tag_remove("sel", "1.0", "end")\n        raw_text = self.editor.text.get("1.0", "end-1c").strip()\n        html = self.editor.get_html().strip()\n        if not html and raw_text:\n            html = escape(raw_text).replace("\\n", "<br>")\n        try:\n            send_email_custom(\n                self.email_session,\n                subject=f"Prueba {name}",\n                html_template=html,\n                context={"email_to": email},\n                signature_path=self.signature_var.get().strip() or None,\n            )\n            messagebox.showinfo("Información", "Correo de prueba enviado correctamente.")\n        except Exception as e:\n            messagebox.showerror("Error", f"No se pudo enviar el correo: {e}")\n    \n\nclass SupplierForm(tk.Toplevel):\n    def __init__(self, master, title, refresh_callback, supplier_data=None):\n        super().__init__(master)\n        self.title(title)\n        self.refresh_callback = refresh_callback\n        self.supplier_data = supplier_data\n        self.create_widgets()\n        center_window(self)\n    \n    def create_widgets(self):\n        container = ttk.Frame(self, style="MyFrame.TFrame", padding=10)\n        container.pack(fill="both", expand=True)\n        \n        self.name_var = tk.StringVar()\n        self.ruc_var = tk.StringVar()\n        self.email_var = tk.StringVar()\n        self.email2_var = tk.StringVar()\n        \n        ttk.Label(container, text="Nombre:", style="MyLabel.TLabel").pack(pady=5, anchor="w")\n        ttk.Entry(container, textvariable=self.name_var, style="MyEntry.TEntry").pack(pady=5, fill="x")\n        \n        ttk.Label(container, text="RUC:", style="MyLabel.TLabel").pack(pady=5, anchor="w")\n        ttk.Entry(container, textvariable=self.ruc_var, style="MyEntry.TEntry").pack(pady=5, fill="x")\n        \n        ttk.Label(container, text="Correo:", style="MyLabel.TLabel").pack(pady=5, anchor="w")\n        ttk.Entry(container, textvariable=self.email_var, style="MyEntry.TEntry").pack(pady=5, fill="x")\n\n        ttk.Label(container, text="Correo 2 (opcional):", style="MyLabel.TLabel").pack(pady=5, anchor="w")\n        ttk.Entry(container, textvariable=self.email2_var, style="MyEntry.TEntry").pack(pady=5, fill="x")\n        \n        ttk.Button(container, text="Guardar",\n                   style="MyButton.TButton",\n                   command=self.save_supplier).pack(pady=10)\n        \n        if self.supplier_data:\n            self.name_var.set(self.supplier_data[1])\n            self.ruc_var.set(self.supplier_data[2])\n            self.email_var.set(self.supplier_data[3])\n            if len(self.supplier_data) > 4:\n                self.email2_var.set(self.supplier_data[4])\n\n    def save_supplier(self):\n        name = self.name_var.get().strip()\n        ruc = self.ruc_var.get().strip()\n        email = self.email_var.get().strip()\n        email2 = self.email2_var.get().strip()\n        if not (name and ruc and email):\n            messagebox.showwarning(\n                "Advertencia",\n                "Nombre, RUC y el primer correo son obligatorios.",\n            )\n            return\n        if self.supplier_data:\n            db.update_supplier(self.supplier_data[0], name, ruc, email, email2)\n        else:\n            db.add_supplier(name, ruc, email, email2)\n        self.refresh_callback()\n        self.destroy()\n\n\nclass AssignmentForm(tk.Toplevel):\n    def __init__(self, master, title, refresh_callback, data=None):\n        super().__init__(master)\n        self.title(title)\n        self.refresh_callback = refresh_callback\n        self.data = data\n        self.create_widgets()\n        center_window(self)\n\n    def create_widgets(self):\n        container = ttk.Frame(self, style="MyFrame.TFrame", padding=10)\n        container.pack(fill="both", expand=True)\n\n        self.sub_var = tk.StringVar()\n        self.dept_var = tk.StringVar()\n        self.person_var = tk.StringVar()\n\n        ttk.Label(container, text="Subdepartamento:", style="MyLabel.TLabel").pack(anchor="w")\n        ttk.Entry(container, textvariable=self.sub_var, style="MyEntry.TEntry").pack(fill="x", pady=5)\n\n        ttk.Label(container, text="Departamento:", style="MyLabel.TLabel").pack(anchor="w")\n        ttk.Entry(container, textvariable=self.dept_var, style="MyEntry.TEntry").pack(fill="x", pady=5)\n\n        ttk.Label(container, text="Persona:", style="MyLabel.TLabel").pack(anchor="w")\n        ttk.Entry(container, textvariable=self.person_var, style="MyEntry.TEntry").pack(fill="x", pady=5)\n\n        ttk.Button(container, text="Guardar", style="MyButton.TButton", command=self.save).pack(pady=10)\n\n        if self.data:\n            self.sub_var.set(self.data[0])\n            self.dept_var.set(self.data[1])\n            self.person_var.set(self.data[2])\n\n    def save(self):\n        sub = self.sub_var.get().strip().upper()\n        dept = self.dept_var.get().strip()\n        person = self.person_var.get().strip()\n        if not (sub and dept and person):\n            messagebox.showwarning("Advertencia", "Todos los campos son obligatorios.")\n            return\n        if self.data and self.data[0] != sub:\n            db.delete_assignment(self.data[0])\n        db.set_assignment_config(sub, dept, person)\n        self.refresh_callback()\n        self.destroy()\n\ndef open_config_gui(root, email_session, *, focus_descargas: bool = False, section: str | None = None):\n    config_window = ConfigGUI(root, email_session)\n    if focus_descargas:\n        config_window.focus_descargas_tab(section)\n    config_window.transient(root)\n    config_window.grab_set()\n    config_window.wait_window()\n',
    'GestorCompras_/gestorcompras/gui/despacho_gui.py': 'import tkinter as tk\nfrom tkinter import ttk, messagebox\nfrom tkinter.scrolledtext import ScrolledText\nimport threading\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom gestorcompras.logic import despacho_logic\nfrom gestorcompras.services import db\n\n\ndef center_window(win: tk.Tk | tk.Toplevel):\n    win.update_idletasks()\n    w = win.winfo_width()\n    h = win.winfo_height()\n    x = (win.winfo_screenwidth() // 2) - (w // 2)\n    y = (win.winfo_screenheight() // 2) - (h // 2)\n    win.geometry(f"{w}x{h}+{x}+{y}")\n\ndef open_despacho(master, email_session):\n    window = tk.Toplevel(master)\n    window.title("Correos Masivos")\n    window.geometry("600x450")\n    window.transient(master)\n    window.grab_set()\n    center_window(window)\n    \n    main_frame = ttk.Frame(window, style="MyFrame.TFrame", padding=10)\n    main_frame.pack(fill="both", expand=True)\n    main_frame.rowconfigure(1, weight=1)\n    main_frame.rowconfigure(3, weight=1)\n    main_frame.columnconfigure(0, weight=1)\n    \n    label = ttk.Label(main_frame, text="Ingrese números de OC (una por línea):", style="MyLabel.TLabel")\n    label.grid(row=0, column=0, sticky="w", pady=10)\n    \n    text_area = tk.Text(main_frame, height=10)\n    text_area.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)\n    \n    ttk.Label(main_frame, text="Estado del Proceso:", style="MyLabel.TLabel").grid(row=2, column=0, sticky="w")\n    log_box = ScrolledText(main_frame, height=8, state="disabled")\n    log_box.grid(row=3, column=0, sticky="nsew", padx=5, pady=5)\n\n    ttk.Label(main_frame, text="Formato de correo:", style="MyLabel.TLabel").grid(row=4, column=0, sticky="w")\n    formatos = ["FORMATO"] + [tpl[1] for tpl in db.get_email_templates()]\n    formato_var = tk.StringVar(value="FORMATO")\n    ttk.Combobox(\n        main_frame,\n        textvariable=formato_var,\n        values=formatos,\n        state="readonly",\n    ).grid(row=4, column=0, sticky="e", padx=(150, 0))\n\n    adjuntar_var = tk.BooleanVar(value=False)\n    ttk.Checkbutton(\n        main_frame,\n        text="Adjuntar varias OC en un solo correo",\n        variable=adjuntar_var,\n        style="MyCheckbutton.TCheckbutton",\n    ).grid(row=5, column=0, sticky="w", pady=(5, 0))\n    \n    def log_func(message):\n        log_box.configure(state="normal")\n        log_box.insert(tk.END, message + "\\n")\n        log_box.see(tk.END)\n        log_box.configure(state="disabled")\n    \n    def process_input_orders():\n        orders = [o.strip() for o in text_area.get("1.0", tk.END).splitlines() if o.strip()]\n        if not orders:\n            messagebox.showwarning("Advertencia", "Ingrese al menos un número de OC.")\n            return\n\n        if formato_var.get() == "FORMATO":\n            messagebox.showwarning("Advertencia", "Debe seleccionar un formato de correo.")\n            return\n\n        summaries = []\n        infos = {}\n        for oc in orders:\n            info, error = despacho_logic.obtener_resumen_orden(oc)\n            if info:\n                emails = ", ".join(info["emails"]) if info["emails"] else ""\n                summaries.append(f"OC {oc} -> {emails}")\n                infos[oc] = info\n            else:\n                summaries.append(f"OC {oc}: {error}")\n        if not summaries:\n            return\n        if adjuntar_var.get():\n            group_count = len({info["ruc"] for info in infos.values()})\n        else:\n            group_count = len(infos)\n        confirm_msg = (\n            "\\n".join(summaries)\n            + f"\\n\\nFormato: {formato_var.get()}"\n            + f"\\n¿Enviar {group_count} correos?"\n        )\n        if not messagebox.askyesno("Confirmar envíos", confirm_msg):\n            return\n\n        log_func("Enviando correos, espere...")\n        btn_procesar.configure(state="disabled")\n\n        def process_all_orders():\n            results = []\n            if adjuntar_var.get():\n                results.extend(\n                    despacho_logic.process_orders_grouped(\n                        email_session,\n                        list(infos.keys()),\n                        True,\n                        formato_var.get(),\n                        "EMAIL_CC_DESPACHO",\n                    )\n                )\n                for result in results:\n                    log_func(result)\n            else:\n                with ThreadPoolExecutor(max_workers=4) as executor:\n                    futures = [\n                        executor.submit(\n                            despacho_logic.process_order,\n                            email_session,\n                            orden,\n                            True,\n                            formato_var.get(),\n                            "EMAIL_CC_DESPACHO",\n                        )\n                        for orden in orders\n                    ]\n                    for future in as_completed(futures):\n                        try:\n                            result = future.result()\n                        except Exception as e:\n                            result = f"Error en el procesamiento: {str(e)}"\n                        results.append(result)\n                        log_func(result)\n            messagebox.showinfo("Resultado", "\\n".join(results))\n            window.after(0, lambda: btn_procesar.configure(state="normal"))\n\n        threading.Thread(target=process_all_orders).start()\n\n    btn_procesar = ttk.Button(\n        main_frame,\n        text="Procesar Despachos",\n        style="MyButton.TButton",\n        command=process_input_orders,\n    )\n    btn_procesar.grid(row=6, column=0, pady=10)\n',
    'GestorCompras_/gestorcompras/gui/reasignacion_gui.py': 'import tkinter as tk\nfrom tkinter import ttk, messagebox, simpledialog\nfrom gestorcompras.services import db\nimport threading\nimport time\nimport datetime\nimport imaplib\nimport email\nimport re\nimport logging\nfrom typing import Any\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nSERVICIOS_HEADLESS_KEY = "SERVICIOS_HEADLESS"\nSERVICIOS_MENSAJE_KEY = "SERVICIOS_REASIGNACION_MSG"\nSERVICIOS_DEPARTAMENTO_KEY = "SERVICIOS_DEPARTAMENTO"\nSERVICIOS_USUARIO_KEY = "SERVICIOS_USUARIO"\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\nfrom webdriver_manager.chrome import ChromeDriverManager\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.action_chains import ActionChains\n\n\ndef center_window(win: tk.Tk | tk.Toplevel):\n    win.update_idletasks()\n    w = win.winfo_width()\n    h = win.winfo_height()\n    x = (win.winfo_screenwidth() // 2) - (w // 2)\n    y = (win.winfo_screenheight() // 2) - (h // 2)\n    win.geometry(f"{w}x{h}+{x}+{y}")\n\ndef process_body(body):\n    task_pattern = r\'Tarea:\\s+(\\d+)\\s+Reasignación a:\\s+(.*?)\\s+Datos relacionados:(.*?)\\n(?=Tarea:|\\Z)\'\n    tasks = re.findall(task_pattern, body, re.DOTALL)\n    tasks_data = []\n    for task_number, reasignacion, details in tasks:\n        detail_pattern = r\'- OC (\\d+) \\| (.*?) \\| FAC\\. (\\S+) \\| INGR\\. (\\S+)\'\n        details_list = re.findall(detail_pattern, details)\n        task_info = {\n            "task_number": task_number,\n            "reasignacion": reasignacion,\n            "details": [\n                {"OC": oc, "Proveedor": supplier, "Factura": invoice, "Ingreso": ingreso}\n                for oc, supplier, invoice, ingreso in details_list\n            ]\n        }\n        tasks_data.append(task_info)\n    return tasks_data\n\n\ndef _normalize_template(template: str | None) -> str:\n    if template is None or not template.strip():\n        template = db.get_config(SERVICIOS_MENSAJE_KEY, \'Taller Asignado "{proveedor}"\')\n    return template\n\n\ndef _provider_from_details(task: dict[str, Any]) -> str:\n    detalles = task.get("details") or []\n    if isinstance(detalles, list):\n        for detalle in detalles:\n            if isinstance(detalle, dict):\n                proveedor = detalle.get("Proveedor") or detalle.get("supplier")\n                if proveedor:\n                    return str(proveedor)\n    return "N/D"\n\n\nclass DateDialog(simpledialog.Dialog):\n    """Ventana para seleccionar una fecha con flechas."""\n\n    def body(self, master):\n        self.cur_date = datetime.date.today()\n        ttk.Label(master, text="Ingresa la fecha (DD/MM/YYYY):").pack()\n        ttk.Label(\n            master,\n            text=(\n                "Los correos solo se podran buscar hasta maximo 15 dias atras "\n                "debido a que el servidor de telconet los borra en ese periodo de tiempo"\n            ),\n            wraplength=300,\n        ).pack(pady=(0, 5))\n        self.entry = ttk.Entry(master)\n        self.entry.pack()\n        self._update()\n        self.entry.bind("<Up>", self._prev)\n        self.entry.bind("<Down>", self._next)\n        return self.entry\n\n    def _update(self):\n        self.entry.delete(0, tk.END)\n        self.entry.insert(0, self.cur_date.strftime("%d/%m/%Y"))\n\n    def _prev(self, event):\n        self.cur_date -= datetime.timedelta(days=1)\n        self._update()\n        return "break"\n\n    def _next(self, event):\n        self.cur_date += datetime.timedelta(days=1)\n        self._update()\n        return "break"\n\n    def apply(self):\n        self.result = self.entry.get()\n\ndef cargar_tareas_correo(email_address, email_password, window):\n    dialog = DateDialog(window)\n    date_input = dialog.result\n    if not date_input:\n        messagebox.showwarning("Advertencia", "No se ingresó fecha.", parent=window)\n        return\n    try:\n        date_since = datetime.datetime.strptime(date_input, "%d/%m/%Y").strftime("%d-%b-%Y")\n    except Exception:\n        messagebox.showerror("Error", "Formato de fecha inválido. Use DD/MM/YYYY", parent=window)\n        return\n\n    task_filters = []\n\n    imap_url = \'pop.telconet.ec\'\n    try:\n        mail = imaplib.IMAP4_SSL(imap_url, 993)\n        mail.login(email_address, email_password)\n        mail.select("inbox")\n    except Exception as e:\n        messagebox.showerror("Error", f"Error de autenticación en correo: {e}", parent=window)\n        return\n\n    query = f\'(FROM "omar777j@gmail.com" SINCE "{date_since}")\'\n    status, messages = mail.search(None, query)\n    messages = messages[0].split()\n    if not messages:\n        messagebox.showinfo("Información", f"No se encontraron correos desde {date_input}.", parent=window)\n        mail.logout()\n        return\n\n    loaded_count = 0\n    for mail_id in messages:\n        status, data = mail.fetch(mail_id, \'(RFC822)\')\n        for response_part in data:\n            if isinstance(response_part, tuple):\n                try:\n                    msg = email.message_from_bytes(response_part[1])\n                    body = msg.get_payload(decode=True).decode()\n                except Exception:\n                    continue\n                tasks_data = process_body(body)\n                for task_info in tasks_data:\n                    if task_filters and task_info["task_number"] not in task_filters:\n                        continue\n                    inserted = db.insert_task_temp(task_info["task_number"],\n                                                   task_info["reasignacion"],\n                                                   task_info["details"])\n                    if inserted:\n                        loaded_count += 1\n                        logger.debug("Tasks after insert: %s", db.get_tasks_temp())\n    mail.logout()\n    messagebox.showinfo("Información", f"Se cargaron {loaded_count} tareas (sin duplicados).", parent=window)\n\ndef login_telcos(driver, username, password):\n    driver.get(\'https://telcos.telconet.ec/inicio/?josso_back_to=http://telcos.telconet.ec/check&josso_partnerapp_host=telcos.telconet.ec\')\n    user_input = WebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.NAME, \'josso_username\')))\n    user_input.send_keys(username)\n    password_input = WebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.NAME, \'josso_password\')))\n    password_input.send_keys(password)\n    password_input.send_keys(Keys.RETURN)\n    WebDriverWait(driver, 20).until(EC.presence_of_element_located((By.ID, \'spanTareasPersonales\')))\n\n\ndef wait_clickable_or_error(driver, locator, parent, description, timeout=30, retries=3):\n    """Espera que un elemento sea clickeable reintentando varias veces."""\n    for intento in range(retries):\n        try:\n            return WebDriverWait(driver, timeout).until(\n                EC.element_to_be_clickable(locator)\n            )\n        except Exception as e:\n            if intento == retries - 1:\n                raise Exception(f"No se pudo encontrar {description}") from e\n            time.sleep(1)\n\ndef process_task(driver, task, parent_window):\n    task_number = task["task_number"]\n    dept = str(task.get("reasignacion", "")).strip().upper()\n    assignments = db.get_assignment_config()\n    assignment_info = assignments.get(dept, {})\n\n    dept_name = (\n        task.get("department_override")\n        or task.get("department")\n        or assignment_info.get("department")\n        or db.get_config(SERVICIOS_DEPARTAMENTO_KEY, "")\n    )\n    empleado = (\n        task.get("employee_override")\n        or task.get("empleado")\n        or assignment_info.get("person")\n        or db.get_config(SERVICIOS_USUARIO_KEY, "SIN ASIGNAR")\n    )\n\n    if not dept_name or not empleado:\n        raise Exception(\n            "No existe configuración de departamento o usuario para la reasignación de la tarea "\n            f"{task_number}"\n        )\n\n    proveedor = task.get("proveedor") or _provider_from_details(task)\n    mecanico = task.get("mecanico", "")\n    telefono = task.get("telefono", "")\n    inf_vehiculo = task.get("inf_vehiculo", "")\n    template = _normalize_template(task.get("comentario_template"))\n    variables = {\n        "proveedor": proveedor or "N/D",\n        "mecanico": mecanico or "N/D",\n        "telefono": telefono or "N/D",\n        "inf_vehiculo": inf_vehiculo or "N/D",\n        "task_number": task_number,\n    }\n    try:\n        comentario = template.format(**variables).strip()\n    except Exception:\n        comentario = template.replace("{proveedor}", variables["proveedor"]).strip()\n\n    element = wait_clickable_or_error(driver, (By.ID, \'spanTareasPersonales\'), parent_window, \'el menú de tareas\')\n    driver.execute_script("arguments[0].click();", element)\n    \n    search_input = wait_clickable_or_error(\n        driver,\n        (By.CSS_SELECTOR, \'input[type="search"].form-control.form-control-sm\'),\n        parent_window,\n        \'el campo de búsqueda\'\n    )\n    search_input.clear()\n    search_input.send_keys(task_number)\n    search_input.send_keys(Keys.RETURN)\n    \n    try:\n        time.sleep(0.5)\n        wait_clickable_or_error(\n            driver,\n            (By.CSS_SELECTOR, \'span.glyphicon.glyphicon-step-forward\'),\n            parent_window,\n            \'el botón para abrir la tarea\'\n        ).click()\n    except Exception:\n        # Se lanza la excepción con el mensaje exacto, sin mostrarla inmediatamente\n        raise Exception(f"No se encontraron las tareas en la plataforma Telcos.\\nTarea: {task_number}")\n    \n    time.sleep(1)\n    comment_input = wait_clickable_or_error(\n        driver, (By.ID, \'txtObservacionTarea\'), parent_window, \'el campo de comentario\')\n    comment_input.send_keys(comentario)\n    time.sleep(1)\n    wait_clickable_or_error(\n        driver, (By.ID, \'btnGrabarEjecucionTarea\'), parent_window, \'el botón Grabar Ejecución\').click()\n    time.sleep(2)\n    wait_clickable_or_error(driver, (By.ID, \'btnSmsCustomOk\'), parent_window, \'la confirmación inicial\').click()\n    time.sleep(2)\n\n    wait_clickable_or_error(\n        driver,\n        (By.CSS_SELECTOR, \'span.glyphicon.glyphicon-dashboard\'),\n        parent_window,\n        \'el botón de reasignar\'\n    ).click()\n    time.sleep(2)\n    department_input = wait_clickable_or_error(\n        driver,\n        (By.ID, \'txtDepartment\'),\n        parent_window,\n        \'el campo Departamento\'\n    )\n    department_input.clear()\n    department_input.send_keys(dept_name)\n    time.sleep(1)\n    #elemento para pruebas compras\n    #department_input.send_keys(Keys.UP, Keys.RETURN)\n    #////////////elementopara produccion bodega\n    department_input.send_keys(Keys.DOWN, Keys.RETURN)\n    time.sleep(2)\n    department_input.send_keys(Keys.TAB)\n    time.sleep(2)\n    employee_input = WebDriverWait(driver, 20).until(\n        EC.element_to_be_clickable((By.NAME, \'txtEmpleado\'))\n    )\n    employee_input.click()\n    employee_input.send_keys(empleado)\n    time.sleep(1)\n    employee_input.send_keys(Keys.DOWN, Keys.RETURN)\n    time.sleep(2)\n    employee_input.send_keys(Keys.TAB)\n    time.sleep(2)\n    observation_textarea = wait_clickable_or_error(\n        driver,\n        (By.ID, \'txtaObsTareaFinalReasigna\'),\n        parent_window,\n        \'el área de observación\'\n    )\n    observation_textarea.send_keys(\'TALLER ASIGNADO\')\n    try:\n        WebDriverWait(driver, 20).until(\n            EC.visibility_of_element_located((By.ID, "modalReasignarTarea"))\n        )\n    except Exception as e:\n        raise Exception("No se abrió la ventana de reasignación") from e\n    boton = wait_clickable_or_error(\n        driver,\n        (By.ID, "btnGrabarReasignaTarea"),\n        parent_window,\n        \'el botón Guardar\'\n    )\n    from selenium.webdriver.common.action_chains import ActionChains\n    ActionChains(driver).move_to_element(boton).perform()\n    boton.click()\n    final_confirm_button = WebDriverWait(driver, 20).until(\n        EC.element_to_be_clickable((By.ID, \'btnMensajeFinTarea\'))\n    )\n    final_confirm_button.click()\n    time.sleep(2)\n\ndef open_reasignacion(master, email_session):\n    window = tk.Toplevel(master)\n    window.title("Reasignación de Tareas")\n    window.geometry("820x650")\n    window.transient(master)\n    window.grab_set()\n    center_window(window)\n\n    def on_close():\n        db.clear_tasks_temp()\n        window.destroy()\n    window.protocol("WM_DELETE_WINDOW", on_close)\n\n    banner = ttk.Label(window, text="Sistema de automatización - compras")\n    banner.configure(font=("Helvetica", 24, "bold"), foreground="#222222")\n    banner.pack(pady=(20,10))\n\n    top_frame = ttk.Frame(window, style="MyFrame.TFrame", padding=5)\n    top_frame.pack(fill="x")\n\n    btn_cargar = ttk.Button(\n        top_frame,\n        text="Buscar Tareas",\n        style="MyButton.TButton",\n        command=lambda: [cargar_tareas_correo(email_session["address"], email_session["password"], window),\n                         actualizar_tareas()]\n    )\n    btn_cargar.pack(side="left", padx=5)\n\n    lbl_title = ttk.Label(top_frame, text="(Se buscan tareas notificadas mediante correo)", style="MyLabel.TLabel")\n    lbl_title.pack(side="left", padx=13)\n\n    main_frame = ttk.Frame(window, style="MyFrame.TFrame", padding=5)\n    main_frame.pack(fill="both", expand=True)\n\n    task_lf = ttk.LabelFrame(main_frame, text="Listado de Tareas",\n                             style="MyLabelFrame.TLabelframe", padding=5)\n    task_lf.pack(fill="both", expand=True)\n\n    canvas = tk.Canvas(task_lf, background="#FFFFFF", highlightthickness=1,\n                       highlightbackground="#CCCCCC")\n    scrollbar = ttk.Scrollbar(task_lf, orient="vertical", command=canvas.yview)\n    tasks_frame = ttk.Frame(canvas, style="MyFrame.TFrame")\n\n    def on_frame_configure(event):\n        canvas.configure(scrollregion=canvas.bbox("all"))\n    tasks_frame.bind("<Configure>", on_frame_configure)\n\n    canvas.create_window((0, 0), window=tasks_frame, anchor="nw")\n    canvas.configure(yscrollcommand=scrollbar.set)\n    canvas.pack(side="left", fill="both", expand=True)\n    scrollbar.pack(side="right", fill="y")\n\n    bottom_frame = ttk.Frame(window, style="MyFrame.TFrame", padding=5)\n    bottom_frame.pack(fill="x")\n\n    task_vars = {}\n    select_all_var = tk.BooleanVar(value=False)\n    headless_var = tk.BooleanVar(value=db.get_config(SERVICIOS_HEADLESS_KEY, "1") != "0")\n\n    def toggle_headless(*_args):\n        db.set_config(SERVICIOS_HEADLESS_KEY, "1" if headless_var.get() else "0")\n\n    headless_var.trace_add("write", toggle_headless)\n\n    def toggle_select_all():\n        new_val = select_all_var.get()\n        for t_id, (var, _) in task_vars.items():\n            var.set(new_val)\n\n    chk_select_all = ttk.Checkbutton(\n        bottom_frame,\n        text="Marcar todas",\n        style="MyCheckbutton.TCheckbutton",\n        variable=select_all_var,\n        command=toggle_select_all\n    )\n    chk_select_all.pack(side="left", padx=5)\n\n    ttk.Checkbutton(\n        bottom_frame,\n        text="Ejecutar navegador en modo oculto (headless)",\n        style="MyCheckbutton.TCheckbutton",\n        variable=headless_var,\n    ).pack(side="left", padx=5)\n\n    process_btn = ttk.Button(\n        bottom_frame,\n        text="Reasignar Tareas",\n        style="MyButton.TButton"\n    )\n    process_btn.pack(side="right")\n\n\n    def actualizar_tareas():\n        all_tasks = db.get_tasks_temp()\n        logger.debug("Tareas en DB: %s", all_tasks)\n\n        for widget in tasks_frame.winfo_children():\n            widget.destroy()\n        task_vars.clear()\n        select_all_var.set(False)\n\n        if not all_tasks:\n            no_tareas_label = ttk.Label(tasks_frame, text="No se encontraron tareas.", style="MyLabel.TLabel")\n            no_tareas_label.pack(pady=20)\n            process_btn.pack_forget()\n            return\n        else:\n            cantidad_label = ttk.Label(tasks_frame,\n                                       text=f"Se encontraron {len(all_tasks)} tareas:",\n                                       style="MyLabel.TLabel")\n            cantidad_label.pack(pady=(0,10))\n\n        for task in all_tasks:\n            var = tk.BooleanVar(value=False)\n            chk_text = f"Tarea {task[\'task_number\']} - {task[\'reasignacion\']}"\n            chk = ttk.Checkbutton(tasks_frame, text=chk_text,\n                                  style="MyCheckbutton.TCheckbutton",\n                                  variable=var)\n            chk.pack(anchor="w", pady=2)\n            task_vars[task["id"]] = (var, chk)\n\n        process_btn.pack(side="right")\n        canvas.update_idletasks()\n        canvas.yview_moveto(0.0)\n\n    def process_tasks():\n        if not any(var.get() for var, _ in task_vars.values()):\n            messagebox.showinfo(\n                "Resultado", "No se ha seleccionado ninguna tarea.", parent=window\n            )\n            return\n\n        process_btn.config(state="disabled", text="Procesando...")\n        window.update()\n\n        errors: list[str] = []\n        tasks_in_db = db.get_tasks_temp()\n        tasks_dict = {t["id"]: t for t in tasks_in_db}\n\n        service = Service(ChromeDriverManager().install())\n        chrome_options = Options()\n        if headless_var.get():\n            chrome_options.add_argument("--headless")\n        chrome_options.add_argument("--disable-gpu")\n        chrome_options.add_argument("--disable-extensions")\n        chrome_options.add_argument("--no-sandbox")\n        chrome_options.add_argument("--disable-dev-shm-usage")\n        prefs = {"profile.managed_default_content_settings.images": 2}\n        chrome_options.add_experimental_option("prefs", prefs)\n        driver = webdriver.Chrome(service=service, options=chrome_options)\n\n        telcos_username = email_session["address"].split("@")[0]\n        telcos_password = email_session["password"]\n        login_telcos(driver, telcos_username, telcos_password)\n\n        try:\n            for t_id, (var, _) in task_vars.items():\n                if var.get():\n                    task = tasks_dict[t_id]\n                    try:\n                        process_task(driver, task, window)\n                        db.delete_task_temp(t_id)\n                    except Exception as e:\n                        errors.append(str(e))\n        finally:\n            driver.quit()\n\n        if errors:\n            summary = "Algunas tareas no fueron reasignadas:\\n" + "\\n".join(errors)\n        else:\n            summary = "Tareas procesadas exitosamente."\n        messagebox.showinfo("Resultado", summary, parent=window)\n\n        process_btn.config(state="normal", text="Reasignar Tareas")\n        actualizar_tareas()\n        window.destroy()\n\n    process_btn.configure(command=process_tasks)\n    actualizar_tareas()\n\n',
    'GestorCompras_/gestorcompras/main.py': '"""Punto de entrada principal de la aplicación de escritorio."""\nfrom __future__ import annotations\n\nimport smtplib\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\n\nfrom gestorcompras.core import config as core_config\nfrom gestorcompras.gui.status_bar import ResourceStatusBar\nfrom gestorcompras.services import db\nfrom gestorcompras import theme\nfrom gestorcompras.ui import router\nfrom gestorcompras.ui.common import center_window, add_hover_effect\n\n# Palette (imported from theme for a cohesive modern look)\nbg_base = theme.bg_base\nbg_frame = theme.bg_frame\ncolor_primario = theme.color_primario\ncolor_hover = theme.color_hover\ncolor_acento = theme.color_acento\ncolor_texto = theme.color_texto\ncolor_titulos = theme.color_titulos\ncolor_borde = theme.color_borde\n\n# Fonts\nfuente_normal = ("Segoe UI", 11)\nfuente_bold = ("Segoe UI", 11, "bold")\nfuente_banner = ("Segoe UI", 20, "bold")\nfuente_entry = ("Segoe UI", 14)\n\nemail_session: dict[str, str] = {}\n\n\ndef test_email_connection(email_address: str, email_password: str) -> bool:\n    try:\n        with smtplib.SMTP("smtp.telconet.ec", 587) as server:\n            server.starttls()\n            server.login(email_address, email_password)\n        return True\n    except Exception:\n        return False\n\n\ndef init_styles() -> None:\n    style = ttk.Style()\n    style.theme_use("clam")\n\n    style.configure("MyFrame.TFrame", background=bg_frame, relief="groove", borderwidth=1)\n    style.configure("MyLabel.TLabel", background=bg_frame, foreground=color_texto, font=fuente_normal)\n    style.map(\n        "MyLabel.TLabel",\n        background=[("active", bg_frame)],\n        foreground=[("active", color_texto)],\n    )\n    style.configure(\n        "MyButton.TButton",\n        font=fuente_bold,\n        foreground=color_titulos,\n        background=color_primario,\n        padding=10,\n        relief="raised",\n        borderwidth=1,\n    )\n    style.configure(\n        "MyButtonHover.TButton",\n        font=fuente_bold,\n        foreground=color_titulos,\n        background=color_hover,\n        padding=10,\n        relief="raised",\n        borderwidth=1,\n    )\n    style.map(\n        "MyButton.TButton",\n        background=[("active", color_acento), ("disabled", color_borde)],\n        foreground=[("active", bg_frame)],\n    )\n    style.map(\n        "MyButtonHover.TButton",\n        background=[("active", color_acento)],\n        foreground=[("active", color_titulos)],\n    )\n    style.configure("MyCheckbutton.TCheckbutton", background=bg_frame, foreground=color_texto, font=fuente_normal)\n    style.configure(\n        "MyEntry.TEntry",\n        font=fuente_entry,\n        padding=5,\n        relief="solid",\n        borderwidth=1,\n        foreground=color_texto,\n        fieldbackground=bg_base,\n        background=bg_base,\n        insertcolor=color_texto,\n    )\n    style.configure(\n        "TCombobox",\n        foreground=color_texto,\n        fieldbackground=bg_base,\n        background=bg_base,\n        arrowcolor=color_texto,\n    )\n    style.configure("MyNotebook.TNotebook", background=bg_base, borderwidth=0)\n    style.configure("MyNotebook.TNotebook.Tab", padding=[12, 8], font=fuente_bold)\n    style.map(\n        "MyNotebook.TNotebook.Tab",\n        background=[("selected", color_primario), ("active", color_hover)],\n        foreground=[("selected", color_texto), ("active", color_texto)],\n    )\n    style.configure(\n        "MyTreeview.Treeview",\n        background=bg_frame,\n        foreground=color_texto,\n        rowheight=28,\n        fieldbackground=bg_frame,\n        font=fuente_normal,\n    )\n    style.configure("MyTreeview.Treeview.Heading", background=color_primario, foreground=color_titulos, font=fuente_bold)\n    style.map("MyTreeview.Treeview.Heading", background=[("active", color_hover)])\n    style.configure(\n        "MyVertical.TScrollbar",\n        gripcount=0,\n        background=color_primario,\n        troughcolor=bg_frame,\n        bordercolor=bg_frame,\n        arrowcolor=color_texto,\n    )\n    style.map("MyVertical.TScrollbar", background=[("active", color_hover)], arrowcolor=[("active", color_texto)])\n    style.configure("MyLabelFrame.TLabelframe", background=bg_frame, relief="groove")\n    style.configure("MyLabelFrame.TLabelframe.Label", background=bg_frame, foreground=color_texto, font=fuente_bold)\n    style.configure("Banner.TLabel", background=bg_frame, foreground=color_titulos, font=fuente_banner)\n\n\nclass LoginScreen(tk.Frame):\n    def __init__(self, master: tk.Misc, on_success):\n        super().__init__(master)\n        self.on_success = on_success\n        self._banner_text = "COMPRAS TELCONET S.A"\n        self._banner_index = 0\n        self._banner_colors = [color_primario, color_acento]\n        self._color_index = 0\n        self.create_widgets()\n        self.animate_banner()\n\n    def create_widgets(self) -> None:\n        container = ttk.Frame(self, style="MyFrame.TFrame")\n        container.pack(fill="both", expand=True)\n\n        self.banner = ttk.Label(container, text="", style="Banner.TLabel")\n        self.banner.pack(pady=(20, 10))\n\n        login_frame = ttk.Frame(container, style="MyFrame.TFrame", padding=20)\n        login_frame.place(relx=0.5, rely=0.5, anchor="center")\n\n        lbl_title = ttk.Label(login_frame, text="Inicio de Sesión", style="MyLabel.TLabel")\n        lbl_title.configure(font=fuente_bold, foreground=color_titulos)\n        lbl_title.grid(row=0, column=0, pady=15)\n\n        ttk.Label(login_frame, text="Usuario Telcos:", style="MyLabel.TLabel").grid(row=1, column=0, sticky="w", pady=(5, 0))\n        self.user_entry = ttk.Entry(login_frame, style="MyEntry.TEntry")\n        self.user_entry.grid(row=2, column=0, pady=5)\n        self.user_entry.config(font=fuente_entry)\n\n        ttk.Label(login_frame, text="Contraseña:", style="MyLabel.TLabel").grid(row=3, column=0, sticky="w", pady=(5, 0))\n        self.pass_entry = ttk.Entry(login_frame, show="*", style="MyEntry.TEntry")\n        self.pass_entry.grid(row=4, column=0, pady=5)\n        self.pass_entry.config(font=fuente_entry)\n        self.pass_entry.bind("<Return>", lambda event: self.attempt_login())\n\n        btn_login = ttk.Button(login_frame, text="Iniciar Sesión", style="MyButton.TButton", command=self.attempt_login)\n        btn_login.grid(row=5, column=0, pady=15)\n        add_hover_effect(btn_login)\n\n    def animate_banner(self) -> None:\n        text = self._banner_text[: self._banner_index]\n        color = self._banner_colors[self._color_index]\n        self.banner.config(text=text, foreground=color)\n        self._banner_index += 1\n        if self._banner_index > len(self._banner_text):\n            self._banner_index = 0\n            self._color_index = (self._color_index + 1) % len(self._banner_colors)\n        self.after(150, self.animate_banner)\n\n    def attempt_login(self) -> None:\n        username = self.user_entry.get().strip()\n        password = self.pass_entry.get().strip()\n        if not username or not password:\n            messagebox.showerror("Error", "Debe ingresar usuario y contraseña.", parent=self)\n            return\n        email_address = f"{username}@telconet.ec"\n        if test_email_connection(email_address, password):\n            email_session["address"] = email_address\n            email_session["password"] = password\n            core_config.set_user_email(email_address)\n            messagebox.showinfo("Éxito", "Inicio de sesión correcto.", parent=self)\n            self.on_success()\n        else:\n            messagebox.showerror("Error", "Usuario o contraseña incorrectos.", parent=self)\n\n\ndef main() -> None:\n    db.init_db()\n    root = tk.Tk()\n    root.title("Sistema de Automatización")\n    root.geometry("800x600")\n    root.tk_setPalette(\n        background=bg_base,\n        foreground=color_texto,\n        activeBackground=color_hover,\n        activeForeground=color_texto,\n        highlightColor=color_borde,\n    )\n    center_window(root)\n\n    init_styles()\n\n    def on_main_close():\n        for w in root.winfo_children():\n            if isinstance(w, tk.Toplevel):\n                messagebox.showwarning(\n                    "Aviso",\n                    "No puede cerrar la ventana principal mientras existan ventanas abiertas.",\n                    parent=root,\n                )\n                return\n        root.destroy()\n\n    root.protocol("WM_DELETE_WINDOW", on_main_close)\n\n    container = ttk.Frame(root, style="MyFrame.TFrame")\n    container.pack(fill="both", expand=True)\n\n    status_bar = ResourceStatusBar(root)\n    status_bar.pack(side="bottom", fill="x")\n\n    def show_home() -> None:\n        router.configure(container, email_session)\n\n    LoginScreen(container, on_success=show_home).pack(fill="both", expand=True)\n\n    root.mainloop()\n\n\nif __name__ == "__main__":\n    main()\n',
    'GestorCompras_/gestorcompras/modules/__init__.py': '"""Módulos gráficos reexportados para facilitar el ruteo."""\n\nfrom . import config_gui, correos_masivos_gui, descargas_oc_gui, reasignacion_gui\n\n__all__ = [\n    "config_gui",\n    "correos_masivos_gui",\n    "descargas_oc_gui",\n    "reasignacion_gui",\n]\n',
    'GestorCompras_/gestorcompras/modules/config_gui.py': '"""Compatibilidad de menú para abrir la configuración general."""\nfrom __future__ import annotations\n\nimport tkinter as tk\n\nfrom gestorcompras.gui import config_gui as bienes_config\n\n\ndef open(master: tk.Misc, email_session: dict[str, str] | None = None, mode: str = "bienes") -> None:\n    """Reutiliza la ventana de configuración existente.\n\n    El flujo de Servicios comparte los mismos parámetros de asignación que\n    Compras Bienes, por lo que se delega completamente a la interfaz\n    tradicional.\n    """\n\n    bienes_config.open_config_gui(master, email_session)\n\n\n__all__ = ["open"]\n',
    'GestorCompras_/gestorcompras/modules/correos_masivos_gui.py': '"""Módulo de compatibilidad para la interfaz de Correos Masivos.\n\nEste archivo mantiene el punto de entrada esperado por el menú de\nnavegación. Internamente reutiliza la implementación previa ubicada en\n:mod:`gestorcompras.gui.despacho_gui` para evitar duplicar lógica.\n"""\nfrom gestorcompras.gui.despacho_gui import open_despacho as open\n\n__all__ = ["open"]\n',
    'GestorCompras_/gestorcompras/modules/descargas_oc_gui.py': '"""Punto de entrada reutilizable para la ventana de descargas de OC."""\nfrom __future__ import annotations\n\nfrom pathlib import Path\nimport subprocess\nimport sys\nimport tkinter as tk\nfrom tkinter import messagebox, ttk\n\nfrom gestorcompras.ui.common import add_hover_effect, center_window\n\n\ndef _find_descargas_root() -> Path | None:\n    for parent in Path(__file__).resolve().parents:\n        candidate = (parent / "DescargasOC-main").resolve()\n        if candidate.exists():\n            return candidate\n    return None\n\n\n_DESCARGAS_ROOT = _find_descargas_root()\n\n\ndef open(master: tk.Misc) -> None:\n    """Abre el selector para iniciar los módulos de descargas de OC."""\n    option_win = tk.Toplevel(master)\n    option_win.title("Descargas OC")\n    option_win.transient(master)\n    option_win.grab_set()\n    center_window(option_win)\n\n    ttk.Label(\n        option_win,\n        text="Seleccione el tipo de descarga:",\n        style="MyLabel.TLabel",\n    ).pack(padx=10, pady=10)\n\n    def _launch(script_name: str, error_title: str) -> None:\n        if _DESCARGAS_ROOT is None:\n            messagebox.showerror(\n                "Descargas OC",\n                "No se encontró la carpeta \'DescargasOC-main\'.",\n                parent=option_win,\n            )\n            return\n        script = _DESCARGAS_ROOT / "descargas_oc" / script_name\n        try:\n            subprocess.Popen([sys.executable, str(script)])\n        except OSError as exc:  # pragma: no cover - errores del SO\n            messagebox.showerror(\n                error_title,\n                (\n                    f"No se pudo abrir el módulo {script_name}. "\n                    f"Detalle: {exc}"\n                ),\n                parent=option_win,\n            )\n            return\n        option_win.destroy()\n\n    btn_norm = ttk.Button(\n        option_win,\n        text="Descarga Normal",\n        style="MyButton.TButton",\n        command=lambda: _launch("ui.py", "Error"),\n    )\n    btn_norm.pack(padx=10, pady=5)\n    add_hover_effect(btn_norm)\n\n    btn_abast = ttk.Button(\n        option_win,\n        text="Abastecimiento",\n        style="MyButton.TButton",\n        command=lambda: _launch("ui_abastecimiento.py", "Error"),\n    )\n    btn_abast.pack(padx=10, pady=5)\n    add_hover_effect(btn_abast)\n',
    'GestorCompras_/gestorcompras/modules/reasignacion_gui.py': '"""Punto de entrada unificado para la reasignación de tareas."""\nfrom __future__ import annotations\n\nimport email\nimport hashlib\nimport html\nimport imaplib\nimport logging\nimport re\nimport unicodedata\nfrom email.header import decode_header, make_header\nfrom email.message import Message\nfrom email.utils import parsedate_to_datetime\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom zoneinfo import ZoneInfo\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\n\nfrom gestorcompras.core import config as core_config\nfrom gestorcompras.core.mail_parse import parse_body, parse_subject\nfrom gestorcompras.data import reasignaciones_repo\nfrom gestorcompras.services import reassign_bridge, db\nfrom gestorcompras.ui.common import add_hover_effect, center_window\nfrom gestorcompras.gui import reasignacion_gui as legacy_gui\n\nLOG_PATH = Path(__file__).resolve().parents[2] / "logs" / "servicios_reasignacion.log"\nLOG_PATH.parent.mkdir(parents=True, exist_ok=True)\nlogger = logging.getLogger("servicios_reasignacion")\nif not logger.handlers:\n    handler = logging.FileHandler(LOG_PATH, encoding="utf-8")\n    formatter = logging.Formatter("%(asctime)s %(levelname)s - %(message)s")\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    logger.setLevel(logging.INFO)\n\n\nSERVICIOS_REMITENTE_KEY = "SERVICIOS_REMITENTE"\n\n\nclass ServiciosReasignacion(tk.Toplevel):\n    columns = (\n        "seleccion",\n        "fecha",\n        "numero_tarea",\n        "taller",\n        "asunto",\n    )\n\n    def __init__(self, master: tk.Misc | None, email_session: dict[str, str]):\n        super().__init__(master)\n        self.title("Reasignación de tareas - Servicios")\n        self.geometry("1080x640")\n        self.transient(master)\n        self.grab_set()\n        self.email_session = email_session\n        self.records: dict[str, dict[str, object]] = {}\n        self._correo_usuario = core_config.get_user_email() or email_session.get("address", "")\n        self.servicios_cfg = core_config.get_servicios_config()\n        self.departamento_var = tk.StringVar(value=db.get_config("SERVICIOS_DEPARTAMENTO", ""))\n        self.usuario_var = tk.StringVar(value=db.get_config("SERVICIOS_USUARIO", ""))\n        self.headless_var = tk.BooleanVar(value=db.get_config("SERVICIOS_HEADLESS", "1") != "0")\n        self.headless_var.trace_add("write", self._persist_headless)\n        remitente_default = db.get_config(\n            SERVICIOS_REMITENTE_KEY,\n            self.servicios_cfg.get("remitente_correo", ""),\n        )\n        self.remitente_var = tk.StringVar(value=remitente_default)\n        self._build_ui()\n        center_window(self)\n\n    # UI helpers\n    def _build_ui(self) -> None:\n        main = ttk.Frame(self, style="MyFrame.TFrame", padding=10)\n        main.pack(fill="both", expand=True)\n        main.columnconfigure(0, weight=3)\n        main.columnconfigure(1, weight=2)\n        main.rowconfigure(2, weight=1)\n\n        filtros = ttk.LabelFrame(main, text="Filtros", style="MyLabelFrame.TLabelframe", padding=10)\n        filtros.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 10))\n        for col in (1, 3):\n            filtros.columnconfigure(col, weight=1)\n        filtros.columnconfigure(4, weight=0)\n\n        ttk.Label(filtros, text="Desde (YYYY-MM-DD HH:MM):", style="MyLabel.TLabel").grid(row=0, column=0, sticky="w")\n        self.desde_var = tk.StringVar()\n        self.hasta_var = tk.StringVar()\n        tz = ZoneInfo(self.servicios_cfg.get("zona_horaria", "America/Guayaquil"))\n        ahora = datetime.now(tz)\n        self.desde_var.set((ahora - timedelta(hours=24)).strftime("%Y-%m-%d %H:%M"))\n        self.hasta_var.set(ahora.strftime("%Y-%m-%d %H:%M"))\n\n        ttk.Entry(filtros, textvariable=self.desde_var, style="MyEntry.TEntry", width=22).grid(row=0, column=1, padx=5, sticky="ew")\n\n        ttk.Label(filtros, text="Hasta (YYYY-MM-DD HH:MM):", style="MyLabel.TLabel").grid(row=0, column=2, sticky="w")\n        ttk.Entry(filtros, textvariable=self.hasta_var, style="MyEntry.TEntry", width=22).grid(row=0, column=3, padx=5, sticky="ew")\n\n        buscar_btn = ttk.Button(filtros, text="Buscar", style="MyButton.TButton", command=self._buscar)\n        buscar_btn.grid(row=0, column=4, padx=10, rowspan=2, sticky="n")\n        add_hover_effect(buscar_btn)\n\n        ttk.Button(\n            filtros,\n            text="Cerrar",\n            style="MyButton.TButton",\n            command=self.destroy,\n        ).grid(row=0, column=5, rowspan=2, sticky="ne")\n\n        ttk.Label(filtros, text="Remitente:", style="MyLabel.TLabel").grid(row=1, column=0, sticky="w", pady=(8, 0))\n        ttk.Entry(\n            filtros,\n            textvariable=self.remitente_var,\n            style="MyEntry.TEntry",\n        ).grid(row=1, column=1, columnspan=3, padx=5, sticky="ew", pady=(8, 0))\n\n        asignacion = ttk.LabelFrame(\n            main,\n            text="Datos de reasignación",\n            style="MyLabelFrame.TLabelframe",\n            padding=10,\n        )\n        asignacion.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(0, 10))\n        asignacion.columnconfigure(1, weight=1)\n        asignacion.columnconfigure(3, weight=1)\n\n        ttk.Label(asignacion, text="Departamento Telcos:", style="MyLabel.TLabel").grid(\n            row=0, column=0, sticky="w"\n        )\n        ttk.Entry(asignacion, textvariable=self.departamento_var, style="MyEntry.TEntry", width=28).grid(\n            row=0, column=1, padx=5, sticky="ew"\n        )\n\n        ttk.Label(asignacion, text="Usuario a reasignar:", style="MyLabel.TLabel").grid(\n            row=0, column=2, sticky="w"\n        )\n        ttk.Entry(asignacion, textvariable=self.usuario_var, style="MyEntry.TEntry", width=28).grid(\n            row=0, column=3, padx=5, sticky="ew"\n        )\n\n        ttk.Checkbutton(\n            asignacion,\n            text="Ejecutar navegador en modo oculto (headless)",\n            style="MyCheckbutton.TCheckbutton",\n            variable=self.headless_var,\n        ).grid(row=1, column=0, columnspan=4, sticky="w", pady=(8, 0))\n\n        tabla_frame = ttk.Frame(main, style="MyFrame.TFrame")\n        tabla_frame.grid(row=2, column=0, sticky="nsew")\n        tabla_frame.rowconfigure(0, weight=1)\n        tabla_frame.columnconfigure(0, weight=1)\n\n        self.tree = ttk.Treeview(\n            tabla_frame,\n            columns=self.columns,\n            show="headings",\n            style="MyTreeview.Treeview",\n            selectmode="browse",\n        )\n        headings = {\n            "seleccion": "",\n            "fecha": "Fecha",\n            "numero_tarea": "Número de tarea",\n            "taller": "Taller",\n            "asunto": "Asunto",\n        }\n        for col, label in headings.items():\n            self.tree.heading(col, text=label)\n        self.tree.column("seleccion", width=40, anchor="center")\n        self.tree.column("fecha", width=150, anchor="center")\n        self.tree.column("numero_tarea", width=140, anchor="center")\n        self.tree.column("taller", width=220, anchor="w")\n        self.tree.column("asunto", width=320, anchor="w")\n        self.tree.grid(row=0, column=0, sticky="nsew")\n        self.tree.bind("<<TreeviewSelect>>", self._on_select)\n        self.tree.bind("<Button-1>", self._on_tree_click, add=True)\n\n        scrollbar = ttk.Scrollbar(tabla_frame, orient="vertical", command=self.tree.yview)\n        scrollbar.grid(row=0, column=1, sticky="ns")\n        self.tree.configure(yscrollcommand=scrollbar.set)\n\n        acciones = ttk.Frame(main, style="MyFrame.TFrame", padding=5)\n        acciones.grid(row=3, column=0, sticky="ew", pady=5)\n\n        self.select_all_var = tk.BooleanVar(value=False)\n        ttk.Checkbutton(\n            acciones,\n            text="Marcar todos",\n            style="MyCheckbutton.TCheckbutton",\n            variable=self.select_all_var,\n            command=self._toggle_all,\n        ).pack(side="left")\n\n        self.estado_label = ttk.Label(acciones, text="", style="MyLabel.TLabel")\n        self.estado_label.pack(side="left", padx=(10, 0))\n\n        reasignar_btn = ttk.Button(acciones, text="Reasignar", style="MyButton.TButton", command=self._reasignar)\n        reasignar_btn.pack(side="right", padx=5)\n        add_hover_effect(reasignar_btn)\n\n        preview_frame = ttk.LabelFrame(main, text="Vista previa", style="MyLabelFrame.TLabelframe", padding=10)\n        preview_frame.grid(row=2, column=1, rowspan=2, sticky="nsew", padx=(10, 0))\n        preview_frame.rowconfigure(0, weight=1)\n        preview_frame.columnconfigure(0, weight=1)\n\n        self.preview = tk.Text(preview_frame, wrap="word", state="disabled")\n        self.preview.grid(row=0, column=0, sticky="nsew")\n\n    @staticmethod\n    def _checkbox_symbol(checked: bool) -> str:\n        return "☑" if checked else "☐"\n\n    def _toggle_all(self) -> None:\n        new_state = self.select_all_var.get()\n        for message_id, record in self.records.items():\n            record["checked"] = new_state\n            self.tree.set(message_id, "seleccion", self._checkbox_symbol(new_state))\n\n    def _sync_master_check(self) -> None:\n        if not self.records:\n            self.select_all_var.set(False)\n            return\n        all_checked = all(record.get("checked") for record in self.records.values())\n        if self.select_all_var.get() != all_checked:\n            self.select_all_var.set(all_checked)\n\n    def _on_tree_click(self, event) -> str | None:\n        region = self.tree.identify_region(event.x, event.y)\n        if region != "cell":\n            return None\n        column = self.tree.identify_column(event.x)\n        if column != "#1":\n            return None\n        item_id = self.tree.identify_row(event.y)\n        if not item_id:\n            return "break"\n        record = self.records.get(item_id)\n        if not record:\n            return "break"\n        nuevo_estado = not record.get("checked", False)\n        record["checked"] = nuevo_estado\n        self.tree.set(item_id, "seleccion", self._checkbox_symbol(nuevo_estado))\n        self._sync_master_check()\n        return "break"\n\n    # Helpers\n    def _persist_headless(self, *_args) -> None:\n        db.set_config("SERVICIOS_HEADLESS", "1" if self.headless_var.get() else "0")\n\n    def _parse_datetime(self, value: str) -> datetime:\n        cfg = core_config.get_servicios_config()\n        tz = ZoneInfo(cfg.get("zona_horaria", "America/Guayaquil"))\n        return datetime.strptime(value.strip(), "%Y-%m-%d %H:%M").replace(tzinfo=tz)\n\n    @staticmethod\n    def _decode_header_value(raw: str) -> str:\n        try:\n            return str(make_header(decode_header(raw)))\n        except Exception:  # pragma: no cover - caso defensivo\n            partes: list[str] = []\n            for value, encoding in decode_header(raw):\n                if isinstance(value, bytes):\n                    codec = encoding or "utf-8"\n                    try:\n                        partes.append(value.decode(codec, errors="ignore"))\n                    except Exception:\n                        partes.append(value.decode("utf-8", errors="ignore"))\n                else:\n                    partes.append(value)\n            return "".join(partes)\n\n    @classmethod\n    def _decode_subject(cls, msg: Message) -> str:\n        return cls._decode_header_value(msg.get("Subject", ""))\n\n    @staticmethod\n    def _clean_html(text: str) -> str:\n        cleaned = re.sub(r"(?is)<(script|style).*?>.*?</\\\\1>", " ", text)\n        cleaned = re.sub(r"(?is)<br\\\\s*/?>", "\\n", cleaned)\n        cleaned = re.sub(r"(?is)</p>", "\\n", cleaned)\n        cleaned = re.sub(r"(?is)<[^>]+>", " ", cleaned)\n        cleaned = html.unescape(cleaned)\n        return re.sub(r"\\s+", " ", cleaned).strip()\n\n    @classmethod\n    def _extract_text(cls, msg: Message) -> str:\n        partes: list[str] = []\n        if msg.is_multipart():\n            for part in msg.walk():\n                if part.get_content_disposition() == "attachment":\n                    continue\n                payload = part.get_payload(decode=True)\n                if payload is None:\n                    continue\n                charset = part.get_content_charset() or "utf-8"\n                try:\n                    texto = payload.decode(charset, errors="ignore")\n                except Exception:\n                    texto = payload.decode("utf-8", errors="ignore")\n                if part.get_content_type() == "text/html":\n                    texto = cls._clean_html(texto)\n                partes.append(texto)\n        else:\n            payload = msg.get_payload(decode=True)\n            if payload:\n                charset = msg.get_content_charset() or "utf-8"\n                try:\n                    texto = payload.decode(charset, errors="ignore")\n                except Exception:\n                    texto = payload.decode("utf-8", errors="ignore")\n                if msg.get_content_type() == "text/html":\n                    texto = cls._clean_html(texto)\n                partes.append(texto)\n        return "\\n".join(filter(None, partes)).strip()\n\n    @staticmethod\n    def _parse_header_date(msg: Message, tz: ZoneInfo) -> datetime | None:\n        header = msg.get("Date")\n        if not header:\n            return None\n        try:\n            dt = parsedate_to_datetime(header)\n        except (TypeError, ValueError):\n            return None\n        if dt is None:\n            return None\n        if dt.tzinfo is None:\n            dt = dt.replace(tzinfo=ZoneInfo("UTC"))\n        return dt.astimezone(tz)\n\n    def _buscar_correos(\n        self,\n        usuario: str,\n        password: str,\n        cadena_asunto: str,\n        dt_desde: datetime,\n        dt_hasta: datetime,\n        remitente: str = "",\n    ) -> list[dict[str, object]]:\n        tz = dt_desde.tzinfo or ZoneInfo("America/Guayaquil")\n        cadena_normalizada = self._normalize_for_search(cadena_asunto)\n        host = "pop.telconet.ec"\n        puerto = 993\n        remitente_busqueda = remitente.strip()\n        remitente_normalizado = remitente_busqueda.lower()\n\n        conexion = imaplib.IMAP4_SSL(host, puerto)\n        try:\n            conexion.login(usuario, password)\n            conexion.select("INBOX")\n            since = dt_desde.strftime("%d-%b-%Y")\n            criterios: list[str] = ["SINCE", since]\n            if remitente_busqueda:\n                criterios.extend(["FROM", remitente_busqueda])\n            status, data = conexion.search(None, *criterios)\n            if status != "OK":\n                raise RuntimeError("No se pudo obtener el listado de correos")\n            ids = data[0].split()\n            resultados: list[dict[str, object]] = []\n            for msg_id in reversed(ids):\n                status, fetch_data = conexion.fetch(msg_id, "(RFC822)")\n                if status != "OK":\n                    continue\n                for response in fetch_data:\n                    if not isinstance(response, tuple):\n                        continue\n                    msg = email.message_from_bytes(response[1])\n                    subject = self._decode_subject(msg)\n                    subject_normalized = self._normalize_for_search(subject)\n                    if cadena_normalizada not in subject_normalized:\n                        continue\n                    from_header = self._decode_header_value(msg.get("From", ""))\n                    if remitente_normalizado and remitente_normalizado not in from_header.lower():\n                        continue\n                    fecha = self._parse_header_date(msg, tz)\n                    if not fecha or not (dt_desde <= fecha <= dt_hasta):\n                        continue\n                    cuerpo = self._extract_text(msg)\n                    parsed = parse_body(cuerpo, usuario)\n                    if not parsed.get("correo_usuario_encontrado"):\n                        mensaje_id = msg_id.decode() if isinstance(msg_id, bytes) else str(msg_id)\n                        logger.info(\n                            "Correo ignorado por no contener al usuario: id=%s",\n                            mensaje_id,\n                        )\n                        continue\n                    info_tarea = parse_subject(subject)\n                    mensaje_id = msg_id.decode() if isinstance(msg_id, bytes) else str(msg_id)\n                    registros = {\n                        "message_id": mensaje_id,\n                        "date": fecha,\n                        "subject": subject,\n                        "from": from_header,\n                        "task_number": info_tarea.get("task_number", "N/D"),\n                        "body": cuerpo,\n                        "proveedor": parsed.get("proveedor", "N/D"),\n                        "mecanico_nombre": parsed.get("mecanico_nombre", "N/D"),\n                        "mecanico_telefono": parsed.get("mecanico_telefono", "N/D"),\n                        "inf_vehiculo": parsed.get("inf_vehiculo", "N/D"),\n                    }\n                    resultados.append(registros)\n                    logger.info(\n                        "Correo válido encontrado: id=%s tarea=%s remitente=%s",\n                        registros["message_id"],\n                        registros["task_number"],\n                        from_header or "(sin remitente)",\n                    )\n            return resultados\n        finally:\n            try:\n                conexion.logout()\n            except Exception:\n                pass\n\n    @staticmethod\n    def _normalize_for_search(value: str | None) -> str:\n        """Normaliza una cadena removiendo acentos para búsquedas flexibles."""\n        if not value:\n            return ""\n        normalized = unicodedata.normalize("NFD", value)\n        sin_acentos = "".join(ch for ch in normalized if not unicodedata.combining(ch))\n        return sin_acentos.upper()\n\n    def _buscar(self) -> None:\n        cfg = core_config.get_servicios_config()\n        correo_usuario = self._correo_usuario or self.email_session.get("address", "")\n        password = self.email_session.get("password", "")\n        if not correo_usuario or not password:\n            messagebox.showerror(\n                "Sesión",\n                "Debe iniciar sesión en el sistema para consultar el correo.",\n                parent=self,\n            )\n            return\n        self._correo_usuario = correo_usuario\n\n        cadena = cfg.get("cadena_asunto_fija", "NOTIFICACION A PROVEEDOR:")\n        remitente = self.remitente_var.get().strip()\n        try:\n            dt_desde = self._parse_datetime(self.desde_var.get())\n            dt_hasta = self._parse_datetime(self.hasta_var.get())\n        except ValueError:\n            messagebox.showerror("Formato incorrecto", "Ingrese fechas en formato YYYY-MM-DD HH:MM", parent=self)\n            return\n\n        if dt_desde > dt_hasta:\n            messagebox.showerror("Rango inválido", "La fecha inicial no puede ser mayor a la final.", parent=self)\n            return\n\n        logger.info(\n            "Buscando correos: usuario=%s asunto~%s rango=%s-%s",\n            correo_usuario,\n            cadena,\n            dt_desde,\n            dt_hasta,\n        )\n\n        try:\n            registros = self._buscar_correos(\n            correo_usuario,\n            password,\n            cadena,\n            dt_desde,\n            dt_hasta,\n            remitente,\n        )\n        except Exception as exc:\n            logger.exception("Error durante la lectura de correos")\n            messagebox.showerror("Correo", f"No se pudo realizar la búsqueda: {exc}", parent=self)\n            return\n\n        self.tree.delete(*self.tree.get_children())\n        self.records.clear()\n        self.select_all_var.set(False)\n        db.set_config(SERVICIOS_REMITENTE_KEY, remitente)\n        for item in registros:\n            message_id = item["message_id"]\n            estado = "Listo"\n            raw_hash = hashlib.sha256(item["body"].encode("utf-8", "ignore")).hexdigest()\n            registro = {\n                "message_id": message_id,\n                "fecha": item["date"],\n                "asunto": item["subject"],\n                "task_number": item.get("task_number", "N/D"),\n                "taller": item.get("proveedor", "N/D"),\n                "proveedor": item.get("proveedor", "N/D"),\n                "mecanico": item.get("mecanico_nombre", "N/D"),\n                "telefono": item.get("mecanico_telefono", "N/D"),\n                "inf_vehiculo": item.get("inf_vehiculo", "N/D"),\n                "correo_usuario": correo_usuario,\n                "raw_hash": raw_hash,\n                "body": item["body"],\n                "estado": estado,\n                "checked": False,\n                "error": "",\n            }\n            self.records[message_id] = registro\n            reasignaciones_repo.upsert({\n                key: registro.get(key)\n                for key in (\n                    "message_id",\n                    "fecha",\n                    "asunto",\n                    "task_number",\n                    "proveedor",\n                    "mecanico",\n                    "telefono",\n                    "inf_vehiculo",\n                    "correo_usuario",\n                    "raw_hash",\n                )\n            })\n            self.tree.insert(\n                "",\n                "end",\n                iid=message_id,\n                values=(\n                    self._checkbox_symbol(False),\n                    item["date"].strftime("%Y-%m-%d %H:%M"),\n                    registro["task_number"],\n                    registro["taller"],\n                    item["subject"],\n                ),\n            )\n            logger.info(\n                "Correo procesado: id=%s task=%s taller=%s", message_id, registro["task_number"], registro["taller"]\n            )\n        if not registros:\n            messagebox.showinfo("Sin resultados", "No se encontraron correos en el rango especificado.", parent=self)\n\n    def _selected_record(self) -> dict[str, object] | None:\n        sel = self.tree.selection()\n        if not sel:\n            messagebox.showwarning("Selección", "Seleccione un registro.", parent=self)\n            return None\n        return self.records.get(sel[0])\n\n    def _on_select(self, _event) -> None:\n        record = self._selected_record()\n        if not record:\n            return\n        self.preview.config(state="normal")\n        self.preview.delete("1.0", tk.END)\n        self.preview.insert(tk.END, record.get("body", ""))\n        self.preview.config(state="disabled")\n        self.estado_label.configure(text=f"Estado seleccionado: {record.get(\'estado\', \'N/D\')}")\n\n    def _reasignar(self) -> None:\n        objetivos = [r for r in self.records.values() if r.get("checked")]\n        if not objetivos:\n            messagebox.showwarning("Reasignación", "Marque al menos un correo para procesar.", parent=self)\n            return\n        department = self.departamento_var.get().strip()\n        employee = self.usuario_var.get().strip()\n        if not department or not employee:\n            messagebox.showwarning(\n                "Reasignación",\n                "Debe ingresar el departamento y el usuario a quien reasignar.",\n                parent=self,\n            )\n            return\n        comentario_template = db.get_config("SERVICIOS_REASIGNACION_MSG", \'Taller Asignado "{proveedor}"\')\n        exitos = 0\n        fallas = 0\n        no_encontradas = 0\n        pendientes: list[dict[str, object]] = []\n        for record in objetivos:\n            task = record.get("task_number")\n            if not task or task == "N/D":\n                fallas += 1\n                record["estado"] = "Número inválido"\n                record["error"] = "Número de tarea no disponible"\n                self.tree.set(record["message_id"], "seleccion", self._checkbox_symbol(False))\n                record["checked"] = False\n                continue\n            pendientes.append(record)\n\n        resultados = []\n        if pendientes:\n            resultados = reassign_bridge.reassign_tasks(\n                pendientes,\n                fuente="SERVICIOS",\n                department=department,\n                employee=employee,\n                headless=self.headless_var.get(),\n                comentario_template=comentario_template,\n                email_session=self.email_session,\n            )\n        resultado_por_id = {item.get("message_id"): item for item in resultados}\n\n        for record in objetivos:\n            resultado = resultado_por_id.get(record.get("message_id"))\n            if resultado:\n                estado = resultado.get("status", "error")\n                record["estado"] = estado.capitalize()\n                record["error"] = resultado.get("error", "")\n            record["checked"] = False\n            self.tree.set(record["message_id"], "seleccion", self._checkbox_symbol(False))\n\n            estado_actual = record.get("estado", "")\n            estado_lower = estado_actual.lower()\n            if estado_lower == "ok" or estado_lower == "reasignada":\n                exitos += 1\n            elif estado_lower == "not_found":\n                no_encontradas += 1\n            elif estado_lower in {"número inválido", "numero inválido", "numero invalido", "número invalido"}:\n                fallas += 1\n            elif estado_lower == "error":\n                fallas += 1\n            else:\n                fallas += 1\n\n        db.set_config("SERVICIOS_DEPARTAMENTO", department)\n        db.set_config("SERVICIOS_USUARIO", employee)\n        self._sync_master_check()\n\n        resumen = []\n        if exitos:\n            resumen.append(f"{exitos} reasignadas")\n        if no_encontradas:\n            resumen.append(f"{no_encontradas} no encontradas")\n        if fallas:\n            resumen.append(f"{fallas} con error")\n        resumen_texto = ", ".join(resumen) if resumen else "Sin cambios"\n        self.estado_label.configure(text=f"Último resultado: {resumen_texto}")\n\n        if exitos and not fallas and not no_encontradas:\n            messagebox.showinfo("Reasignación", "Tareas reasignadas correctamente.", parent=self)\n        elif exitos or no_encontradas:\n            messagebox.showwarning("Reasignación", resumen_texto.capitalize(), parent=self)\n        else:\n            messagebox.showerror("Reasignación", "No se pudo reasignar ninguna tarea.", parent=self)\n\n        exitosos: list[dict[str, object]] = []\n        fallidos: list[dict[str, object]] = []\n        for record in objetivos:\n            fila_base = {\n                "fecha": record.get("fecha"),\n                "task_number": record.get("task_number", "N/D"),\n                "taller": record.get("taller", "N/D"),\n                "asunto": record.get("asunto", ""),\n            }\n            estado = str(record.get("estado", "")).lower()\n            if estado in {"ok", "reasignada"}:\n                exitosos.append(fila_base)\n            else:\n                error_texto = record.get("error") or record.get("estado", "Error")\n                fila_fallo = dict(fila_base)\n                fila_fallo["error"] = error_texto\n                fallidos.append(fila_fallo)\n\n        try:\n            from gestorcompras.services.reassign_reporter import enviar_reporte_servicios\n\n            enviar_reporte_servicios(\n                self.email_session,\n                self._correo_usuario,\n                exitosos,\n                fallidos,\n            )\n        except Exception:\n            logger.exception("No se pudo enviar el reporte de reasignación")\n\n\ndef open(master: tk.Misc, email_session: dict[str, str], mode: str = "bienes") -> None:\n    if mode == "servicios":\n        ServiciosReasignacion(master, email_session)\n    else:\n        legacy_gui.open_reasignacion(master, email_session)\n',
    'GestorCompras_/gestorcompras/services/db.py': 'import sqlite3\nimport os\nimport json\n\n# Definición de rutas y creación de carpeta de datos\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nDB_DIR = os.path.join(BASE_DIR, "data")\nos.makedirs(DB_DIR, exist_ok=True)\nDB_PATH = os.path.join(DB_DIR, "app.db")\n\ndef get_connection():\n    """\n    Retorna una conexión a la base de datos SQLite.\n    """\n    return sqlite3.connect(DB_PATH)\n\ndef init_db():\n    """\n    Inicializa la base de datos creando las tablas necesarias si no existen.\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    # Tabla de proveedores\n    cursor.execute(\n        """\n        CREATE TABLE IF NOT EXISTS suppliers (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL,\n            ruc TEXT UNIQUE NOT NULL,\n            email TEXT NOT NULL,\n            email_alt TEXT\n        )\n        """\n    )\n    # Aseguramos que la columna email_alt exista en instalaciones antiguas\n    cursor.execute("PRAGMA table_info(suppliers)")\n    cols = [c[1] for c in cursor.fetchall()]\n    if "email_alt" not in cols:\n        cursor.execute("ALTER TABLE suppliers ADD COLUMN email_alt TEXT")\n    # Tabla para tareas temporales\n    cursor.execute("""\n        CREATE TABLE IF NOT EXISTS tasks_temp (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            task_number TEXT NOT NULL,\n            reasignacion TEXT NOT NULL,\n            details TEXT NOT NULL\n        )\n    """)\n    # Configuración de asignación: subdepartamento -> departamento y persona\n    cursor.execute("""\n        CREATE TABLE IF NOT EXISTS config_assignment (\n            subdepartment TEXT PRIMARY KEY,\n            department TEXT NOT NULL,\n            person TEXT NOT NULL\n        )\n    """)\n    # Migrar esquema antiguo si es necesario (solo columnas department/person)\n    cursor.execute("PRAGMA table_info(config_assignment)")\n    cols = [c[1] for c in cursor.fetchall()]\n    if cols == ["department", "person"]:\n        cursor.execute("ALTER TABLE config_assignment RENAME TO config_assignment_old")\n        cursor.execute(\n            """\n            CREATE TABLE config_assignment (\n                subdepartment TEXT PRIMARY KEY,\n                department TEXT NOT NULL,\n                person TEXT NOT NULL\n            )\n            """\n        )\n        cursor.execute(\n            "INSERT INTO config_assignment (subdepartment, department, person) "\n            "SELECT department, \'\', person FROM config_assignment_old"\n        )\n        cursor.execute("DROP TABLE config_assignment_old")\n    # Tabla para configuración general de la aplicación\n    cursor.execute("""\n        CREATE TABLE IF NOT EXISTS app_config (\n            key TEXT PRIMARY KEY,\n            value TEXT NOT NULL\n        )\n    """)\n\n    cursor.execute(\n        """\n        CREATE TABLE IF NOT EXISTS reasignaciones_servicios (\n            id INTEGER PRIMARY KEY,\n            message_id TEXT UNIQUE,\n            fecha DATETIME,\n            asunto TEXT,\n            task_number TEXT,\n            proveedor TEXT,\n            mecanico TEXT,\n            telefono TEXT,\n            inf_vehiculo TEXT,\n            correo_usuario TEXT,\n            raw_hash TEXT,\n            created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n        )\n        """\n    )\n    cursor.execute("PRAGMA table_info(reasignaciones_servicios)")\n    rs_cols = {col[1] for col in cursor.fetchall()}\n    if "task_number" not in rs_cols:\n        cursor.execute("ALTER TABLE reasignaciones_servicios ADD COLUMN task_number TEXT")\n    cursor.execute(\n        "CREATE INDEX IF NOT EXISTS idx_rs_fecha ON reasignaciones_servicios(fecha)"\n    )\n    cursor.execute(\n        "CREATE INDEX IF NOT EXISTS idx_rs_message ON reasignaciones_servicios(message_id)"\n    )\n    cursor.execute(\n        "CREATE INDEX IF NOT EXISTS idx_rs_task ON reasignaciones_servicios(task_number)"\n    )\n\n    # Tabla para formatos de correo personalizados\n    cursor.execute("""\n        CREATE TABLE IF NOT EXISTS email_templates (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT UNIQUE NOT NULL,\n            html TEXT NOT NULL,\n            signature_path TEXT\n        )\n    """)\n    conn.commit()\n    conn.close()\n\n# ------------------ Proveedores ------------------\ndef get_suppliers():\n    """\n    Retorna una lista con los proveedores registrados.\n    Cada elemento es una tupla (id, name, ruc, email, email_alt).\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("SELECT id, name, ruc, email, COALESCE(email_alt, \'\') FROM suppliers")\n    rows = cursor.fetchall()\n    conn.close()\n    return rows\n\n\ndef get_supplier(supplier_id):\n    """Obtiene un proveedor específico por su identificador."""\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "SELECT id, name, ruc, email, COALESCE(email_alt, \'\') FROM suppliers WHERE id=?",\n        (supplier_id,),\n    )\n    row = cursor.fetchone()\n    conn.close()\n    return row\n\ndef add_supplier(name, ruc, email, email_alt=None):\n    """\n    Agrega o actualiza un proveedor en la tabla.\n    El correo secundario es opcional.\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "INSERT OR REPLACE INTO suppliers (name, ruc, email, email_alt) VALUES (?, ?, ?, ?)",\n        (name, ruc, email, email_alt),\n    )\n    conn.commit()\n    conn.close()\n\ndef update_supplier(supplier_id, name, ruc, email, email_alt=None):\n    """\n    Actualiza la información de un proveedor.\n    El correo secundario es opcional.\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "UPDATE suppliers SET name=?, ruc=?, email=?, email_alt=? WHERE id=?",\n        (name, ruc, email, email_alt, supplier_id),\n    )\n    conn.commit()\n    conn.close()\n\ndef delete_supplier(supplier_id):\n    """\n    Elimina un proveedor de la base de datos.\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("DELETE FROM suppliers WHERE id=?", (supplier_id,))\n    conn.commit()\n    conn.close()\n\n# ------------------ Configuración de Asignación Única ------------------\ndef set_assignment_config(subdept: str, department: str, person: str):\n    """Inserta o actualiza la asignación para un subdepartamento."""\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "INSERT OR REPLACE INTO config_assignment (subdepartment, department, person) VALUES (?, ?, ?)",\n        (subdept, department, person),\n    )\n    conn.commit()\n    conn.close()\n\ndef delete_assignment(subdept: str):\n    """Elimina la configuración de un subdepartamento."""\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("DELETE FROM config_assignment WHERE subdepartment=?", (subdept,))\n    conn.commit()\n    conn.close()\n\ndef get_assignments():\n    """Retorna la lista completa de asignaciones."""\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("SELECT subdepartment, department, person FROM config_assignment")\n    rows = cursor.fetchall()\n    conn.close()\n    return rows\n\ndef get_assignment_config():\n    """Retorna un diccionario {subdepartment: {department, person}}."""\n    rows = get_assignments()\n    return {r[0].upper(): {"department": r[1], "person": r[2]} for r in rows}\n\n# ------------------ Tareas Temporales ------------------\ndef clear_tasks_temp():\n    """\n    Elimina todas las tareas temporales registradas.\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("DELETE FROM tasks_temp")\n    conn.commit()\n    conn.close()\n\ndef insert_task_temp(task_number, reasignacion, details_dict):\n    """\n    Inserta una tarea temporal. Los detalles se guardan en formato JSON.\n    Evita duplicados (no inserta la misma task_number dos veces).\n    Retorna True si se insertó la tarea, False si ya existía.\n    """\n    details_json = json.dumps(details_dict)\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("SELECT COUNT(*) FROM tasks_temp WHERE task_number=?", (task_number,))\n    count = cursor.fetchone()[0]\n    inserted = False\n    if count == 0:\n        cursor.execute("INSERT INTO tasks_temp (task_number, reasignacion, details) VALUES (?, ?, ?)",\n                       (task_number, reasignacion, details_json))\n        inserted = True\n    conn.commit()\n    conn.close()\n    return inserted\n\ndef get_tasks_temp():\n    """\n    Retorna la lista de tareas temporales registradas.\n    Cada tarea es un diccionario con las claves: id, task_number, reasignacion, details.\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("SELECT id, task_number, reasignacion, details FROM tasks_temp")\n    rows = cursor.fetchall()\n    conn.close()\n    tasks = []\n    for row in rows:\n        tasks.append({\n            "id": row[0],\n            "task_number": row[1],\n            "reasignacion": row[2],\n            "details": json.loads(row[3])\n        })\n    return tasks\n\ndef delete_task_temp(task_id):\n    """\n    Elimina una tarea temporal específica.\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("DELETE FROM tasks_temp WHERE id=?", (task_id,))\n    conn.commit()\n    conn.close()\n\n# ------------------ Configuración General (app_config) ------------------\ndef get_config(key, default=None):\n    """\n    Retorna el valor asociado a la clave en app_config. Si no existe, retorna default.\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("SELECT value FROM app_config WHERE key=?", (key,))\n    row = cursor.fetchone()\n    conn.close()\n    if row:\n        return row[0]\n    return default\n\ndef set_config(key, value):\n    """\n    Establece o actualiza el valor asociado a la clave en app_config.\n    """\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("INSERT OR REPLACE INTO app_config (key, value) VALUES (?, ?)", (key, value))\n    conn.commit()\n    conn.close()\n\n# ------------------ Email Templates ------------------\ndef get_email_templates():\n    """Retorna la lista de formatos de correo registrados."""\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("SELECT id, name, html, signature_path FROM email_templates")\n    rows = cursor.fetchall()\n    conn.close()\n    return rows\n\ndef search_suppliers(term):\n    """Busca proveedores por coincidencia parcial en nombre o RUC."""\n    conn = get_connection()\n    cursor = conn.cursor()\n    like = f"%{term}%"\n    cursor.execute(\n        "SELECT id, name, ruc, email, COALESCE(email_alt, \'\') FROM suppliers WHERE name LIKE ? OR ruc LIKE ?",\n        (like, like),\n    )\n    rows = cursor.fetchall()\n    conn.close()\n    return rows\n\ndef get_supplier_by_name(name: str):\n    """Retorna la información de un proveedor buscándolo por nombre exacto."""\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "SELECT id, name, ruc, email, COALESCE(email_alt, \'\') FROM suppliers WHERE UPPER(name)=UPPER(?)",\n        (name,),\n    )\n    row = cursor.fetchone()\n    conn.close()\n    return row\n\ndef get_email_template(template_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "SELECT id, name, html, signature_path FROM email_templates WHERE id=?",\n        (template_id,))\n    row = cursor.fetchone()\n    conn.close()\n    return row\n\ndef get_email_template_by_name(name):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "SELECT id, name, html, signature_path FROM email_templates WHERE name=?",\n        (name,))\n    row = cursor.fetchone()\n    conn.close()\n    return row\n\ndef add_email_template(name, html, signature_path=None):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "INSERT INTO email_templates (name, html, signature_path) VALUES (?, ?, ?)",\n        (name, html, signature_path))\n    conn.commit()\n    conn.close()\n\ndef update_email_template(template_id, name, html, signature_path=None):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "UPDATE email_templates SET name=?, html=?, signature_path=? WHERE id=?",\n        (name, html, signature_path, template_id))\n    conn.commit()\n    conn.close()\n\ndef delete_email_template(template_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("DELETE FROM email_templates WHERE id=?", (template_id,))\n    conn.commit()\n    conn.close()\n\n# Inicializamos las tablas al importar el módulo para evitar\n# errores si otras partes del programa acceden a la base de datos\n# antes de abrir la ventana de configuración.\ninit_db()\n',
    'GestorCompras_/gestorcompras/services/reassign_bridge.py': '"""Adaptador para ejecutar la reasignación desde el flujo de Servicios."""\nfrom __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List\n\nfrom gestorcompras.services import db\n\nlogger = logging.getLogger(__name__)\n\n_DEFAULT_TEMPLATE = \'Taller Asignado "{proveedor}"\'\n\n\ndef _normalize_template(template: str | None) -> str:\n    if template is None:\n        template = db.get_config("SERVICIOS_REASIGNACION_MSG", _DEFAULT_TEMPLATE)\n    return template or _DEFAULT_TEMPLATE\n\n\ndef _ensure_credentials(email_session: Dict[str, str] | None) -> tuple[str, str]:\n    if not email_session:\n        raise ValueError("No hay sesión de Telcos disponible.")\n    address = email_session.get("address", "")\n    password = email_session.get("password", "")\n    if not address or not password:\n        raise ValueError("Credenciales incompletas para iniciar sesión en Telcos.")\n    return address, password\n\n\ndef _build_payload(\n    task_number: str,\n    proveedor: str,\n    mecanico: str,\n    telefono: str,\n    inf_vehiculo: str,\n    fuente: str,\n    department: str | None,\n    employee: str | None,\n    comentario_template: str,\n) -> Dict[str, Any]:\n    return {\n        "task_number": task_number,\n        "reasignacion": "",\n        "details": [],\n        "proveedor": proveedor or "N/D",\n        "mecanico": mecanico or "N/D",\n        "telefono": telefono or "N/D",\n        "inf_vehiculo": inf_vehiculo or "N/D",\n        "department_override": (department or "").strip(),\n        "employee_override": (employee or "").strip(),\n        "comentario_template": comentario_template,\n        "fuente": fuente,\n    }\n\n\ndef _create_driver(headless: bool):\n    from selenium import webdriver\n    from selenium.webdriver.chrome.options import Options\n    from selenium.webdriver.chrome.service import Service\n    from webdriver_manager.chrome import ChromeDriverManager\n\n    service = Service(ChromeDriverManager().install())\n    options = Options()\n    if headless:\n        options.add_argument("--headless=new")\n    options.add_argument("--disable-gpu")\n    options.add_argument("--disable-extensions")\n    options.add_argument("--no-sandbox")\n    options.add_argument("--disable-dev-shm-usage")\n    prefs = {"profile.managed_default_content_settings.images": 2}\n    options.add_experimental_option("prefs", prefs)\n    return webdriver.Chrome(service=service, options=options)\n\n\ndef _reanudar_panel(driver) -> None:\n    try:\n        from selenium.webdriver.common.by import By\n\n        from gestorcompras.gui.reasignacion_gui import wait_clickable_or_error\n\n        boton = wait_clickable_or_error(\n            driver,\n            (By.ID, "spanTareasPersonales"),\n            None,\n            "el menú de tareas",\n            timeout=15,\n            retries=1,\n        )\n        driver.execute_script("arguments[0].click();", boton)\n    except Exception as exc:  # pragma: no cover - mejora de resiliencia\n        logger.debug("No se pudo reabrir el panel de tareas: %s", exc)\n\n\ndef _run_selenium_batch(\n    email_session: Dict[str, str],\n    payloads: List[Dict[str, Any]],\n    headless: bool,\n) -> List[Dict[str, Any]]:\n    if not payloads:\n        return []\n\n    from gestorcompras.gui.reasignacion_gui import login_telcos, process_task\n\n    driver = None\n    resultados: List[Dict[str, Any]] = []\n    try:\n        address, password = _ensure_credentials(email_session)\n        driver = _create_driver(headless)\n        login_telcos(driver, address.split("@")[0], password)\n\n        for payload in payloads:\n            message_id = payload.get("message_id")\n            try:\n                process_task(driver, payload, None)\n                _reanudar_panel(driver)\n                resultados.append({\n                    "status": "ok",\n                    "details": payload,\n                    "message_id": message_id,\n                })\n            except Exception as exc:  # pragma: no cover - se registra para diagnóstico\n                estado = "not_found" if "No se encontraron las tareas" in str(exc) else "error"\n                resultados.append({\n                    "status": estado,\n                    "details": payload,\n                    "message_id": message_id,\n                    "error": str(exc),\n                })\n                try:\n                    _reanudar_panel(driver)\n                except Exception:\n                    pass\n        return resultados\n    finally:\n        if driver:\n            driver.quit()\n\n\ndef reassign_by_task_number(\n    task_number: str,\n    proveedor: str,\n    mecanico: str,\n    telefono: str,\n    inf_vehiculo: str,\n    *,\n    fuente: str = "SERVICIOS",\n    department: str | None = None,\n    employee: str | None = None,\n    headless: bool = True,\n    comentario_template: str | None = None,\n    email_session: Dict[str, str] | None = None,\n) -> Dict[str, Any]:\n    """Ejecuta la reasignación de una tarea utilizando Selenium."""\n\n    if not task_number:\n        return {"status": "error", "details": "Número de tarea inválido"}\n\n    template = _normalize_template(comentario_template)\n    payload = _build_payload(\n        task_number,\n        proveedor,\n        mecanico,\n        telefono,\n        inf_vehiculo,\n        fuente,\n        department,\n        employee,\n        template,\n    )\n    payload["message_id"] = None\n\n    resultados = reassign_tasks(\n        [payload],\n        fuente=fuente,\n        department=department,\n        employee=employee,\n        headless=headless,\n        comentario_template=template,\n        email_session=email_session,\n        _prebuilt_payloads=True,\n    )\n    return resultados[0] if resultados else {"status": "error", "details": "Sin resultado"}\n\n\ndef reassign_tasks(\n    records: List[Dict[str, Any]],\n    *,\n    fuente: str = "SERVICIOS",\n    department: str | None = None,\n    employee: str | None = None,\n    headless: bool = True,\n    comentario_template: str | None = None,\n    email_session: Dict[str, str] | None = None,\n    _prebuilt_payloads: bool = False,\n) -> List[Dict[str, Any]]:\n    """Reasigna múltiples tareas reutilizando la misma sesión de navegador."""\n\n    if not records:\n        return []\n\n    template = _normalize_template(comentario_template)\n    payloads: List[Dict[str, Any]] = []\n    if _prebuilt_payloads:\n        payloads = records\n        for payload in payloads:\n            if "comentario_template" not in payload or not payload["comentario_template"]:\n                payload["comentario_template"] = template\n    else:\n        for record in records:\n            task_number = record.get("task_number")\n            payload = _build_payload(\n                str(task_number or ""),\n                record.get("proveedor", ""),\n                record.get("mecanico", ""),\n                record.get("telefono", ""),\n                record.get("inf_vehiculo", ""),\n                fuente,\n                department,\n                employee,\n                template,\n            )\n            payload["message_id"] = record.get("message_id")\n            payloads.append(payload)\n\n    try:\n        resultados = _run_selenium_batch(email_session or {}, payloads, headless)\n        for resultado in resultados:\n            if resultado.get("status") == "ok":\n                detalle = resultado.get("details", {})\n                logger.info(\n                    "Reasignación completada para tarea %s (%s)",\n                    detalle.get("task_number"),\n                    detalle.get("fuente", fuente),\n                )\n        return resultados\n    except ValueError as exc:\n        logger.warning("Reasignación cancelada: %s", exc)\n        return [\n            {\n                "status": "error",\n                "message_id": payload.get("message_id"),\n                "error": str(exc),\n                "details": payload,\n            }\n            for payload in payloads\n        ]\n    except Exception as exc:  # pragma: no cover - protección adicional\n        logger.exception("Error durante la reasignación de tareas")\n        mensaje = str(exc)\n        return [\n            {\n                "status": "error",\n                "message_id": payload.get("message_id"),\n                "error": mensaje,\n                "details": payload,\n            }\n            for payload in payloads\n        ]\n\n\n__all__ = ["reassign_by_task_number", "reassign_tasks"]\n\n',
    'GestorCompras_/gestorcompras/services/reassign_reporter.py': '"""Generación y envío de reportes para la reasignación de Servicios."""\nfrom __future__ import annotations\n\nimport logging\nfrom datetime import datetime\nfrom typing import Iterable, Dict, List\n\nfrom gestorcompras.services.email_sender import send_email_custom\n\nlogger = logging.getLogger(__name__)\n\n_HTML_TEMPLATE = """\n<p>Se adjunta el resumen de tareas procesadas por el módulo de Servicios.</p>\n{% if filas_ok %}\n<h3>Tareas reasignadas correctamente</h3>\n<table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;">\n  <thead>\n    <tr>\n      <th>Fecha</th>\n      <th>Número de tarea</th>\n      <th>Taller</th>\n      <th>Asunto</th>\n    </tr>\n  </thead>\n  <tbody>\n  {% for fila in filas_ok %}\n    <tr>\n      <td>{{ fila.fecha }}</td>\n      <td>{{ fila.task_number }}</td>\n      <td>{{ fila.taller }}</td>\n      <td>{{ fila.asunto }}</td>\n    </tr>\n  {% endfor %}\n  </tbody>\n</table>\n{% endif %}\n{% if filas_fail %}\n<h3>Tareas con inconvenientes</h3>\n<table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;">\n  <thead>\n    <tr>\n      <th>Fecha</th>\n      <th>Número de tarea</th>\n      <th>Taller</th>\n      <th>Asunto</th>\n    </tr>\n  </thead>\n  <tbody>\n  {% for fila in filas_fail %}\n    <tr>\n      <td>{{ fila.fecha }}</td>\n      <td>{{ fila.task_number }}</td>\n      <td>{{ fila.taller }}</td>\n      <td>{{ fila.asunto }}</td>\n    </tr>\n  {% endfor %}\n  </tbody>\n</table>\n{% endif %}\n"""\n\n\ndef _formatear_filas(filas: Iterable[Dict[str, object]]) -> List[Dict[str, str]]:\n    resultado: List[Dict[str, str]] = []\n    for fila in filas:\n        if not fila:\n            continue\n        fecha = fila.get("fecha")\n        if isinstance(fecha, datetime):\n            fecha_str = fecha.strftime("%Y-%m-%d %H:%M")\n        else:\n            fecha_str = str(fecha or "")\n        asunto = str(fila.get("asunto", ""))\n        error = fila.get("error")\n        if error:\n            asunto = f"{asunto} (Error: {error})" if asunto else f"Error: {error}"\n        resultado.append(\n            {\n                "fecha": fecha_str,\n                "task_number": str(fila.get("task_number") or "N/D"),\n                "taller": str(fila.get("taller") or "N/D"),\n                "asunto": asunto,\n            }\n        )\n    return resultado\n\n\ndef enviar_reporte_servicios(\n    email_session: Dict[str, str] | None,\n    destinatario: str | None,\n    exitosos: Iterable[Dict[str, object]] | None,\n    fallidos: Iterable[Dict[str, object]] | None,\n) -> bool:\n    """Envía un resumen de las tareas reasignadas y las que fallaron."""\n\n    if not email_session or not destinatario:\n        logger.debug("No se envía reporte: faltan credenciales o destinatario")\n        return False\n\n    filas_ok = _formatear_filas(exitosos or [])\n    filas_fail = _formatear_filas(fallidos or [])\n\n    if not filas_ok and not filas_fail:\n        logger.debug("No se envía reporte: no hay filas para reportar")\n        return False\n\n    contexto = {\n        "email_to": destinatario,\n        "filas_ok": filas_ok,\n        "filas_fail": filas_fail,\n    }\n\n    try:\n        send_email_custom(\n            email_session,\n            "Reporte de tareas reasignadas",\n            _HTML_TEMPLATE,\n            contexto,\n            cc_key="EMAIL_CC_REASIGNACION",\n        )\n        logger.info("Reporte de reasignación enviado a %s", destinatario)\n        return True\n    except Exception as exc:  # pragma: no cover - la entrega puede fallar por red\n        logger.warning("No se pudo enviar el reporte de reasignación: %s", exc)\n        return False\n\n\n__all__ = ["enviar_reporte_servicios"]\n',
    'GestorCompras_/gestorcompras/ui/__init__.py': '',
    'GestorCompras_/gestorcompras/ui/bienes_home.py': '"""Menú principal para el flujo de Compras Bienes."""\nfrom __future__ import annotations\n\nimport tkinter as tk\nfrom tkinter import messagebox, ttk\n\nfrom gestorcompras.gui import config_gui, seguimientos_gui\nfrom gestorcompras.modules import correos_masivos_gui, descargas_oc_gui, reasignacion_gui\nfrom gestorcompras.ui.common import add_hover_effect\nfrom gestorcompras import theme\n\nbg_frame = theme.bg_frame\ncolor_texto = theme.color_texto\ncolor_titulos = theme.color_titulos\ncolor_primario = theme.color_primario\ncolor_acento = theme.color_acento\n\n\ndef _button_specs():\n    return [\n        ("Reasignación de Tareas", "open_reasignacion"),\n        ("Correos Masivos", "open_correos_masivos"),\n        ("Seguimientos", "open_seguimientos"),\n        ("Descargas OC", "open_descargas_oc"),\n        ("Cotizador", "open_cotizador"),\n        ("Configuración", "open_config"),\n        ("Salir", "quit"),\n    ]\n\n\nclass BienesMenu(ttk.Frame):\n    """Menú existente adaptado para el ruteo desde la pantalla inicial."""\n\n    def __init__(self, master: tk.Misc, email_session: dict[str, str]):\n        super().__init__(master, style="MyFrame.TFrame")\n        self.master = master\n        self.email_session = email_session\n        self._banner_colors = [color_primario, color_acento]\n        self._color_index = 0\n        self._button_widgets: list[ttk.Button] = []\n        self._buttons = _button_specs()\n        self._build()\n\n    def _build(self) -> None:\n        container = ttk.Frame(self, style="MyFrame.TFrame")\n        container.pack(fill="both", expand=True)\n\n        self.banner = ttk.Label(container, text="Sistema de automatización - compras")\n        self.banner.configure(font=("Segoe UI", 20, "bold"), foreground=color_titulos)\n        self.banner.pack(pady=(20, 10))\n        self.after(0, self._animate_banner)\n\n        menu_frame = ttk.Frame(container, style="MyFrame.TFrame", padding=20)\n        menu_frame.pack(pady=20)\n        menu_frame.columnconfigure(0, weight=1)\n\n        lbl_title = ttk.Label(menu_frame, text="Compras Bienes", style="MyLabel.TLabel")\n        lbl_title.configure(font=("Segoe UI", 11, "bold"), foreground=color_titulos)\n        lbl_title.grid(row=0, column=0, pady=15, sticky="n")\n\n        self.menu_frame = menu_frame\n        self._show_button(0)\n\n    def _animate_banner(self) -> None:\n        color = self._banner_colors[self._color_index]\n        self.banner.configure(foreground=color)\n        self._color_index = (self._color_index + 1) % len(self._banner_colors)\n        self.after(800, self._animate_banner)\n\n    def _show_button(self, index: int) -> None:\n        if index >= len(self._buttons):\n            return\n        text, method_name = self._buttons[index]\n        command = getattr(self, method_name)\n        btn = ttk.Button(self.menu_frame, text=text, style="MyButton.TButton", command=command)\n        btn.grid(row=index + 1, column=0, padx=20, pady=5, sticky="ew")\n        add_hover_effect(btn)\n        self._button_widgets.append(btn)\n        self.after(120, self._show_button, index + 1)\n\n    # --- Acciones ---\n    def open_reasignacion(self) -> None:\n        reasignacion_gui.open(self.master, self.email_session, mode="bienes")\n\n    def open_correos_masivos(self) -> None:\n        # Alias que mantiene compatibilidad con la UI anterior\n        correos_masivos_gui.open(self.master, self.email_session)\n\n    def open_seguimientos(self) -> None:\n        seguimientos_gui.open_seguimientos(self.master, self.email_session)\n\n    def open_descargas_oc(self) -> None:\n        descargas_oc_gui.open(self.master)\n\n    def open_config(self) -> None:\n        config_gui.open_config_gui(self.master, self.email_session)\n\n    def open_cotizador(self) -> None:\n        messagebox.showinfo("Cotizador", "Esta opción se encuentra en desarrollo", parent=self.master)\n\n    def quit(self) -> None:\n        if isinstance(self.master, tk.Tk):\n            self.master.quit()\n        else:\n            self.master.winfo_toplevel().quit()\n\n\n__all__ = ["BienesMenu"]\n',
    'GestorCompras_/gestorcompras/ui/common.py': '"""Utilidades compartidas para las pantallas de la interfaz."""\nfrom __future__ import annotations\n\nimport tkinter as tk\nfrom tkinter import ttk\n\n\ndef center_window(win: tk.Tk | tk.Toplevel) -> None:\n    win.update_idletasks()\n    w = win.winfo_width()\n    h = win.winfo_height()\n    x = (win.winfo_screenwidth() // 2) - (w // 2)\n    y = (win.winfo_screenheight() // 2) - (h // 2)\n    win.geometry(f"{w}x{h}+{x}+{y}")\n\n\ndef add_hover_effect(btn: ttk.Button) -> None:\n    """Añade un estilo alternativo mientras el cursor está sobre el botón."""\n\n    def on_enter(_):\n        btn.configure(style="MyButtonHover.TButton")\n\n    def on_leave(_):\n        btn.configure(style="MyButton.TButton")\n\n    btn.bind("<Enter>", on_enter)\n    btn.bind("<Leave>", on_leave)\n',
    'GestorCompras_/gestorcompras/ui/home.py': '"""Pantalla inicial para seleccionar el flujo de compras."""\nfrom __future__ import annotations\n\nimport tkinter as tk\nfrom tkinter import ttk\n\nfrom gestorcompras.ui.common import add_hover_effect\n\n\nclass HomeScreen(ttk.Frame):\n    def __init__(self, master: tk.Misc, on_bienes, on_servicios):\n        super().__init__(master, style="MyFrame.TFrame")\n        self.master = master\n        self._on_bienes = on_bienes\n        self._on_servicios = on_servicios\n        self._build()\n\n    def _build(self) -> None:\n        container = ttk.Frame(self, style="MyFrame.TFrame", padding=(20, 40))\n        container.pack(fill="both", expand=True)\n        container.columnconfigure(0, weight=1)\n\n        titulo = ttk.Label(\n            container,\n            text="¿Qué flujo desea abrir?",\n            style="Banner.TLabel",\n        )\n        titulo.grid(row=0, column=0, pady=(10, 30))\n\n        buttons_row = ttk.Frame(container, style="MyFrame.TFrame")\n        buttons_row.grid(row=1, column=0, pady=10)\n        buttons_row.columnconfigure((0, 1), weight=1)\n\n        btn_bienes = ttk.Button(\n            buttons_row,\n            text="COMPRAS BIENES",\n            style="MyButton.TButton",\n            command=self._on_bienes,\n        )\n        btn_bienes.grid(row=0, column=0, padx=(0, 12))\n        btn_bienes.configure(width=25)\n        add_hover_effect(btn_bienes)\n\n        btn_servicios = ttk.Button(\n            buttons_row,\n            text="COMPRAS SERVICIOS",\n            style="MyButton.TButton",\n            command=self._on_servicios,\n        )\n        btn_servicios.grid(row=0, column=1, padx=(12, 0))\n        btn_servicios.configure(width=25)\n        add_hover_effect(btn_servicios)\n',
    'GestorCompras_/gestorcompras/ui/router.py': '"""Ruteo centralizado entre pantallas principales."""\nfrom __future__ import annotations\n\nimport tkinter as tk\n\nfrom gestorcompras.ui.home import HomeScreen\nfrom gestorcompras.ui.bienes_home import BienesMenu\nfrom gestorcompras.ui.servicios_home import ServiciosHome\n\n_container: tk.Misc | None = None\n_email_session: dict[str, str] | None = None\n\n\ndef configure(container: tk.Misc, email_session: dict[str, str]) -> None:\n    global _container, _email_session\n    _container = container\n    _email_session = email_session\n    open_home()\n\n\ndef _clear_container() -> None:\n    if _container is None:\n        raise RuntimeError("Router no inicializado")\n    for widget in list(_container.winfo_children()):\n        widget.destroy()\n\n\ndef open_home() -> None:\n    _clear_container()\n    screen = HomeScreen(_container, open_bienes_menu, open_servicios_menu)\n    screen.pack(fill="both", expand=True)\n\n\ndef open_bienes_menu() -> None:\n    if _email_session is None:\n        raise RuntimeError("Sesión de correo no inicializada")\n    _clear_container()\n    BienesMenu(_container, _email_session).pack(fill="both", expand=True)\n\n\ndef open_servicios_menu() -> None:\n    if _email_session is None:\n        raise RuntimeError("Sesión de correo no inicializada")\n    _clear_container()\n    ServiciosHome(_container, _email_session).pack(fill="both", expand=True)\n',
    'GestorCompras_/gestorcompras/ui/servicios_home.py': '"""Menú principal para el flujo de Compras Servicios."""\nfrom __future__ import annotations\n\nimport tkinter as tk\nfrom tkinter import ttk\n\nfrom gestorcompras.modules import correos_masivos_gui, descargas_oc_gui, config_gui, reasignacion_gui\nfrom gestorcompras.ui.common import add_hover_effect\n\n\nclass ServiciosHome(ttk.Frame):\n    def __init__(self, master: tk.Misc, email_session: dict[str, str]):\n        super().__init__(master, style="MyFrame.TFrame")\n        self.master = master\n        self.email_session = email_session\n        self._build()\n\n    def _build(self) -> None:\n        container = ttk.Frame(self, style="MyFrame.TFrame", padding=30)\n        container.pack(fill="both", expand=True)\n        container.columnconfigure(0, weight=1)\n\n        titulo = ttk.Label(\n            container,\n            text="Compras Servicios",\n            style="Banner.TLabel",\n        )\n        titulo.grid(row=0, column=0, pady=(10, 30))\n\n        self._add_button(\n            container,\n            row=1,\n            text="Configuraciones",\n            command=lambda: config_gui.open(self.master, self.email_session, mode="servicios"),\n        )\n        self._add_button(\n            container,\n            row=2,\n            text="Correos Masivos",\n            command=lambda: correos_masivos_gui.open(self.master, self.email_session),\n        )\n        self._add_button(\n            container,\n            row=3,\n            text="Descargas OC",\n            command=lambda: descargas_oc_gui.open(self.master),\n        )\n        self._add_button(\n            container,\n            row=4,\n            text="Reasignación de tareas",\n            command=lambda: reasignacion_gui.open(self.master, self.email_session, mode="servicios"),\n        )\n\n    def _add_button(self, container: ttk.Frame, row: int, text: str, command) -> None:\n        btn = ttk.Button(\n            container,\n            text=text,\n            style="MyButton.TButton",\n            command=command,\n        )\n        btn.grid(row=row, column=0, pady=10, sticky="ew")\n        btn.configure(width=35)\n        add_hover_effect(btn)\n',
    'GestorCompras_/requirements.txt': 'jinja2\npdfplumber\npandas\nopenpyxl\nselenium\nwebdriver_manager\npsutil\n',
    'GestorCompras_/tests/test_mail_parse.py': 'import pytest\n\nfrom gestorcompras.core.mail_parse import parse_body, parse_subject\n\n\n@pytest.mark.parametrize(\n    "subject,expected",\n    [\n        ("NOTIFICACION A PROVEEDOR: TAREA: \\"142959682\\"", "142959682"),\n        ("Aviso - TAREA:\\"123456\\"", "123456"),\n        ("TAREA: 987654321 - actualización", "987654321"),\n        ("Sin número", "N/D"),\n    ],\n)\ndef test_parse_subject(subject, expected):\n    assert parse_subject(subject)["task_number"] == expected\n\n\n@pytest.mark.parametrize(\n    "body,correo,expect_found",\n    [\n        (\n            "Estimados \\"Proveedor Uno\\"\\ncoordinando el mantenimiento con \\"Juan Perez (0999999999)\\".\\n\\"OT-12345\\"",\n            "user@telconet.ec",\n            False,\n        ),\n        (\n            "Estimados \\"Proveedor Dos\\" correo user@telconet.ec\\ncoordinando el mantenimiento con \\"María López (09-888-7777)\\"\\n\\"OT 98765\\"",\n            "user@telconet.ec",\n            True,\n        ),\n        (\n            "Estimados \\"Proveedor Tres\\"\\ncoordinando el mantenimiento con \\"Carlos Gómez (593-2-123456)\\"\\n\\"OT 222\\"",\n            "otro@telconet.ec",\n            False,\n        ),\n    ],\n)\ndef test_parse_body_identifica_correo(body, correo, expect_found):\n    parsed = parse_body(body, correo)\n    assert parsed["correo_usuario_encontrado"] is expect_found\n\n\n@pytest.mark.parametrize(\n    "body,expected_tel",\n    [\n        ("coordinando el mantenimiento con \\"Nombre (09-999-8888)\\".", "099998888"),\n        ("coordinando el mantenimiento con \\"Nombre (593099998888)\\".", "593099998888"),\n        ("coordinando el mantenimiento con \\"Nombre (09 999 8888)\\".", "099998888"),\n    ],\n)\ndef test_parse_body_normaliza_telefono(body, expected_tel):\n    parsed = parse_body(body, "user@telconet.ec")\n    assert parsed["mecanico_telefono"] == expected_tel\n\n\ndef test_parse_body_mojibake_y_comillas_tipograficas():\n    cuerpo = (\n        "Estimados “ProveedÃ³r Ñandú”\\n"\n        "coordinando el mantenimiento con “Mecánico (09 111 2222)”\\n"\n        "“OT para revisión” user@telconet.ec"\n    )\n    parsed = parse_body(cuerpo, "user@telconet.ec")\n    assert parsed["proveedor"] == "Proveedór Ñandú"\n    assert parsed["mecanico_nombre"] == "Mecánico"\n    assert parsed["mecanico_telefono"] == "091112222"\n    assert parsed["inf_vehiculo"].startswith("OT")\n    assert parsed["correo_usuario_encontrado"] is True\n\n\ndef test_parse_body_valores_por_defecto():\n    parsed = parse_body("Sin coincidencias", "user@telconet.ec")\n    assert parsed["proveedor"] == "N/D"\n    assert parsed["mecanico_nombre"] == "N/D"\n    assert parsed["mecanico_telefono"] == "N/D"\n    assert parsed["inf_vehiculo"] == "N/D"\n\n\ndef test_parse_body_formato_servicios():\n    cuerpo = (\n        "Estimados MAVESA QUITO\\n"\n        "Su ayuda coordinando el mantenimiento con Miguel García (093-558-7896)\\n"\n        "[GTI-1566] [107082] OT MG-3363 MANT, GREAT WALL 335 GTI-1566 KM 107082\\n"\n        "Agradezco su atención\\n"\n        "Sistema Compras - Alex Cárdenas\\n"\n        "AVISO IMPORTANTE: Dirija cualquier consulta a acardenas@telconet.ec\\n"\n    )\n    parsed = parse_body(cuerpo, "acardenas@telconet.ec")\n    assert parsed["proveedor"] == "MAVESA QUITO"\n    assert parsed["mecanico_nombre"] == "Miguel García"\n    assert parsed["mecanico_telefono"] == "0935587896"\n    assert "OT" in parsed["inf_vehiculo"]\n    assert parsed["correo_usuario_encontrado"] is True\n',
    'GestorCompras_/tests/test_reasignacion_busqueda.py': 'import pytest\n\nfrom gestorcompras.modules.reasignacion_gui import ServiciosReasignacion\n\n\ndef test_normaliza_busqueda_sin_acentos():\n    normalizado = ServiciosReasignacion._normalize_for_search("Notificación a Proveedor: Tarea")\n    assert "NOTIFICACION A PROVEEDOR" in normalizado\n\n\n@pytest.mark.parametrize(\n    "subject",\n    [\n        "Notificación a Proveedor: aviso",\n        "notificacion a proveedor: actualización",\n        "Aviso NOTIFICACIÓN A PROVEEDOR: detalle",\n    ],\n)\ndef test_subcadena_detectada(subject):\n    patron = ServiciosReasignacion._normalize_for_search("NOTIFICACION A PROVEEDOR:")\n    sujeto = ServiciosReasignacion._normalize_for_search(subject)\n    assert patron in sujeto\n',
    'GestorCompras_/tests/test_reassign_bridge.py': 'from gestorcompras.services import reassign_bridge\n\n\ndef _session():\n    return {"address": "usuario@telconet.ec", "password": "secreto"}\n\n\ndef test_reassign_ok(monkeypatch):\n    capturas = {}\n\n    def _fake_batch(session, payloads, headless):\n        capturas["session"] = session\n        capturas["payloads"] = payloads\n        capturas["headless"] = headless\n        return [\n            {\n                "status": "ok",\n                "details": payloads[0],\n                "message_id": payloads[0].get("message_id"),\n            }\n        ]\n\n    monkeypatch.setattr(reassign_bridge, "_run_selenium_batch", _fake_batch)\n\n    resultado = reassign_bridge.reassign_by_task_number(\n        "123",\n        "Proveedor",\n        "Mecánico",\n        "0999",\n        "OT",\n        fuente="SERVICIOS",\n        department="Compras",\n        employee="jdoe",\n        headless=False,\n        comentario_template=\'Taller Asignado "{proveedor}"\',\n        email_session=_session(),\n    )\n\n    assert resultado["status"] == "ok"\n    assert capturas["payloads"][0]["task_number"] == "123"\n    assert capturas["payloads"][0]["department_override"] == "Compras"\n    assert capturas["headless"] is False\n\n\ndef test_reassign_not_found(monkeypatch):\n    def _fake_batch(_session, payloads, _headless):\n        return [\n            {\n                "status": "not_found",\n                "details": payloads[0],\n                "message_id": payloads[0].get("message_id"),\n                "error": "No se encontraron las tareas en la plataforma Telcos.\\nTarea: 999",\n            }\n        ]\n\n    monkeypatch.setattr(reassign_bridge, "_run_selenium_batch", _fake_batch)\n\n    resultado = reassign_bridge.reassign_by_task_number(\n        "999",\n        "Prov",\n        "Mec",\n        "0",\n        "OT",\n        email_session=_session(),\n    )\n\n    assert resultado["status"] == "not_found"\n\n\ndef test_reassign_error(monkeypatch):\n    def _fake_batch(_session, _payloads, _headless):\n        raise Exception("Fallo inesperado")\n\n    monkeypatch.setattr(reassign_bridge, "_run_selenium_batch", _fake_batch)\n\n    resultado = reassign_bridge.reassign_by_task_number(\n        "500",\n        "Prov",\n        "Mec",\n        "0",\n        "OT",\n        email_session=_session(),\n    )\n\n    assert resultado["status"] == "error"\n\n\ndef test_reassign_tasks_batch_error(monkeypatch):\n    def _fake_batch(_session, payloads, _headless):\n        raise ValueError("Sin credenciales")\n\n    monkeypatch.setattr(reassign_bridge, "_run_selenium_batch", _fake_batch)\n\n    registros = [\n        {\n            "task_number": "111",\n            "proveedor": "Proveedor",\n            "mecanico": "Mec",\n            "telefono": "0999",\n            "inf_vehiculo": "OT",\n            "message_id": "mid-1",\n        }\n    ]\n\n    resultados = reassign_bridge.reassign_tasks(\n        registros,\n        fuente="SERVICIOS",\n        department="Compras",\n        employee="usuario",\n        comentario_template="Taller Asignado \\"{proveedor}\\"",\n        email_session=_session(),\n    )\n\n    assert resultados[0]["status"] == "error"\n    assert resultados[0]["message_id"] == "mid-1"\n',
    'GestorCompras_/tests/test_reassign_reporter.py': 'from datetime import datetime\n\nfrom gestorcompras.services import reassign_reporter\n\n\ndef test_enviar_reporte_envia_con_filas(monkeypatch):\n    capturas = {}\n\n    def _fake_send(session, subject, template, context, **kwargs):\n        capturas["session"] = session\n        capturas["subject"] = subject\n        capturas["context"] = context\n\n    monkeypatch.setattr(reassign_reporter, "send_email_custom", _fake_send)\n\n    email_session = {"address": "usuario@telconet.ec", "password": "secreto"}\n    filas = [\n        {\n            "fecha": datetime(2024, 5, 1, 8, 30),\n            "task_number": "123456",\n            "taller": "Proveedor",\n            "asunto": "Aviso",\n        }\n    ]\n\n    resultado = reassign_reporter.enviar_reporte_servicios(email_session, "dest@telconet.ec", filas, [])\n\n    assert resultado is True\n    assert capturas["subject"] == "Reporte de tareas reasignadas"\n    assert capturas["context"]["filas_ok"][0]["task_number"] == "123456"\n\n\ndef test_enviar_reporte_sin_datos(monkeypatch):\n    enviado = reassign_reporter.enviar_reporte_servicios(\n        {"address": "usuario@telconet.ec", "password": "secreto"},\n        "dest@telconet.ec",\n        [],\n        [],\n    )\n\n    assert enviado is False\n',
}

def ensure_parent(path: Path):
    path.parent.mkdir(parents=True, exist_ok=True)


def write_file(path: Path, content: str):
    ensure_parent(path)
    path.write_text(content, encoding='utf-8')

def main():
    for rel, content in FILES.items():
        write_file(ROOT / rel, content)
    print(f'Se actualizaron {len(FILES)} archivos.')


if __name__ == '__main__':
    main()
